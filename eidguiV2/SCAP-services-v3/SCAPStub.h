/* SCAPStub.h
   Generated by gSOAP 2.8.49 for SCAP-Services.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <deque>
#include <list>
#include <vector>
#include <set>
#define SOAP_NAMESPACE_OF_ns1	"http://www.cartaodecidadao.pt/ccc/sccc/services/AttributeClientService"
#define SOAP_NAMESPACE_OF_ns2	"http://www.cartaodecidadao.pt/ccc/sccc/messages/AttributeClientService"
#define SOAP_NAMESPACE_OF_ns5	"http://www.w3.org/2000/09/xmldsig#"
#define SOAP_NAMESPACE_OF_ns3	"http://www.cartaodecidadao.pt/ccc/commons/messages/Attribute"
#define SOAP_NAMESPACE_OF_ns4	"http://www.cartaodecidadao.pt/ccc/commons/messages/Types"
#define SOAP_NAMESPACE_OF_ns6	"http://uri.etsi.org/01903/v1.3.2#"
#define SOAP_NAMESPACE_OF_ns7	"http://www.cartaodecidadao.pt/ccc/commons/messages/SVG"
#define SOAP_NAMESPACE_OF_ns8	"http://www.cartaodecidadao.pt/ccc/sccc/services/AttributeSupplierService"
#define SOAP_NAMESPACE_OF_ns9	"http://www.cartaodecidadao.pt/ccc/sccc/messages/AttributeSupplierService"
#define SOAP_NAMESPACE_OF_ns1	"http://www.cartaodecidadao.pt/ccc/tipos/SCAPSignature"
#define SOAP_WSA_200408

#ifndef SCAPStub_H
#define SCAPStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20849
# error "GSOAP VERSION 20849 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* wsa.h:119 */
#ifndef SOAP_TYPE_wsa__RelationshipTypeValues
#define SOAP_TYPE_wsa__RelationshipTypeValues (314)
/* wsa:RelationshipTypeValues */
enum wsa__RelationshipTypeValues {
	wsa__Reply = 0
};
#endif

/* wsa.h:127 */
#ifndef SOAP_TYPE_wsa__FaultSubcodeValues
#define SOAP_TYPE_wsa__FaultSubcodeValues (315)
/* wsa:FaultSubcodeValues */
enum wsa__FaultSubcodeValues {
	wsa__InvalidMessageInformationHeader = 0,
	wsa__MessageInformationHeaderRequired = 1,
	wsa__DestinationUnreachable = 2,
	wsa__ActionNotSupported = 3,
	wsa__EndpointUnavailable = 4
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class xsd__base64Binary;	/* SCAP-Services.h:199 */
class ns2__AttributeRequestType;	/* SCAP-Services.h:227 */
class ns2__SingleAttributeRequestType;	/* SCAP-Services.h:230 */
class ns2__PSAAttributeRequestType;	/* SCAP-Services.h:233 */
class ns2__AttributeSupplierListType;	/* SCAP-Services.h:236 */
class ns2__AttributeResponseType;	/* SCAP-Services.h:239 */
class ns2__SingleAttributeResponseType;	/* SCAP-Services.h:242 */
class ns2__UnsignedAttributeResponseType;	/* SCAP-Services.h:245 */
class ns2__AttributesType;	/* SCAP-Services.h:248 */
class ns2__UnsignedAttributesType;	/* SCAP-Services.h:251 */
class ns2__SignedAttributesType;	/* SCAP-Services.h:254 */
class ns2__UnsignedAttributesBasicType;	/* SCAP-Services.h:257 */
class ns2__ResponseResult;	/* SCAP-Services.h:260 */
class ns5__SignatureType;	/* SCAP-Services.h:263 */
class ns5__SignedInfoType;	/* SCAP-Services.h:266 */
class ns5__CanonicalizationMethodType;	/* SCAP-Services.h:269 */
class ns5__SignatureMethodType;	/* SCAP-Services.h:272 */
class ns5__ReferenceType;	/* SCAP-Services.h:275 */
class ns5__TransformsType;	/* SCAP-Services.h:278 */
class ns5__TransformType;	/* SCAP-Services.h:281 */
class ns5__DigestMethodType;	/* SCAP-Services.h:284 */
class ns5__KeyInfoType;	/* SCAP-Services.h:287 */
class ns5__X509DataType;	/* SCAP-Services.h:290 */
union _ns5__union_ObjectType;	/* SCAP-Services.h:1309 */
class ns5__ObjectType;	/* SCAP-Services.h:293 */
class ns3__AttributeType;	/* SCAP-Services.h:305 */
class ns3__AttributeSupplierType;	/* SCAP-Services.h:308 */
class ns3__PersonalDataType;	/* SCAP-Services.h:311 */
class ns3__ExtraIDListType;	/* SCAP-Services.h:314 */
class ns3__ExtraIDType;	/* SCAP-Services.h:317 */
class ns3__MainAttributeType;	/* SCAP-Services.h:320 */
class ns3__LegalActListType;	/* SCAP-Services.h:323 */
class ns3__SubAttributeListType;	/* SCAP-Services.h:326 */
class ns3__SubAttributeType;	/* SCAP-Services.h:329 */
class ns3__ResponseCodeStatusType;	/* SCAP-Services.h:332 */
class ns6__QualifyingPropertiesType;	/* SCAP-Services.h:335 */
class ns6__SignedPropertiesType;	/* SCAP-Services.h:338 */
class ns6__SignedSignaturePropertiesType;	/* SCAP-Services.h:341 */
class ns6__SigningCertificateType;	/* SCAP-Services.h:344 */
class ns6__CertType;	/* SCAP-Services.h:347 */
class ns6__CertDigestType;	/* SCAP-Services.h:350 */
class ns6__IssuerSerialType;	/* SCAP-Services.h:353 */
class ns6__SignerRoleType;	/* SCAP-Services.h:356 */
class ns6__ClaimedRolesListType;	/* SCAP-Services.h:359 */
class ns6__ClaimedRoleType;	/* SCAP-Services.h:362 */
class ns6__UnsignedPropertiesType;	/* SCAP-Services.h:365 */
class ns6__UnsignedSignaturePropertiesType;	/* SCAP-Services.h:368 */
class ns6__CounterSignatureType;	/* SCAP-Services.h:371 */
class ns6__SignatureTimeStampType;	/* SCAP-Services.h:374 */
class ns6__CompleteCertificateRefsType;	/* SCAP-Services.h:377 */
class ns6__CertRefsType;	/* SCAP-Services.h:380 */
class ns6__CompleteRevocationRefsType;	/* SCAP-Services.h:383 */
class ns6__CRLRefsType;	/* SCAP-Services.h:386 */
class ns6__CRLRefType;	/* SCAP-Services.h:389 */
class ns6__DigestAlgAndValueType;	/* SCAP-Services.h:392 */
class ns6__CRLIdentifierType;	/* SCAP-Services.h:395 */
class ns6__OCSPRefsType;	/* SCAP-Services.h:398 */
class ns6__OCSPRefType;	/* SCAP-Services.h:401 */
class ns6__OCSPIdentifierType;	/* SCAP-Services.h:404 */
class ns6__ResponderIDType;	/* SCAP-Services.h:407 */
class ns6__SigAndRefsTimeStampType;	/* SCAP-Services.h:410 */
class ns6__CertificateValuesType;	/* SCAP-Services.h:413 */
class ns6__RevocationValuesType;	/* SCAP-Services.h:419 */
class ns6__CRLValuesType;	/* SCAP-Services.h:422 */
class ns6__OCSPValuesType;	/* SCAP-Services.h:428 */
class ns6__ArchiveTimeStampType;	/* SCAP-Services.h:434 */
class ns7__SVGListType;	/* SCAP-Services.h:452 */
class ns9__AttributeSupplierResponseType;	/* SCAP-Services.h:455 */
class ns1__PersonalData;	/* SCAP-Services.h:458 */
class ns1__AttributeListType;	/* SCAP-Services.h:461 */
class ns1__AttributeType;	/* SCAP-Services.h:464 */
class ns1__AttributeSupplierType;	/* SCAP-Services.h:467 */
class ns1__MainAttributeType;	/* SCAP-Services.h:470 */
class ns1__LegalActListType;	/* SCAP-Services.h:473 */
class ns1__SubAttributeListType;	/* SCAP-Services.h:476 */
class ns1__SubAttributeType;	/* SCAP-Services.h:479 */
class ns1__Status;	/* SCAP-Services.h:482 */
class ns1__TransactionTypeList;	/* SCAP-Services.h:485 */
class ns1__TransactionType;	/* SCAP-Services.h:488 */
class _ns1__AuthorizationRequest;	/* SCAP-Services.h:491 */
class _ns1__AuthorizationResponse;	/* SCAP-Services.h:494 */
class _ns1__SignatureRequest;	/* SCAP-Services.h:497 */
class _ns1__SignatureResponse;	/* SCAP-Services.h:500 */
class ns5__X509CertificateType;	/* SCAP-Services.h:296 */
class ns5__DigestValueType;	/* SCAP-Services.h:299 */
class ns5__SignatureValueType;	/* SCAP-Services.h:302 */
class ns6__EncapsulatedX509CertificateType;	/* SCAP-Services.h:416 */
class ns6__EncapsulatedCRLValueType;	/* SCAP-Services.h:425 */
class ns6__EncapsulatedOCSPValueType;	/* SCAP-Services.h:431 */
struct wsa__EndpointReferenceType;	/* wsa.h:94 */
struct wsa__ReferencePropertiesType;	/* wsa.h:97 */
struct wsa__ReferenceParametersType;	/* wsa.h:100 */
struct wsa__ServiceNameType;	/* wsa.h:103 */
struct wsa__Relationship;	/* wsa.h:106 */
struct __ns1__Attributes;	/* SCAP-Services.h:3383 */
struct __ns2__Authorization;	/* SCAP-Services.h:3471 */
struct __ns3__Signature;	/* SCAP-Services.h:3559 */
struct __ns8__AttributeSuppliers;	/* SCAP-Services.h:3644 */

/* SCAP-Services.h:199 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (11)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XSD type 'xsd:string'
        char *id;
        /// Optional element 'type' of XSD type 'xsd:string'
        char *type;
        /// Optional element 'options' of XSD type 'xsd:string'
        char *options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW(xsd__base64Binary); }
      public:
        /// Constructor with initializations
        xsd__base64Binary() : __ptr(), __size(), id(), type(), options(), soap()
        { }
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 SCAP_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:227 */
#ifndef SOAP_TYPE_ns2__AttributeRequestType
#define SOAP_TYPE_ns2__AttributeRequestType (21)
/* complex XSD type 'ns2:AttributeRequestType': */
class SOAP_CMAC ns2__AttributeRequestType {
      public:
        /// Required element 'ns2:ProcessId' of XSD type 'ns4:ProcessIDType'
        std::string ProcessId;
        /// Required element 'ns2:Citizen' of XSD type 'ns3:PersonalDataType'
        ns3__PersonalDataType *Citizen;
        /// Required element 'ns2:AttributeSuppliers' of XSD type 'ns2:AttributeSupplierListType'
        ns2__AttributeSupplierListType *AttributeSuppliers;
        /// Optional element 'ns2:AllEnterprises' of XSD type 'xsd:boolean'
        bool *AllEnterprises;
        /// Optional element 'ns2:AppId' of XSD type 'xsd:string'
        std::string *AppId;
        /// Optional element 'ns2:AppName' of XSD type 'xsd:string'
        std::string *AppName;
        /// Optional element 'ns2:SecretKey' of XSD type 'xsd:string'
        std::string *SecretKey;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AttributeRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AttributeRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AttributeRequestType, default initialized and not managed by a soap context
        virtual ns2__AttributeRequestType *soap_alloc(void) const { return SOAP_NEW(ns2__AttributeRequestType); }
      public:
        /// Constructor with initializations
        ns2__AttributeRequestType() : ProcessId(), Citizen(), AttributeSuppliers(), AllEnterprises(), AppId(), AppName(), SecretKey(), soap()
        { }
        virtual ~ns2__AttributeRequestType() { }
        /// Friend allocator used by soap_new_ns2__AttributeRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns2__AttributeRequestType * SOAP_FMAC2 SCAP_instantiate_ns2__AttributeRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:230 */
#ifndef SOAP_TYPE_ns2__SingleAttributeRequestType
#define SOAP_TYPE_ns2__SingleAttributeRequestType (22)
/* complex XSD type 'ns2:SingleAttributeRequestType': */
class SOAP_CMAC ns2__SingleAttributeRequestType {
      public:
        /// Required element 'ns2:ProcessId' of XSD type 'ns4:ProcessIDType'
        std::string ProcessId;
        /// Required element 'ns2:Citizen' of XSD type 'ns3:PersonalDataType'
        ns3__PersonalDataType *Citizen;
        /// Required element 'ns2:AttributeSuppliers' of XSD type 'ns3:AttributeSupplierType'
        ns3__AttributeSupplierType *AttributeSuppliers;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SingleAttributeRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__SingleAttributeRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SingleAttributeRequestType, default initialized and not managed by a soap context
        virtual ns2__SingleAttributeRequestType *soap_alloc(void) const { return SOAP_NEW(ns2__SingleAttributeRequestType); }
      public:
        /// Constructor with initializations
        ns2__SingleAttributeRequestType() : ProcessId(), Citizen(), AttributeSuppliers(), soap()
        { }
        virtual ~ns2__SingleAttributeRequestType() { }
        /// Friend allocator used by soap_new_ns2__SingleAttributeRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns2__SingleAttributeRequestType * SOAP_FMAC2 SCAP_instantiate_ns2__SingleAttributeRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:233 */
#ifndef SOAP_TYPE_ns2__PSAAttributeRequestType
#define SOAP_TYPE_ns2__PSAAttributeRequestType (23)
/* complex XSD type 'ns2:PSAAttributeRequestType': */
class SOAP_CMAC ns2__PSAAttributeRequestType {
      public:
        /// Required element 'ns2:ProcessId' of XSD type 'ns4:ProcessIDType'
        std::string ProcessId;
        /// Required element 'ns2:Citizen' of XSD type 'ns3:PersonalDataType'
        ns3__PersonalDataType *Citizen;
        /// Optional element 'ns2:CompanyId' of XSD type 'ns4:NIPCType'
        std::string *CompanyId;
        /// Optional element 'ns2:CompanyName' of XSD type 'ns4:CompanyNameType'
        std::string *CompanyName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PSAAttributeRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PSAAttributeRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PSAAttributeRequestType, default initialized and not managed by a soap context
        virtual ns2__PSAAttributeRequestType *soap_alloc(void) const { return SOAP_NEW(ns2__PSAAttributeRequestType); }
      public:
        /// Constructor with initializations
        ns2__PSAAttributeRequestType() : ProcessId(), Citizen(), CompanyId(), CompanyName(), soap()
        { }
        virtual ~ns2__PSAAttributeRequestType() { }
        /// Friend allocator used by soap_new_ns2__PSAAttributeRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns2__PSAAttributeRequestType * SOAP_FMAC2 SCAP_instantiate_ns2__PSAAttributeRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:236 */
#ifndef SOAP_TYPE_ns2__AttributeSupplierListType
#define SOAP_TYPE_ns2__AttributeSupplierListType (24)
/* complex XSD type 'ns2:AttributeSupplierListType': */
class SOAP_CMAC ns2__AttributeSupplierListType {
      public:
        /// Required element 'ns2:AttributeSupplier' of XSD type 'ns3:AttributeSupplierType'
        std::vector<ns3__AttributeSupplierType *> AttributeSupplier;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AttributeSupplierListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AttributeSupplierListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AttributeSupplierListType, default initialized and not managed by a soap context
        virtual ns2__AttributeSupplierListType *soap_alloc(void) const { return SOAP_NEW(ns2__AttributeSupplierListType); }
      public:
        /// Constructor with initializations
        ns2__AttributeSupplierListType() : AttributeSupplier(), soap()
        { }
        virtual ~ns2__AttributeSupplierListType() { }
        /// Friend allocator used by soap_new_ns2__AttributeSupplierListType(struct soap*, int)
        friend SOAP_FMAC1 ns2__AttributeSupplierListType * SOAP_FMAC2 SCAP_instantiate_ns2__AttributeSupplierListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:239 */
#ifndef SOAP_TYPE_ns2__AttributeResponseType
#define SOAP_TYPE_ns2__AttributeResponseType (25)
/* complex XSD type 'ns2:AttributeResponseType': */
class SOAP_CMAC ns2__AttributeResponseType {
      public:
        /// Required element 'ns2:ProcessId' of XSD type 'ns4:ProcessIDType'
        std::string ProcessId;
        /// Required element 'ns2:AttributeResponseValues' of XSD type 'ns2:AttributesType'
        std::vector<ns2__AttributesType *> AttributeResponseValues;
        /// Optional element 'ns2:ErrorMessage' of XSD type 'xsd:string'
        std::string *ErrorMessage;
        /// Optional element 'ns2:AppId' of XSD type 'xsd:string'
        std::string *AppId;
        /// Optional element 'ns2:SecretKey' of XSD type 'xsd:string'
        std::string *SecretKey;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AttributeResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AttributeResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AttributeResponseType, default initialized and not managed by a soap context
        virtual ns2__AttributeResponseType *soap_alloc(void) const { return SOAP_NEW(ns2__AttributeResponseType); }
      public:
        /// Constructor with initializations
        ns2__AttributeResponseType() : ProcessId(), AttributeResponseValues(), ErrorMessage(), AppId(), SecretKey(), soap()
        { }
        virtual ~ns2__AttributeResponseType() { }
        /// Friend allocator used by soap_new_ns2__AttributeResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns2__AttributeResponseType * SOAP_FMAC2 SCAP_instantiate_ns2__AttributeResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:242 */
#ifndef SOAP_TYPE_ns2__SingleAttributeResponseType
#define SOAP_TYPE_ns2__SingleAttributeResponseType (26)
/* complex XSD type 'ns2:SingleAttributeResponseType': */
class SOAP_CMAC ns2__SingleAttributeResponseType {
      public:
        /// Required element 'ns2:ProcessId' of XSD type 'ns4:ProcessIDType'
        std::string ProcessId;
        /// Required element 'ns2:AttributeResponseValues' of XSD type 'ns2:AttributesType'
        ns2__AttributesType *AttributeResponseValues;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SingleAttributeResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__SingleAttributeResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SingleAttributeResponseType, default initialized and not managed by a soap context
        virtual ns2__SingleAttributeResponseType *soap_alloc(void) const { return SOAP_NEW(ns2__SingleAttributeResponseType); }
      public:
        /// Constructor with initializations
        ns2__SingleAttributeResponseType() : ProcessId(), AttributeResponseValues(), soap()
        { }
        virtual ~ns2__SingleAttributeResponseType() { }
        /// Friend allocator used by soap_new_ns2__SingleAttributeResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns2__SingleAttributeResponseType * SOAP_FMAC2 SCAP_instantiate_ns2__SingleAttributeResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:245 */
#ifndef SOAP_TYPE_ns2__UnsignedAttributeResponseType
#define SOAP_TYPE_ns2__UnsignedAttributeResponseType (27)
/* complex XSD type 'ns2:UnsignedAttributeResponseType': */
class SOAP_CMAC ns2__UnsignedAttributeResponseType {
      public:
        /// Required element 'ns2:ProcessId' of XSD type 'ns4:ProcessIDType'
        std::string ProcessId;
        /// Optional element 'ns2:CompanyId' of XSD type 'ns4:NIPCType'
        std::string *CompanyId;
        /// Optional element 'ns2:CompanyName' of XSD type 'ns4:CompanyNameType'
        std::string *CompanyName;
        /// Required element 'ns2:AttributeResponseValues' of XSD type 'ns2:UnsignedAttributesType'
        ns2__UnsignedAttributesType *AttributeResponseValues;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__UnsignedAttributeResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__UnsignedAttributeResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__UnsignedAttributeResponseType, default initialized and not managed by a soap context
        virtual ns2__UnsignedAttributeResponseType *soap_alloc(void) const { return SOAP_NEW(ns2__UnsignedAttributeResponseType); }
      public:
        /// Constructor with initializations
        ns2__UnsignedAttributeResponseType() : ProcessId(), CompanyId(), CompanyName(), AttributeResponseValues(), soap()
        { }
        virtual ~ns2__UnsignedAttributeResponseType() { }
        /// Friend allocator used by soap_new_ns2__UnsignedAttributeResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns2__UnsignedAttributeResponseType * SOAP_FMAC2 SCAP_instantiate_ns2__UnsignedAttributeResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:248 */
#ifndef SOAP_TYPE_ns2__AttributesType
#define SOAP_TYPE_ns2__AttributesType (28)
/* complex XSD type 'ns2:AttributesType': */
class SOAP_CMAC ns2__AttributesType {
      public:
        /// Required element 'ns2:ATTRSupplier' of XSD type 'ns3:AttributeSupplierType'
        ns3__AttributeSupplierType *ATTRSupplier;
        /// Required element 'ns2:ResponseResult' of XSD type 'ns2:ResponseResult'
        ns2__ResponseResult *ResponseResult;
        /// Optional element 'ns2:SignedAttributes' of XSD type 'ns2:SignedAttributesType'
        ns2__SignedAttributesType *SignedAttributes;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AttributesType
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AttributesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AttributesType, default initialized and not managed by a soap context
        virtual ns2__AttributesType *soap_alloc(void) const { return SOAP_NEW(ns2__AttributesType); }
      public:
        /// Constructor with initializations
        ns2__AttributesType() : ATTRSupplier(), ResponseResult(), SignedAttributes(), soap()
        { }
        virtual ~ns2__AttributesType() { }
        /// Friend allocator used by soap_new_ns2__AttributesType(struct soap*, int)
        friend SOAP_FMAC1 ns2__AttributesType * SOAP_FMAC2 SCAP_instantiate_ns2__AttributesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:251 */
#ifndef SOAP_TYPE_ns2__UnsignedAttributesType
#define SOAP_TYPE_ns2__UnsignedAttributesType (29)
/* complex XSD type 'ns2:UnsignedAttributesType': */
class SOAP_CMAC ns2__UnsignedAttributesType {
      public:
        /// Required element 'ns2:ResponseResult' of XSD type 'ns2:ResponseResult'
        ns2__ResponseResult *ResponseResult;
        /// Optional element 'ns2:UnsignedAttributes' of XSD type 'ns2:UnsignedAttributesBasicType'
        ns2__UnsignedAttributesBasicType *UnsignedAttributes;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__UnsignedAttributesType
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__UnsignedAttributesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__UnsignedAttributesType, default initialized and not managed by a soap context
        virtual ns2__UnsignedAttributesType *soap_alloc(void) const { return SOAP_NEW(ns2__UnsignedAttributesType); }
      public:
        /// Constructor with initializations
        ns2__UnsignedAttributesType() : ResponseResult(), UnsignedAttributes(), soap()
        { }
        virtual ~ns2__UnsignedAttributesType() { }
        /// Friend allocator used by soap_new_ns2__UnsignedAttributesType(struct soap*, int)
        friend SOAP_FMAC1 ns2__UnsignedAttributesType * SOAP_FMAC2 SCAP_instantiate_ns2__UnsignedAttributesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:254 */
#ifndef SOAP_TYPE_ns2__SignedAttributesType
#define SOAP_TYPE_ns2__SignedAttributesType (30)
/* complex XSD type 'ns2:SignedAttributesType': */
class SOAP_CMAC ns2__SignedAttributesType {
      public:
        /// Required element 'ns3:SignatureAttribute' of XSD type 'ns5:SignatureType'
        std::vector<ns5__SignatureType *> ns3__SignatureAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SignedAttributesType
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__SignedAttributesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SignedAttributesType, default initialized and not managed by a soap context
        virtual ns2__SignedAttributesType *soap_alloc(void) const { return SOAP_NEW(ns2__SignedAttributesType); }
      public:
        /// Constructor with initializations
        ns2__SignedAttributesType() : ns3__SignatureAttribute(), soap()
        { }
        virtual ~ns2__SignedAttributesType() { }
        /// Friend allocator used by soap_new_ns2__SignedAttributesType(struct soap*, int)
        friend SOAP_FMAC1 ns2__SignedAttributesType * SOAP_FMAC2 SCAP_instantiate_ns2__SignedAttributesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:257 */
#ifndef SOAP_TYPE_ns2__UnsignedAttributesBasicType
#define SOAP_TYPE_ns2__UnsignedAttributesBasicType (31)
/* complex XSD type 'ns2:UnsignedAttributesBasicType': */
class SOAP_CMAC ns2__UnsignedAttributesBasicType {
      public:
        /// Required element 'ns3:Attribute' of XSD type 'ns3:AttributeType'
        std::vector<ns3__AttributeType *> ns3__Attribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__UnsignedAttributesBasicType
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__UnsignedAttributesBasicType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__UnsignedAttributesBasicType, default initialized and not managed by a soap context
        virtual ns2__UnsignedAttributesBasicType *soap_alloc(void) const { return SOAP_NEW(ns2__UnsignedAttributesBasicType); }
      public:
        /// Constructor with initializations
        ns2__UnsignedAttributesBasicType() : ns3__Attribute(), soap()
        { }
        virtual ~ns2__UnsignedAttributesBasicType() { }
        /// Friend allocator used by soap_new_ns2__UnsignedAttributesBasicType(struct soap*, int)
        friend SOAP_FMAC1 ns2__UnsignedAttributesBasicType * SOAP_FMAC2 SCAP_instantiate_ns2__UnsignedAttributesBasicType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:260 */
#ifndef SOAP_TYPE_ns2__ResponseResult
#define SOAP_TYPE_ns2__ResponseResult (32)
/* complex XSD type 'ns2:ResponseResult': */
class SOAP_CMAC ns2__ResponseResult {
      public:
        /// Required element 'ns2:ResultCode' of XSD type 'xsd:string'
        std::string ResultCode;
        /// Required element 'ns2:ResultMessage' of XSD type 'xsd:string'
        std::string ResultMessage;
        /// Required element 'ns2:CitizenIDWithExtraInfo' of XSD type 'ns3:PersonalDataType'
        ns3__PersonalDataType *CitizenIDWithExtraInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ResponseResult
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ResponseResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ResponseResult, default initialized and not managed by a soap context
        virtual ns2__ResponseResult *soap_alloc(void) const { return SOAP_NEW(ns2__ResponseResult); }
      public:
        /// Constructor with initializations
        ns2__ResponseResult() : ResultCode(), ResultMessage(), CitizenIDWithExtraInfo(), soap()
        { }
        virtual ~ns2__ResponseResult() { }
        /// Friend allocator used by soap_new_ns2__ResponseResult(struct soap*, int)
        friend SOAP_FMAC1 ns2__ResponseResult * SOAP_FMAC2 SCAP_instantiate_ns2__ResponseResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:263 */
#ifndef SOAP_TYPE_ns5__SignatureType
#define SOAP_TYPE_ns5__SignatureType (33)
/* Type ns5__SignatureType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns5:SignatureType': */
class SOAP_CMAC ns5__SignatureType {
      public:
        /// Required element 'ns5:SignedInfo' of XSD type 'ns5:SignedInfoType'
        ns5__SignedInfoType *ns5__SignedInfo;
        /// Required element 'ns5:SignatureValue' of XSD type 'ns5:SignatureValueType'
        ns5__SignatureValueType *ns5__SignatureValue;
        /// Required element 'ns5:KeyInfo' of XSD type 'ns5:KeyInfoType'
        ns5__KeyInfoType *ns5__KeyInfo;
        /// Optional element 'ns5:Object' of XSD type 'ns5:ObjectType'
        std::vector<ns5__ObjectType *> ns5__Object;
        /// required attribute 'Id' of XSD type 'xsd:ID'
        std::string Id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__SignatureType
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__SignatureType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__SignatureType, default initialized and not managed by a soap context
        virtual ns5__SignatureType *soap_alloc(void) const { return SOAP_NEW(ns5__SignatureType); }
      public:
        /// Constructor with initializations
        ns5__SignatureType() : ns5__SignedInfo(), ns5__SignatureValue(), ns5__KeyInfo(), ns5__Object(), Id(), soap()
        { }
        virtual ~ns5__SignatureType() { }
        /// Friend allocator used by soap_new_ns5__SignatureType(struct soap*, int)
        friend SOAP_FMAC1 ns5__SignatureType * SOAP_FMAC2 SCAP_instantiate_ns5__SignatureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:266 */
#ifndef SOAP_TYPE_ns5__SignedInfoType
#define SOAP_TYPE_ns5__SignedInfoType (34)
/* complex XSD type 'ns5:SignedInfoType': */
class SOAP_CMAC ns5__SignedInfoType {
      public:
        /// Required element 'ns5:CanonicalizationMethod' of XSD type 'ns5:CanonicalizationMethodType'
        ns5__CanonicalizationMethodType *ns5__CanonicalizationMethod;
        /// Required element 'ns5:SignatureMethod' of XSD type 'ns5:SignatureMethodType'
        ns5__SignatureMethodType *ns5__SignatureMethod;
        /// Required element 'ns5:Reference' of XSD type 'ns5:ReferenceType'
        std::vector<ns5__ReferenceType *> ns5__Reference;
        /// required attribute 'Id' of XSD type 'xsd:ID'
        std::string Id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__SignedInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__SignedInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__SignedInfoType, default initialized and not managed by a soap context
        virtual ns5__SignedInfoType *soap_alloc(void) const { return SOAP_NEW(ns5__SignedInfoType); }
      public:
        /// Constructor with initializations
        ns5__SignedInfoType() : ns5__CanonicalizationMethod(), ns5__SignatureMethod(), ns5__Reference(), Id(), soap()
        { }
        virtual ~ns5__SignedInfoType() { }
        /// Friend allocator used by soap_new_ns5__SignedInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns5__SignedInfoType * SOAP_FMAC2 SCAP_instantiate_ns5__SignedInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:269 */
#ifndef SOAP_TYPE_ns5__CanonicalizationMethodType
#define SOAP_TYPE_ns5__CanonicalizationMethodType (35)
/* complex XSD type 'ns5:CanonicalizationMethodType': */
class SOAP_CMAC ns5__CanonicalizationMethodType {
      public:
        /// required attribute 'Algorithm' of XSD type 'xsd:anyURI'
        std::string Algorithm;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__CanonicalizationMethodType
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__CanonicalizationMethodType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__CanonicalizationMethodType, default initialized and not managed by a soap context
        virtual ns5__CanonicalizationMethodType *soap_alloc(void) const { return SOAP_NEW(ns5__CanonicalizationMethodType); }
      public:
        /// Constructor with initializations
        ns5__CanonicalizationMethodType() : Algorithm(), soap()
        { }
        virtual ~ns5__CanonicalizationMethodType() { }
        /// Friend allocator used by soap_new_ns5__CanonicalizationMethodType(struct soap*, int)
        friend SOAP_FMAC1 ns5__CanonicalizationMethodType * SOAP_FMAC2 SCAP_instantiate_ns5__CanonicalizationMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:272 */
#ifndef SOAP_TYPE_ns5__SignatureMethodType
#define SOAP_TYPE_ns5__SignatureMethodType (36)
/* complex XSD type 'ns5:SignatureMethodType': */
class SOAP_CMAC ns5__SignatureMethodType {
      public:
        /// required attribute 'Algorithm' of XSD type 'xsd:anyURI'
        std::string Algorithm;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__SignatureMethodType
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__SignatureMethodType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__SignatureMethodType, default initialized and not managed by a soap context
        virtual ns5__SignatureMethodType *soap_alloc(void) const { return SOAP_NEW(ns5__SignatureMethodType); }
      public:
        /// Constructor with initializations
        ns5__SignatureMethodType() : Algorithm(), soap()
        { }
        virtual ~ns5__SignatureMethodType() { }
        /// Friend allocator used by soap_new_ns5__SignatureMethodType(struct soap*, int)
        friend SOAP_FMAC1 ns5__SignatureMethodType * SOAP_FMAC2 SCAP_instantiate_ns5__SignatureMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:275 */
#ifndef SOAP_TYPE_ns5__ReferenceType
#define SOAP_TYPE_ns5__ReferenceType (37)
/* complex XSD type 'ns5:ReferenceType': */
class SOAP_CMAC ns5__ReferenceType {
      public:
        /// Required element 'ns5:Transforms' of XSD type 'ns5:TransformsType'
        ns5__TransformsType *ns5__Transforms;
        /// Required element 'ns5:DigestMethod' of XSD type 'ns5:DigestMethodType'
        ns5__DigestMethodType *ns5__DigestMethod;
        /// Required element 'ns5:DigestValue' of XSD type 'ns5:DigestValueType'
        ns5__DigestValueType *ns5__DigestValue;
        /// required attribute 'Id' of XSD type 'xsd:ID'
        std::string Id;
        /// optional attribute 'Type' of XSD type 'xsd:anyURI'
        std::string *Type;
        /// optional attribute 'URI' of XSD type 'xsd:anyURI'
        std::string *URI;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__ReferenceType
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__ReferenceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__ReferenceType, default initialized and not managed by a soap context
        virtual ns5__ReferenceType *soap_alloc(void) const { return SOAP_NEW(ns5__ReferenceType); }
      public:
        /// Constructor with initializations
        ns5__ReferenceType() : ns5__Transforms(), ns5__DigestMethod(), ns5__DigestValue(), Id(), Type(), URI(), soap()
        { }
        virtual ~ns5__ReferenceType() { }
        /// Friend allocator used by soap_new_ns5__ReferenceType(struct soap*, int)
        friend SOAP_FMAC1 ns5__ReferenceType * SOAP_FMAC2 SCAP_instantiate_ns5__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:278 */
#ifndef SOAP_TYPE_ns5__TransformsType
#define SOAP_TYPE_ns5__TransformsType (38)
/* complex XSD type 'ns5:TransformsType': */
class SOAP_CMAC ns5__TransformsType {
      public:
        /// Required element 'ns5:Transform' of XSD type 'ns5:TransformType'
        std::vector<ns5__TransformType *> ns5__Transform;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__TransformsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__TransformsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__TransformsType, default initialized and not managed by a soap context
        virtual ns5__TransformsType *soap_alloc(void) const { return SOAP_NEW(ns5__TransformsType); }
      public:
        /// Constructor with initializations
        ns5__TransformsType() : ns5__Transform(), soap()
        { }
        virtual ~ns5__TransformsType() { }
        /// Friend allocator used by soap_new_ns5__TransformsType(struct soap*, int)
        friend SOAP_FMAC1 ns5__TransformsType * SOAP_FMAC2 SCAP_instantiate_ns5__TransformsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:281 */
#ifndef SOAP_TYPE_ns5__TransformType
#define SOAP_TYPE_ns5__TransformType (39)
/* complex XSD type 'ns5:TransformType': */
class SOAP_CMAC ns5__TransformType {
      public:
        /// required attribute 'Algorithm' of XSD type 'xsd:anyURI'
        std::string Algorithm;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__TransformType
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__TransformType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__TransformType, default initialized and not managed by a soap context
        virtual ns5__TransformType *soap_alloc(void) const { return SOAP_NEW(ns5__TransformType); }
      public:
        /// Constructor with initializations
        ns5__TransformType() : Algorithm(), soap()
        { }
        virtual ~ns5__TransformType() { }
        /// Friend allocator used by soap_new_ns5__TransformType(struct soap*, int)
        friend SOAP_FMAC1 ns5__TransformType * SOAP_FMAC2 SCAP_instantiate_ns5__TransformType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:284 */
#ifndef SOAP_TYPE_ns5__DigestMethodType
#define SOAP_TYPE_ns5__DigestMethodType (40)
/* complex XSD type 'ns5:DigestMethodType': */
class SOAP_CMAC ns5__DigestMethodType {
      public:
        /// required attribute 'Algorithm' of XSD type 'xsd:anyURI'
        std::string Algorithm;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__DigestMethodType
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__DigestMethodType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__DigestMethodType, default initialized and not managed by a soap context
        virtual ns5__DigestMethodType *soap_alloc(void) const { return SOAP_NEW(ns5__DigestMethodType); }
      public:
        /// Constructor with initializations
        ns5__DigestMethodType() : Algorithm(), soap()
        { }
        virtual ~ns5__DigestMethodType() { }
        /// Friend allocator used by soap_new_ns5__DigestMethodType(struct soap*, int)
        friend SOAP_FMAC1 ns5__DigestMethodType * SOAP_FMAC2 SCAP_instantiate_ns5__DigestMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:287 */
#ifndef SOAP_TYPE_ns5__KeyInfoType
#define SOAP_TYPE_ns5__KeyInfoType (41)
/* complex XSD type 'ns5:KeyInfoType': */
class SOAP_CMAC ns5__KeyInfoType {
      public:
        /// Required element 'ns5:X509Data' of XSD type 'ns5:X509DataType'
        ns5__X509DataType *ns5__X509Data;
        /// required attribute 'Id' of XSD type 'xsd:ID'
        std::string Id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__KeyInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__KeyInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__KeyInfoType, default initialized and not managed by a soap context
        virtual ns5__KeyInfoType *soap_alloc(void) const { return SOAP_NEW(ns5__KeyInfoType); }
      public:
        /// Constructor with initializations
        ns5__KeyInfoType() : ns5__X509Data(), Id(), soap()
        { }
        virtual ~ns5__KeyInfoType() { }
        /// Friend allocator used by soap_new_ns5__KeyInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns5__KeyInfoType * SOAP_FMAC2 SCAP_instantiate_ns5__KeyInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:290 */
#ifndef SOAP_TYPE_ns5__X509DataType
#define SOAP_TYPE_ns5__X509DataType (42)
/* complex XSD type 'ns5:X509DataType': */
class SOAP_CMAC ns5__X509DataType {
      public:
        /// Required element 'ns5:X509Certificate' of XSD type 'ns5:X509CertificateType'
        std::vector<ns5__X509CertificateType *> ns5__X509Certificate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__X509DataType
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__X509DataType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__X509DataType, default initialized and not managed by a soap context
        virtual ns5__X509DataType *soap_alloc(void) const { return SOAP_NEW(ns5__X509DataType); }
      public:
        /// Constructor with initializations
        ns5__X509DataType() : ns5__X509Certificate(), soap()
        { }
        virtual ~ns5__X509DataType() { }
        /// Friend allocator used by soap_new_ns5__X509DataType(struct soap*, int)
        friend SOAP_FMAC1 ns5__X509DataType * SOAP_FMAC2 SCAP_instantiate_ns5__X509DataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:1309 */
#ifndef SOAP_TYPE__ns5__union_ObjectType
#define SOAP_TYPE__ns5__union_ObjectType (177)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns5__union_ObjectType
{
        #define SOAP_UNION__ns5__union_ObjectType_ns6__QualifyingProperties	(1)	/**< union variant selector value for member ns6__QualifyingProperties */
        ns6__QualifyingPropertiesType *ns6__QualifyingProperties;
        #define SOAP_UNION__ns5__union_ObjectType_ns7__SVGList	(2)	/**< union variant selector value for member ns7__SVGList */
        ns7__SVGListType *ns7__SVGList;
        #define SOAP_UNION__ns5__union_ObjectType_ns3__Attribute	(3)	/**< union variant selector value for member ns3__Attribute */
        ns3__AttributeType *ns3__Attribute;
};
#endif

/* SCAP-Services.h:293 */
#ifndef SOAP_TYPE_ns5__ObjectType
#define SOAP_TYPE_ns5__ObjectType (43)
/* complex XSD type 'ns5:ObjectType': */
class SOAP_CMAC ns5__ObjectType {
      public:
        /// Union with union _ns5__union_ObjectType variant selector __union_ObjectType set to one of: SOAP_UNION__ns5__union_ObjectType_ns6__QualifyingProperties SOAP_UNION__ns5__union_ObjectType_ns7__SVGList SOAP_UNION__ns5__union_ObjectType_ns3__Attribute
        int __union_ObjectType;
        union _ns5__union_ObjectType union_ObjectType;
        /// required attribute 'Id' of XSD type 'xsd:ID'
        std::string Id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__ObjectType
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__ObjectType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__ObjectType, default initialized and not managed by a soap context
        virtual ns5__ObjectType *soap_alloc(void) const { return SOAP_NEW(ns5__ObjectType); }
      public:
        /// Constructor with initializations
        ns5__ObjectType() : __union_ObjectType(), Id(), soap()
        { }
        virtual ~ns5__ObjectType() { }
        /// Friend allocator used by soap_new_ns5__ObjectType(struct soap*, int)
        friend SOAP_FMAC1 ns5__ObjectType * SOAP_FMAC2 SCAP_instantiate_ns5__ObjectType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:305 */
#ifndef SOAP_TYPE_ns3__AttributeType
#define SOAP_TYPE_ns3__AttributeType (47)
/* complex XSD type 'ns3:AttributeType': */
class SOAP_CMAC ns3__AttributeType {
      public:
        /// Required element 'ns3:AttributeSupplier' of XSD type 'ns3:AttributeSupplierType'
        ns3__AttributeSupplierType *AttributeSupplier;
        /// Required element 'ns3:Date' of XSD type 'ns4:DateType'
        std::string Date;
        /// Required element 'ns3:Validity' of XSD type 'ns4:ValidityType'
        std::string Validity;
        /// Required element 'ns3:PersonalData' of XSD type 'ns3:PersonalDataType'
        ns3__PersonalDataType *PersonalData;
        /// Required element 'ns3:MainAttribute' of XSD type 'ns3:MainAttributeType'
        ns3__MainAttributeType *MainAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__AttributeType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__AttributeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__AttributeType, default initialized and not managed by a soap context
        virtual ns3__AttributeType *soap_alloc(void) const { return SOAP_NEW(ns3__AttributeType); }
      public:
        /// Constructor with initializations
        ns3__AttributeType() : AttributeSupplier(), Date(), Validity(), PersonalData(), MainAttribute(), soap()
        { }
        virtual ~ns3__AttributeType() { }
        /// Friend allocator used by soap_new_ns3__AttributeType(struct soap*, int)
        friend SOAP_FMAC1 ns3__AttributeType * SOAP_FMAC2 SCAP_instantiate_ns3__AttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:308 */
#ifndef SOAP_TYPE_ns3__AttributeSupplierType
#define SOAP_TYPE_ns3__AttributeSupplierType (48)
/* complex XSD type 'ns3:AttributeSupplierType': */
class SOAP_CMAC ns3__AttributeSupplierType {
      public:
        /// Required element 'ns3:Id' of XSD type 'xsd:anyURI'
        std::string Id;
        /// Required element 'ns3:Name' of XSD type 'ns4:NameType'
        std::string Name;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__AttributeSupplierType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__AttributeSupplierType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__AttributeSupplierType, default initialized and not managed by a soap context
        virtual ns3__AttributeSupplierType *soap_alloc(void) const { return SOAP_NEW(ns3__AttributeSupplierType); }
      public:
        /// Constructor with initializations
        ns3__AttributeSupplierType() : Id(), Name(), soap()
        { }
        virtual ~ns3__AttributeSupplierType() { }
        /// Friend allocator used by soap_new_ns3__AttributeSupplierType(struct soap*, int)
        friend SOAP_FMAC1 ns3__AttributeSupplierType * SOAP_FMAC2 SCAP_instantiate_ns3__AttributeSupplierType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:311 */
#ifndef SOAP_TYPE_ns3__PersonalDataType
#define SOAP_TYPE_ns3__PersonalDataType (49)
/* complex XSD type 'ns3:PersonalDataType': */
class SOAP_CMAC ns3__PersonalDataType {
      public:
        /// Required element 'ns3:Name' of XSD type 'ns4:NameType'
        std::string Name;
        /// Required element 'ns3:NIC' of XSD type 'ns4:NICType'
        std::string NIC;
        /// Optional element 'ns3:ExtraIDList' of XSD type 'ns3:ExtraIDListType'
        ns3__ExtraIDListType *ExtraIDList;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__PersonalDataType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__PersonalDataType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PersonalDataType, default initialized and not managed by a soap context
        virtual ns3__PersonalDataType *soap_alloc(void) const { return SOAP_NEW(ns3__PersonalDataType); }
      public:
        /// Constructor with initializations
        ns3__PersonalDataType() : Name(), NIC(), ExtraIDList(), soap()
        { }
        virtual ~ns3__PersonalDataType() { }
        /// Friend allocator used by soap_new_ns3__PersonalDataType(struct soap*, int)
        friend SOAP_FMAC1 ns3__PersonalDataType * SOAP_FMAC2 SCAP_instantiate_ns3__PersonalDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:314 */
#ifndef SOAP_TYPE_ns3__ExtraIDListType
#define SOAP_TYPE_ns3__ExtraIDListType (50)
/* complex XSD type 'ns3:ExtraIDListType': */
class SOAP_CMAC ns3__ExtraIDListType {
      public:
        /// Required element 'ns3:ExtraID' of XSD type 'ns3:ExtraIDType'
        std::vector<ns3__ExtraIDType *> ExtraID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ExtraIDListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ExtraIDListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ExtraIDListType, default initialized and not managed by a soap context
        virtual ns3__ExtraIDListType *soap_alloc(void) const { return SOAP_NEW(ns3__ExtraIDListType); }
      public:
        /// Constructor with initializations
        ns3__ExtraIDListType() : ExtraID(), soap()
        { }
        virtual ~ns3__ExtraIDListType() { }
        /// Friend allocator used by soap_new_ns3__ExtraIDListType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ExtraIDListType * SOAP_FMAC2 SCAP_instantiate_ns3__ExtraIDListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:317 */
#ifndef SOAP_TYPE_ns3__ExtraIDType
#define SOAP_TYPE_ns3__ExtraIDType (51)
/* complex XSD type 'ns3:ExtraIDType': */
class SOAP_CMAC ns3__ExtraIDType {
      public:
        /// Required element 'ns3:Name' of XSD type 'ns4:NameType'
        std::string Name;
        /// Required element 'ns3:Value' of XSD type 'ns4:ExtraIDValueType'
        std::string Value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ExtraIDType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ExtraIDType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ExtraIDType, default initialized and not managed by a soap context
        virtual ns3__ExtraIDType *soap_alloc(void) const { return SOAP_NEW(ns3__ExtraIDType); }
      public:
        /// Constructor with initializations
        ns3__ExtraIDType() : Name(), Value(), soap()
        { }
        virtual ~ns3__ExtraIDType() { }
        /// Friend allocator used by soap_new_ns3__ExtraIDType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ExtraIDType * SOAP_FMAC2 SCAP_instantiate_ns3__ExtraIDType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:320 */
#ifndef SOAP_TYPE_ns3__MainAttributeType
#define SOAP_TYPE_ns3__MainAttributeType (52)
/* complex XSD type 'ns3:MainAttributeType': */
class SOAP_CMAC ns3__MainAttributeType {
      public:
        /// Required element 'ns3:AttributeID' of XSD type 'ns4:AttributeIDType'
        std::string AttributeID;
        /// Optional element 'ns3:Description' of XSD type 'ns4:DescriptionType'
        std::string *Description;
        /// Optional element 'ns3:LegalActList' of XSD type 'ns3:LegalActListType'
        ns3__LegalActListType *LegalActList;
        /// Optional element 'ns3:SubAttributeList' of XSD type 'ns3:SubAttributeListType'
        ns3__SubAttributeListType *SubAttributeList;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__MainAttributeType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__MainAttributeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__MainAttributeType, default initialized and not managed by a soap context
        virtual ns3__MainAttributeType *soap_alloc(void) const { return SOAP_NEW(ns3__MainAttributeType); }
      public:
        /// Constructor with initializations
        ns3__MainAttributeType() : AttributeID(), Description(), LegalActList(), SubAttributeList(), soap()
        { }
        virtual ~ns3__MainAttributeType() { }
        /// Friend allocator used by soap_new_ns3__MainAttributeType(struct soap*, int)
        friend SOAP_FMAC1 ns3__MainAttributeType * SOAP_FMAC2 SCAP_instantiate_ns3__MainAttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:323 */
#ifndef SOAP_TYPE_ns3__LegalActListType
#define SOAP_TYPE_ns3__LegalActListType (53)
/* complex XSD type 'ns3:LegalActListType': */
class SOAP_CMAC ns3__LegalActListType {
      public:
        /// Required element 'ns3:LegalAct' of XSD type 'ns4:LegalActType'
        std::vector<std::string> LegalAct;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__LegalActListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__LegalActListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__LegalActListType, default initialized and not managed by a soap context
        virtual ns3__LegalActListType *soap_alloc(void) const { return SOAP_NEW(ns3__LegalActListType); }
      public:
        /// Constructor with initializations
        ns3__LegalActListType() : LegalAct(), soap()
        { }
        virtual ~ns3__LegalActListType() { }
        /// Friend allocator used by soap_new_ns3__LegalActListType(struct soap*, int)
        friend SOAP_FMAC1 ns3__LegalActListType * SOAP_FMAC2 SCAP_instantiate_ns3__LegalActListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:326 */
#ifndef SOAP_TYPE_ns3__SubAttributeListType
#define SOAP_TYPE_ns3__SubAttributeListType (54)
/* complex XSD type 'ns3:SubAttributeListType': */
class SOAP_CMAC ns3__SubAttributeListType {
      public:
        /// Required element 'ns3:SubAttribute' of XSD type 'ns3:SubAttributeType'
        std::vector<ns3__SubAttributeType *> SubAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__SubAttributeListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__SubAttributeListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__SubAttributeListType, default initialized and not managed by a soap context
        virtual ns3__SubAttributeListType *soap_alloc(void) const { return SOAP_NEW(ns3__SubAttributeListType); }
      public:
        /// Constructor with initializations
        ns3__SubAttributeListType() : SubAttribute(), soap()
        { }
        virtual ~ns3__SubAttributeListType() { }
        /// Friend allocator used by soap_new_ns3__SubAttributeListType(struct soap*, int)
        friend SOAP_FMAC1 ns3__SubAttributeListType * SOAP_FMAC2 SCAP_instantiate_ns3__SubAttributeListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:329 */
#ifndef SOAP_TYPE_ns3__SubAttributeType
#define SOAP_TYPE_ns3__SubAttributeType (55)
/* complex XSD type 'ns3:SubAttributeType': */
class SOAP_CMAC ns3__SubAttributeType {
      public:
        /// Required element 'ns3:AttributeID' of XSD type 'ns4:AttributeIDType'
        std::string AttributeID;
        /// Optional element 'ns3:Description' of XSD type 'ns4:DescriptionType'
        std::string *Description;
        /// Optional element 'ns3:Value' of XSD type 'ns4:SubAttributeValueType'
        std::string *Value;
        /// Optional element 'ns3:LegalActList' of XSD type 'ns3:LegalActListType'
        ns3__LegalActListType *LegalActList;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__SubAttributeType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__SubAttributeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__SubAttributeType, default initialized and not managed by a soap context
        virtual ns3__SubAttributeType *soap_alloc(void) const { return SOAP_NEW(ns3__SubAttributeType); }
      public:
        /// Constructor with initializations
        ns3__SubAttributeType() : AttributeID(), Description(), Value(), LegalActList(), soap()
        { }
        virtual ~ns3__SubAttributeType() { }
        /// Friend allocator used by soap_new_ns3__SubAttributeType(struct soap*, int)
        friend SOAP_FMAC1 ns3__SubAttributeType * SOAP_FMAC2 SCAP_instantiate_ns3__SubAttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:332 */
#ifndef SOAP_TYPE_ns3__ResponseCodeStatusType
#define SOAP_TYPE_ns3__ResponseCodeStatusType (56)
/* complex XSD type 'ns3:ResponseCodeStatusType': */
class SOAP_CMAC ns3__ResponseCodeStatusType {
      public:
        /// Required element 'ns3:Code' of XSD type 'ns4:ResponseCodeType'
        std::string Code;
        /// Optional element 'ns3:Message' of XSD type 'ns4:ResponseCodeMessage'
        std::string *Message;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ResponseCodeStatusType
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ResponseCodeStatusType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ResponseCodeStatusType, default initialized and not managed by a soap context
        virtual ns3__ResponseCodeStatusType *soap_alloc(void) const { return SOAP_NEW(ns3__ResponseCodeStatusType); }
      public:
        /// Constructor with initializations
        ns3__ResponseCodeStatusType() : Code(), Message(), soap()
        { }
        virtual ~ns3__ResponseCodeStatusType() { }
        /// Friend allocator used by soap_new_ns3__ResponseCodeStatusType(struct soap*, int)
        friend SOAP_FMAC1 ns3__ResponseCodeStatusType * SOAP_FMAC2 SCAP_instantiate_ns3__ResponseCodeStatusType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:335 */
#ifndef SOAP_TYPE_ns6__QualifyingPropertiesType
#define SOAP_TYPE_ns6__QualifyingPropertiesType (57)
/* complex XSD type 'ns6:QualifyingPropertiesType': */
class SOAP_CMAC ns6__QualifyingPropertiesType {
      public:
        /// Required element 'ns6:SignedProperties' of XSD type 'ns6:SignedPropertiesType'
        ns6__SignedPropertiesType *ns6__SignedProperties;
        /// Optional element 'ns6:UnsignedProperties' of XSD type 'ns6:UnsignedPropertiesType'
        ns6__UnsignedPropertiesType *ns6__UnsignedProperties;
        /// required attribute 'Target' of XSD type 'xsd:anyURI'
        std::string Target;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__QualifyingPropertiesType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__QualifyingPropertiesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__QualifyingPropertiesType, default initialized and not managed by a soap context
        virtual ns6__QualifyingPropertiesType *soap_alloc(void) const { return SOAP_NEW(ns6__QualifyingPropertiesType); }
      public:
        /// Constructor with initializations
        ns6__QualifyingPropertiesType() : ns6__SignedProperties(), ns6__UnsignedProperties(), Target(), soap()
        { }
        virtual ~ns6__QualifyingPropertiesType() { }
        /// Friend allocator used by soap_new_ns6__QualifyingPropertiesType(struct soap*, int)
        friend SOAP_FMAC1 ns6__QualifyingPropertiesType * SOAP_FMAC2 SCAP_instantiate_ns6__QualifyingPropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:338 */
#ifndef SOAP_TYPE_ns6__SignedPropertiesType
#define SOAP_TYPE_ns6__SignedPropertiesType (58)
/* complex XSD type 'ns6:SignedPropertiesType': */
class SOAP_CMAC ns6__SignedPropertiesType {
      public:
        /// Required element 'ns6:SignedSignatureProperties' of XSD type 'ns6:SignedSignaturePropertiesType'
        ns6__SignedSignaturePropertiesType *ns6__SignedSignatureProperties;
        /// required attribute 'Id' of XSD type 'xsd:ID'
        std::string Id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__SignedPropertiesType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__SignedPropertiesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__SignedPropertiesType, default initialized and not managed by a soap context
        virtual ns6__SignedPropertiesType *soap_alloc(void) const { return SOAP_NEW(ns6__SignedPropertiesType); }
      public:
        /// Constructor with initializations
        ns6__SignedPropertiesType() : ns6__SignedSignatureProperties(), Id(), soap()
        { }
        virtual ~ns6__SignedPropertiesType() { }
        /// Friend allocator used by soap_new_ns6__SignedPropertiesType(struct soap*, int)
        friend SOAP_FMAC1 ns6__SignedPropertiesType * SOAP_FMAC2 SCAP_instantiate_ns6__SignedPropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:341 */
#ifndef SOAP_TYPE_ns6__SignedSignaturePropertiesType
#define SOAP_TYPE_ns6__SignedSignaturePropertiesType (59)
/* complex XSD type 'ns6:SignedSignaturePropertiesType': */
class SOAP_CMAC ns6__SignedSignaturePropertiesType {
      public:
        /// Required element 'ns6:SigningTime' of XSD type 'ns6:SigningTimeType'
        time_t ns6__SigningTime;
        /// Required element 'ns6:SigningCertificate' of XSD type 'ns6:SigningCertificateType'
        ns6__SigningCertificateType *ns6__SigningCertificate;
        /// Optional element 'ns6:SignerRole' of XSD type 'ns6:SignerRoleType'
        ns6__SignerRoleType *ns6__SignerRole;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__SignedSignaturePropertiesType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__SignedSignaturePropertiesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__SignedSignaturePropertiesType, default initialized and not managed by a soap context
        virtual ns6__SignedSignaturePropertiesType *soap_alloc(void) const { return SOAP_NEW(ns6__SignedSignaturePropertiesType); }
      public:
        /// Constructor with initializations
        ns6__SignedSignaturePropertiesType() : ns6__SigningTime(), ns6__SigningCertificate(), ns6__SignerRole(), soap()
        { }
        virtual ~ns6__SignedSignaturePropertiesType() { }
        /// Friend allocator used by soap_new_ns6__SignedSignaturePropertiesType(struct soap*, int)
        friend SOAP_FMAC1 ns6__SignedSignaturePropertiesType * SOAP_FMAC2 SCAP_instantiate_ns6__SignedSignaturePropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:344 */
#ifndef SOAP_TYPE_ns6__SigningCertificateType
#define SOAP_TYPE_ns6__SigningCertificateType (60)
/* complex XSD type 'ns6:SigningCertificateType': */
class SOAP_CMAC ns6__SigningCertificateType {
      public:
        /// Required element 'ns6:Cert' of XSD type 'ns6:CertType'
        ns6__CertType *ns6__Cert;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__SigningCertificateType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__SigningCertificateType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__SigningCertificateType, default initialized and not managed by a soap context
        virtual ns6__SigningCertificateType *soap_alloc(void) const { return SOAP_NEW(ns6__SigningCertificateType); }
      public:
        /// Constructor with initializations
        ns6__SigningCertificateType() : ns6__Cert(), soap()
        { }
        virtual ~ns6__SigningCertificateType() { }
        /// Friend allocator used by soap_new_ns6__SigningCertificateType(struct soap*, int)
        friend SOAP_FMAC1 ns6__SigningCertificateType * SOAP_FMAC2 SCAP_instantiate_ns6__SigningCertificateType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:347 */
#ifndef SOAP_TYPE_ns6__CertType
#define SOAP_TYPE_ns6__CertType (61)
/* complex XSD type 'ns6:CertType': */
class SOAP_CMAC ns6__CertType {
      public:
        /// Required element 'ns6:CertDigest' of XSD type 'ns6:CertDigestType'
        ns6__CertDigestType *ns6__CertDigest;
        /// Required element 'ns6:IssuerSerial' of XSD type 'ns6:IssuerSerialType'
        ns6__IssuerSerialType *ns6__IssuerSerial;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__CertType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__CertType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__CertType, default initialized and not managed by a soap context
        virtual ns6__CertType *soap_alloc(void) const { return SOAP_NEW(ns6__CertType); }
      public:
        /// Constructor with initializations
        ns6__CertType() : ns6__CertDigest(), ns6__IssuerSerial(), soap()
        { }
        virtual ~ns6__CertType() { }
        /// Friend allocator used by soap_new_ns6__CertType(struct soap*, int)
        friend SOAP_FMAC1 ns6__CertType * SOAP_FMAC2 SCAP_instantiate_ns6__CertType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:350 */
#ifndef SOAP_TYPE_ns6__CertDigestType
#define SOAP_TYPE_ns6__CertDigestType (62)
/* complex XSD type 'ns6:CertDigestType': */
class SOAP_CMAC ns6__CertDigestType {
      public:
        /// Required element 'ns5:DigestMethod' of XSD type 'ns5:DigestMethodType'
        ns5__DigestMethodType *ns5__DigestMethod;
        /// Required element 'ns5:DigestValue' of XSD type 'ns5:DigestValueType'
        ns5__DigestValueType *ns5__DigestValue;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__CertDigestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__CertDigestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__CertDigestType, default initialized and not managed by a soap context
        virtual ns6__CertDigestType *soap_alloc(void) const { return SOAP_NEW(ns6__CertDigestType); }
      public:
        /// Constructor with initializations
        ns6__CertDigestType() : ns5__DigestMethod(), ns5__DigestValue(), soap()
        { }
        virtual ~ns6__CertDigestType() { }
        /// Friend allocator used by soap_new_ns6__CertDigestType(struct soap*, int)
        friend SOAP_FMAC1 ns6__CertDigestType * SOAP_FMAC2 SCAP_instantiate_ns6__CertDigestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:353 */
#ifndef SOAP_TYPE_ns6__IssuerSerialType
#define SOAP_TYPE_ns6__IssuerSerialType (63)
/* complex XSD type 'ns6:IssuerSerialType': */
class SOAP_CMAC ns6__IssuerSerialType {
      public:
        /// Required element 'ns5:X509IssuerName' of XSD type 'ns5:X509IssuerNameType'
        std::string ns5__X509IssuerName;
        /// Required element 'ns5:X509SerialNumber' of XSD type 'ns5:X509SerialNumberType'
        std::string ns5__X509SerialNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__IssuerSerialType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__IssuerSerialType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__IssuerSerialType, default initialized and not managed by a soap context
        virtual ns6__IssuerSerialType *soap_alloc(void) const { return SOAP_NEW(ns6__IssuerSerialType); }
      public:
        /// Constructor with initializations
        ns6__IssuerSerialType() : ns5__X509IssuerName(), ns5__X509SerialNumber(), soap()
        { }
        virtual ~ns6__IssuerSerialType() { }
        /// Friend allocator used by soap_new_ns6__IssuerSerialType(struct soap*, int)
        friend SOAP_FMAC1 ns6__IssuerSerialType * SOAP_FMAC2 SCAP_instantiate_ns6__IssuerSerialType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:356 */
#ifndef SOAP_TYPE_ns6__SignerRoleType
#define SOAP_TYPE_ns6__SignerRoleType (64)
/* complex XSD type 'ns6:SignerRoleType': */
class SOAP_CMAC ns6__SignerRoleType {
      public:
        /// Required element 'ns6:ClaimedRoles' of XSD type 'ns6:ClaimedRolesListType'
        ns6__ClaimedRolesListType *ns6__ClaimedRoles;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__SignerRoleType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__SignerRoleType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__SignerRoleType, default initialized and not managed by a soap context
        virtual ns6__SignerRoleType *soap_alloc(void) const { return SOAP_NEW(ns6__SignerRoleType); }
      public:
        /// Constructor with initializations
        ns6__SignerRoleType() : ns6__ClaimedRoles(), soap()
        { }
        virtual ~ns6__SignerRoleType() { }
        /// Friend allocator used by soap_new_ns6__SignerRoleType(struct soap*, int)
        friend SOAP_FMAC1 ns6__SignerRoleType * SOAP_FMAC2 SCAP_instantiate_ns6__SignerRoleType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:359 */
#ifndef SOAP_TYPE_ns6__ClaimedRolesListType
#define SOAP_TYPE_ns6__ClaimedRolesListType (65)
/* complex XSD type 'ns6:ClaimedRolesListType': */
class SOAP_CMAC ns6__ClaimedRolesListType {
      public:
        /// Required element 'ns6:ClaimedRole' of XSD type 'ns6:ClaimedRoleType'
        std::vector<ns6__ClaimedRoleType *> ns6__ClaimedRole;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__ClaimedRolesListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__ClaimedRolesListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__ClaimedRolesListType, default initialized and not managed by a soap context
        virtual ns6__ClaimedRolesListType *soap_alloc(void) const { return SOAP_NEW(ns6__ClaimedRolesListType); }
      public:
        /// Constructor with initializations
        ns6__ClaimedRolesListType() : ns6__ClaimedRole(), soap()
        { }
        virtual ~ns6__ClaimedRolesListType() { }
        /// Friend allocator used by soap_new_ns6__ClaimedRolesListType(struct soap*, int)
        friend SOAP_FMAC1 ns6__ClaimedRolesListType * SOAP_FMAC2 SCAP_instantiate_ns6__ClaimedRolesListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:362 */
#ifndef SOAP_TYPE_ns6__ClaimedRoleType
#define SOAP_TYPE_ns6__ClaimedRoleType (66)
/* complex XSD type 'ns6:ClaimedRoleType': */
class SOAP_CMAC ns6__ClaimedRoleType {
      public:
        /// Required element 'ns3:SignatureAttribute' of XSD type 'ns5:SignatureType'
        ns5__SignatureType *ns3__SignatureAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__ClaimedRoleType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__ClaimedRoleType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__ClaimedRoleType, default initialized and not managed by a soap context
        virtual ns6__ClaimedRoleType *soap_alloc(void) const { return SOAP_NEW(ns6__ClaimedRoleType); }
      public:
        /// Constructor with initializations
        ns6__ClaimedRoleType() : ns3__SignatureAttribute(), soap()
        { }
        virtual ~ns6__ClaimedRoleType() { }
        /// Friend allocator used by soap_new_ns6__ClaimedRoleType(struct soap*, int)
        friend SOAP_FMAC1 ns6__ClaimedRoleType * SOAP_FMAC2 SCAP_instantiate_ns6__ClaimedRoleType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:365 */
#ifndef SOAP_TYPE_ns6__UnsignedPropertiesType
#define SOAP_TYPE_ns6__UnsignedPropertiesType (67)
/* complex XSD type 'ns6:UnsignedPropertiesType': */
class SOAP_CMAC ns6__UnsignedPropertiesType {
      public:
        /// Required element 'ns6:UnsignedSignatureProperties' of XSD type 'ns6:UnsignedSignaturePropertiesType'
        ns6__UnsignedSignaturePropertiesType *ns6__UnsignedSignatureProperties;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__UnsignedPropertiesType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__UnsignedPropertiesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__UnsignedPropertiesType, default initialized and not managed by a soap context
        virtual ns6__UnsignedPropertiesType *soap_alloc(void) const { return SOAP_NEW(ns6__UnsignedPropertiesType); }
      public:
        /// Constructor with initializations
        ns6__UnsignedPropertiesType() : ns6__UnsignedSignatureProperties(), soap()
        { }
        virtual ~ns6__UnsignedPropertiesType() { }
        /// Friend allocator used by soap_new_ns6__UnsignedPropertiesType(struct soap*, int)
        friend SOAP_FMAC1 ns6__UnsignedPropertiesType * SOAP_FMAC2 SCAP_instantiate_ns6__UnsignedPropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:368 */
#ifndef SOAP_TYPE_ns6__UnsignedSignaturePropertiesType
#define SOAP_TYPE_ns6__UnsignedSignaturePropertiesType (68)
/* complex XSD type 'ns6:UnsignedSignaturePropertiesType': */
class SOAP_CMAC ns6__UnsignedSignaturePropertiesType {
      public:
        /// Optional element 'ns6:CounterSignature' of XSD type 'ns6:CounterSignatureType'
        ns6__CounterSignatureType *ns6__CounterSignature;
        /// Required element 'ns6:SignatureTimeStamp' of XSD type 'ns6:SignatureTimeStampType'
        ns6__SignatureTimeStampType *ns6__SignatureTimeStamp;
        /// Required element 'ns6:CompleteCertificateRefs' of XSD type 'ns6:CompleteCertificateRefsType'
        ns6__CompleteCertificateRefsType *ns6__CompleteCertificateRefs;
        /// Required element 'ns6:CompleteRevocationRefs' of XSD type 'ns6:CompleteRevocationRefsType'
        ns6__CompleteRevocationRefsType *ns6__CompleteRevocationRefs;
        /// Required element 'ns6:SigAndRefsTimeStamp' of XSD type 'ns6:SigAndRefsTimeStampType'
        ns6__SigAndRefsTimeStampType *ns6__SigAndRefsTimeStamp;
        /// Required element 'ns6:CertificateValues' of XSD type 'ns6:CertificateValuesType'
        ns6__CertificateValuesType *ns6__CertificateValues;
        /// Required element 'ns6:RevocationValues' of XSD type 'ns6:RevocationValuesType'
        ns6__RevocationValuesType *ns6__RevocationValues;
        /// Required element 'ns6:ArchiveTimeStamp' of XSD type 'ns6:ArchiveTimeStampType'
        ns6__ArchiveTimeStampType *ns6__ArchiveTimeStamp;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__UnsignedSignaturePropertiesType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__UnsignedSignaturePropertiesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__UnsignedSignaturePropertiesType, default initialized and not managed by a soap context
        virtual ns6__UnsignedSignaturePropertiesType *soap_alloc(void) const { return SOAP_NEW(ns6__UnsignedSignaturePropertiesType); }
      public:
        /// Constructor with initializations
        ns6__UnsignedSignaturePropertiesType() : ns6__CounterSignature(), ns6__SignatureTimeStamp(), ns6__CompleteCertificateRefs(), ns6__CompleteRevocationRefs(), ns6__SigAndRefsTimeStamp(), ns6__CertificateValues(), ns6__RevocationValues(), ns6__ArchiveTimeStamp(), soap()
        { }
        virtual ~ns6__UnsignedSignaturePropertiesType() { }
        /// Friend allocator used by soap_new_ns6__UnsignedSignaturePropertiesType(struct soap*, int)
        friend SOAP_FMAC1 ns6__UnsignedSignaturePropertiesType * SOAP_FMAC2 SCAP_instantiate_ns6__UnsignedSignaturePropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:371 */
#ifndef SOAP_TYPE_ns6__CounterSignatureType
#define SOAP_TYPE_ns6__CounterSignatureType (69)
/* complex XSD type 'ns6:CounterSignatureType': */
class SOAP_CMAC ns6__CounterSignatureType {
      public:
        /// Required element 'ns5:Signature' of XSD type 'ns5:SignatureType'
        ns5__SignatureType *ns5__Signature;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__CounterSignatureType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__CounterSignatureType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__CounterSignatureType, default initialized and not managed by a soap context
        virtual ns6__CounterSignatureType *soap_alloc(void) const { return SOAP_NEW(ns6__CounterSignatureType); }
      public:
        /// Constructor with initializations
        ns6__CounterSignatureType() : ns5__Signature(), soap()
        { }
        virtual ~ns6__CounterSignatureType() { }
        /// Friend allocator used by soap_new_ns6__CounterSignatureType(struct soap*, int)
        friend SOAP_FMAC1 ns6__CounterSignatureType * SOAP_FMAC2 SCAP_instantiate_ns6__CounterSignatureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:374 */
#ifndef SOAP_TYPE_ns6__SignatureTimeStampType
#define SOAP_TYPE_ns6__SignatureTimeStampType (70)
/* complex XSD type 'ns6:SignatureTimeStampType': */
class SOAP_CMAC ns6__SignatureTimeStampType {
      public:
        /// Required element 'ns5:CanonicalizationMethod' of XSD type 'ns5:CanonicalizationMethodType'
        ns5__CanonicalizationMethodType *ns5__CanonicalizationMethod;
        /// Required element 'ns6:EncapsulatedTimeStamp' of XSD type 'ns6:EncapsulatedTimeStampType'
        xsd__base64Binary ns6__EncapsulatedTimeStamp;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__SignatureTimeStampType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__SignatureTimeStampType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__SignatureTimeStampType, default initialized and not managed by a soap context
        virtual ns6__SignatureTimeStampType *soap_alloc(void) const { return SOAP_NEW(ns6__SignatureTimeStampType); }
      public:
        /// Constructor with initializations
        ns6__SignatureTimeStampType() : ns5__CanonicalizationMethod(), ns6__EncapsulatedTimeStamp(), soap()
        { }
        virtual ~ns6__SignatureTimeStampType() { }
        /// Friend allocator used by soap_new_ns6__SignatureTimeStampType(struct soap*, int)
        friend SOAP_FMAC1 ns6__SignatureTimeStampType * SOAP_FMAC2 SCAP_instantiate_ns6__SignatureTimeStampType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:377 */
#ifndef SOAP_TYPE_ns6__CompleteCertificateRefsType
#define SOAP_TYPE_ns6__CompleteCertificateRefsType (71)
/* complex XSD type 'ns6:CompleteCertificateRefsType': */
class SOAP_CMAC ns6__CompleteCertificateRefsType {
      public:
        /// Required element 'ns6:CertRefs' of XSD type 'ns6:CertRefsType'
        ns6__CertRefsType *ns6__CertRefs;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__CompleteCertificateRefsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__CompleteCertificateRefsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__CompleteCertificateRefsType, default initialized and not managed by a soap context
        virtual ns6__CompleteCertificateRefsType *soap_alloc(void) const { return SOAP_NEW(ns6__CompleteCertificateRefsType); }
      public:
        /// Constructor with initializations
        ns6__CompleteCertificateRefsType() : ns6__CertRefs(), soap()
        { }
        virtual ~ns6__CompleteCertificateRefsType() { }
        /// Friend allocator used by soap_new_ns6__CompleteCertificateRefsType(struct soap*, int)
        friend SOAP_FMAC1 ns6__CompleteCertificateRefsType * SOAP_FMAC2 SCAP_instantiate_ns6__CompleteCertificateRefsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:380 */
#ifndef SOAP_TYPE_ns6__CertRefsType
#define SOAP_TYPE_ns6__CertRefsType (72)
/* complex XSD type 'ns6:CertRefsType': */
class SOAP_CMAC ns6__CertRefsType {
      public:
        /// Required element 'ns6:Cert' of XSD type 'ns6:CertType'
        std::vector<ns6__CertType *> ns6__Cert;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__CertRefsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__CertRefsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__CertRefsType, default initialized and not managed by a soap context
        virtual ns6__CertRefsType *soap_alloc(void) const { return SOAP_NEW(ns6__CertRefsType); }
      public:
        /// Constructor with initializations
        ns6__CertRefsType() : ns6__Cert(), soap()
        { }
        virtual ~ns6__CertRefsType() { }
        /// Friend allocator used by soap_new_ns6__CertRefsType(struct soap*, int)
        friend SOAP_FMAC1 ns6__CertRefsType * SOAP_FMAC2 SCAP_instantiate_ns6__CertRefsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:383 */
#ifndef SOAP_TYPE_ns6__CompleteRevocationRefsType
#define SOAP_TYPE_ns6__CompleteRevocationRefsType (73)
/* complex XSD type 'ns6:CompleteRevocationRefsType': */
class SOAP_CMAC ns6__CompleteRevocationRefsType {
      public:
        /// Required element 'ns6:CRLRefs' of XSD type 'ns6:CRLRefsType'
        ns6__CRLRefsType *ns6__CRLRefs;
        /// Required element 'ns6:OCSPRefs' of XSD type 'ns6:OCSPRefsType'
        ns6__OCSPRefsType *ns6__OCSPRefs;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__CompleteRevocationRefsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__CompleteRevocationRefsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__CompleteRevocationRefsType, default initialized and not managed by a soap context
        virtual ns6__CompleteRevocationRefsType *soap_alloc(void) const { return SOAP_NEW(ns6__CompleteRevocationRefsType); }
      public:
        /// Constructor with initializations
        ns6__CompleteRevocationRefsType() : ns6__CRLRefs(), ns6__OCSPRefs(), soap()
        { }
        virtual ~ns6__CompleteRevocationRefsType() { }
        /// Friend allocator used by soap_new_ns6__CompleteRevocationRefsType(struct soap*, int)
        friend SOAP_FMAC1 ns6__CompleteRevocationRefsType * SOAP_FMAC2 SCAP_instantiate_ns6__CompleteRevocationRefsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:386 */
#ifndef SOAP_TYPE_ns6__CRLRefsType
#define SOAP_TYPE_ns6__CRLRefsType (74)
/* complex XSD type 'ns6:CRLRefsType': */
class SOAP_CMAC ns6__CRLRefsType {
      public:
        /// Required element 'ns6:CRLRef' of XSD type 'ns6:CRLRefType'
        std::vector<ns6__CRLRefType *> ns6__CRLRef;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__CRLRefsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__CRLRefsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__CRLRefsType, default initialized and not managed by a soap context
        virtual ns6__CRLRefsType *soap_alloc(void) const { return SOAP_NEW(ns6__CRLRefsType); }
      public:
        /// Constructor with initializations
        ns6__CRLRefsType() : ns6__CRLRef(), soap()
        { }
        virtual ~ns6__CRLRefsType() { }
        /// Friend allocator used by soap_new_ns6__CRLRefsType(struct soap*, int)
        friend SOAP_FMAC1 ns6__CRLRefsType * SOAP_FMAC2 SCAP_instantiate_ns6__CRLRefsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:389 */
#ifndef SOAP_TYPE_ns6__CRLRefType
#define SOAP_TYPE_ns6__CRLRefType (75)
/* complex XSD type 'ns6:CRLRefType': */
class SOAP_CMAC ns6__CRLRefType {
      public:
        /// Required element 'ns6:DigestAlgAndValue' of XSD type 'ns6:DigestAlgAndValueType'
        ns6__DigestAlgAndValueType *ns6__DigestAlgAndValue;
        /// Required element 'ns6:CRLIdentifier' of XSD type 'ns6:CRLIdentifierType'
        ns6__CRLIdentifierType *ns6__CRLIdentifier;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__CRLRefType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__CRLRefType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__CRLRefType, default initialized and not managed by a soap context
        virtual ns6__CRLRefType *soap_alloc(void) const { return SOAP_NEW(ns6__CRLRefType); }
      public:
        /// Constructor with initializations
        ns6__CRLRefType() : ns6__DigestAlgAndValue(), ns6__CRLIdentifier(), soap()
        { }
        virtual ~ns6__CRLRefType() { }
        /// Friend allocator used by soap_new_ns6__CRLRefType(struct soap*, int)
        friend SOAP_FMAC1 ns6__CRLRefType * SOAP_FMAC2 SCAP_instantiate_ns6__CRLRefType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:392 */
#ifndef SOAP_TYPE_ns6__DigestAlgAndValueType
#define SOAP_TYPE_ns6__DigestAlgAndValueType (76)
/* complex XSD type 'ns6:DigestAlgAndValueType': */
class SOAP_CMAC ns6__DigestAlgAndValueType {
      public:
        /// Required element 'ns5:DigestMethod' of XSD type 'ns5:DigestMethodType'
        ns5__DigestMethodType *ns5__DigestMethod;
        /// Required element 'ns5:DigestValue' of XSD type 'ns5:DigestValueType'
        ns5__DigestValueType *ns5__DigestValue;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__DigestAlgAndValueType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__DigestAlgAndValueType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__DigestAlgAndValueType, default initialized and not managed by a soap context
        virtual ns6__DigestAlgAndValueType *soap_alloc(void) const { return SOAP_NEW(ns6__DigestAlgAndValueType); }
      public:
        /// Constructor with initializations
        ns6__DigestAlgAndValueType() : ns5__DigestMethod(), ns5__DigestValue(), soap()
        { }
        virtual ~ns6__DigestAlgAndValueType() { }
        /// Friend allocator used by soap_new_ns6__DigestAlgAndValueType(struct soap*, int)
        friend SOAP_FMAC1 ns6__DigestAlgAndValueType * SOAP_FMAC2 SCAP_instantiate_ns6__DigestAlgAndValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:395 */
#ifndef SOAP_TYPE_ns6__CRLIdentifierType
#define SOAP_TYPE_ns6__CRLIdentifierType (77)
/* complex XSD type 'ns6:CRLIdentifierType': */
class SOAP_CMAC ns6__CRLIdentifierType {
      public:
        /// Required element 'ns6:Issuer' of XSD type 'xsd:anyType'
        char *ns6__Issuer;
        /// Required element 'ns6:IssueTime' of XSD type 'xsd:anyType'
        char *ns6__IssueTime;
        /// Required element 'ns6:Number' of XSD type 'xsd:anyType'
        char *ns6__Number;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__CRLIdentifierType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__CRLIdentifierType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__CRLIdentifierType, default initialized and not managed by a soap context
        virtual ns6__CRLIdentifierType *soap_alloc(void) const { return SOAP_NEW(ns6__CRLIdentifierType); }
      public:
        /// Constructor with initializations
        ns6__CRLIdentifierType() : ns6__Issuer(), ns6__IssueTime(), ns6__Number(), soap()
        { }
        virtual ~ns6__CRLIdentifierType() { }
        /// Friend allocator used by soap_new_ns6__CRLIdentifierType(struct soap*, int)
        friend SOAP_FMAC1 ns6__CRLIdentifierType * SOAP_FMAC2 SCAP_instantiate_ns6__CRLIdentifierType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:398 */
#ifndef SOAP_TYPE_ns6__OCSPRefsType
#define SOAP_TYPE_ns6__OCSPRefsType (78)
/* complex XSD type 'ns6:OCSPRefsType': */
class SOAP_CMAC ns6__OCSPRefsType {
      public:
        /// Required element 'ns6:OCSPRef' of XSD type 'ns6:OCSPRefType'
        std::vector<ns6__OCSPRefType *> ns6__OCSPRef;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__OCSPRefsType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__OCSPRefsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__OCSPRefsType, default initialized and not managed by a soap context
        virtual ns6__OCSPRefsType *soap_alloc(void) const { return SOAP_NEW(ns6__OCSPRefsType); }
      public:
        /// Constructor with initializations
        ns6__OCSPRefsType() : ns6__OCSPRef(), soap()
        { }
        virtual ~ns6__OCSPRefsType() { }
        /// Friend allocator used by soap_new_ns6__OCSPRefsType(struct soap*, int)
        friend SOAP_FMAC1 ns6__OCSPRefsType * SOAP_FMAC2 SCAP_instantiate_ns6__OCSPRefsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:401 */
#ifndef SOAP_TYPE_ns6__OCSPRefType
#define SOAP_TYPE_ns6__OCSPRefType (79)
/* complex XSD type 'ns6:OCSPRefType': */
class SOAP_CMAC ns6__OCSPRefType {
      public:
        /// Required element 'ns6:OCSPIdentifier' of XSD type 'ns6:OCSPIdentifierType'
        ns6__OCSPIdentifierType *ns6__OCSPIdentifier;
        /// Required element 'ns6:DigestAlgAndValue' of XSD type 'ns6:DigestAlgAndValueType'
        ns6__DigestAlgAndValueType *ns6__DigestAlgAndValue;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__OCSPRefType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__OCSPRefType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__OCSPRefType, default initialized and not managed by a soap context
        virtual ns6__OCSPRefType *soap_alloc(void) const { return SOAP_NEW(ns6__OCSPRefType); }
      public:
        /// Constructor with initializations
        ns6__OCSPRefType() : ns6__OCSPIdentifier(), ns6__DigestAlgAndValue(), soap()
        { }
        virtual ~ns6__OCSPRefType() { }
        /// Friend allocator used by soap_new_ns6__OCSPRefType(struct soap*, int)
        friend SOAP_FMAC1 ns6__OCSPRefType * SOAP_FMAC2 SCAP_instantiate_ns6__OCSPRefType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:404 */
#ifndef SOAP_TYPE_ns6__OCSPIdentifierType
#define SOAP_TYPE_ns6__OCSPIdentifierType (80)
/* complex XSD type 'ns6:OCSPIdentifierType': */
class SOAP_CMAC ns6__OCSPIdentifierType {
      public:
        /// Required element 'ns6:ResponderID' of XSD type 'ns6:ResponderIDType'
        ns6__ResponderIDType *ns6__ResponderID;
        /// Required element 'ns6:ProducedAt' of XSD type 'xsd:anyType'
        char *ns6__ProducedAt;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__OCSPIdentifierType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__OCSPIdentifierType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__OCSPIdentifierType, default initialized and not managed by a soap context
        virtual ns6__OCSPIdentifierType *soap_alloc(void) const { return SOAP_NEW(ns6__OCSPIdentifierType); }
      public:
        /// Constructor with initializations
        ns6__OCSPIdentifierType() : ns6__ResponderID(), ns6__ProducedAt(), soap()
        { }
        virtual ~ns6__OCSPIdentifierType() { }
        /// Friend allocator used by soap_new_ns6__OCSPIdentifierType(struct soap*, int)
        friend SOAP_FMAC1 ns6__OCSPIdentifierType * SOAP_FMAC2 SCAP_instantiate_ns6__OCSPIdentifierType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:407 */
#ifndef SOAP_TYPE_ns6__ResponderIDType
#define SOAP_TYPE_ns6__ResponderIDType (81)
/* complex XSD type 'ns6:ResponderIDType': */
class SOAP_CMAC ns6__ResponderIDType {
      public:
        /// Required element 'ns6:ByName' of XSD type 'xsd:anyType'
        char *ns6__ByName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__ResponderIDType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__ResponderIDType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__ResponderIDType, default initialized and not managed by a soap context
        virtual ns6__ResponderIDType *soap_alloc(void) const { return SOAP_NEW(ns6__ResponderIDType); }
      public:
        /// Constructor with initializations
        ns6__ResponderIDType() : ns6__ByName(), soap()
        { }
        virtual ~ns6__ResponderIDType() { }
        /// Friend allocator used by soap_new_ns6__ResponderIDType(struct soap*, int)
        friend SOAP_FMAC1 ns6__ResponderIDType * SOAP_FMAC2 SCAP_instantiate_ns6__ResponderIDType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:410 */
#ifndef SOAP_TYPE_ns6__SigAndRefsTimeStampType
#define SOAP_TYPE_ns6__SigAndRefsTimeStampType (82)
/* complex XSD type 'ns6:SigAndRefsTimeStampType': */
class SOAP_CMAC ns6__SigAndRefsTimeStampType {
      public:
        /// Required element 'ns5:CanonicalizationMethod' of XSD type 'ns5:CanonicalizationMethodType'
        ns5__CanonicalizationMethodType *ns5__CanonicalizationMethod;
        /// Required element 'ns6:EncapsulatedTimeStamp' of XSD type 'ns6:EncapsulatedTimeStampType'
        xsd__base64Binary ns6__EncapsulatedTimeStamp;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__SigAndRefsTimeStampType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__SigAndRefsTimeStampType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__SigAndRefsTimeStampType, default initialized and not managed by a soap context
        virtual ns6__SigAndRefsTimeStampType *soap_alloc(void) const { return SOAP_NEW(ns6__SigAndRefsTimeStampType); }
      public:
        /// Constructor with initializations
        ns6__SigAndRefsTimeStampType() : ns5__CanonicalizationMethod(), ns6__EncapsulatedTimeStamp(), soap()
        { }
        virtual ~ns6__SigAndRefsTimeStampType() { }
        /// Friend allocator used by soap_new_ns6__SigAndRefsTimeStampType(struct soap*, int)
        friend SOAP_FMAC1 ns6__SigAndRefsTimeStampType * SOAP_FMAC2 SCAP_instantiate_ns6__SigAndRefsTimeStampType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:413 */
#ifndef SOAP_TYPE_ns6__CertificateValuesType
#define SOAP_TYPE_ns6__CertificateValuesType (83)
/* complex XSD type 'ns6:CertificateValuesType': */
class SOAP_CMAC ns6__CertificateValuesType {
      public:
        /// Required element 'ns6:EncapsulatedX509Certificate' of XSD type 'ns6:EncapsulatedX509CertificateType'
        std::vector<ns6__EncapsulatedX509CertificateType *> ns6__EncapsulatedX509Certificate;
        /// required attribute 'Id' of XSD type 'xsd:ID'
        std::string Id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__CertificateValuesType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__CertificateValuesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__CertificateValuesType, default initialized and not managed by a soap context
        virtual ns6__CertificateValuesType *soap_alloc(void) const { return SOAP_NEW(ns6__CertificateValuesType); }
      public:
        /// Constructor with initializations
        ns6__CertificateValuesType() : ns6__EncapsulatedX509Certificate(), Id(), soap()
        { }
        virtual ~ns6__CertificateValuesType() { }
        /// Friend allocator used by soap_new_ns6__CertificateValuesType(struct soap*, int)
        friend SOAP_FMAC1 ns6__CertificateValuesType * SOAP_FMAC2 SCAP_instantiate_ns6__CertificateValuesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:419 */
#ifndef SOAP_TYPE_ns6__RevocationValuesType
#define SOAP_TYPE_ns6__RevocationValuesType (85)
/* complex XSD type 'ns6:RevocationValuesType': */
class SOAP_CMAC ns6__RevocationValuesType {
      public:
        /// Required element 'ns6:CRLValues' of XSD type 'ns6:CRLValuesType'
        ns6__CRLValuesType *ns6__CRLValues;
        /// Required element 'ns6:OCSPValues' of XSD type 'ns6:OCSPValuesType'
        ns6__OCSPValuesType *ns6__OCSPValues;
        /// required attribute 'Id' of XSD type 'xsd:ID'
        std::string Id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__RevocationValuesType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__RevocationValuesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__RevocationValuesType, default initialized and not managed by a soap context
        virtual ns6__RevocationValuesType *soap_alloc(void) const { return SOAP_NEW(ns6__RevocationValuesType); }
      public:
        /// Constructor with initializations
        ns6__RevocationValuesType() : ns6__CRLValues(), ns6__OCSPValues(), Id(), soap()
        { }
        virtual ~ns6__RevocationValuesType() { }
        /// Friend allocator used by soap_new_ns6__RevocationValuesType(struct soap*, int)
        friend SOAP_FMAC1 ns6__RevocationValuesType * SOAP_FMAC2 SCAP_instantiate_ns6__RevocationValuesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:422 */
#ifndef SOAP_TYPE_ns6__CRLValuesType
#define SOAP_TYPE_ns6__CRLValuesType (86)
/* complex XSD type 'ns6:CRLValuesType': */
class SOAP_CMAC ns6__CRLValuesType {
      public:
        /// Required element 'ns6:EncapsulatedCRLValue' of XSD type 'ns6:EncapsulatedCRLValueType'
        std::vector<ns6__EncapsulatedCRLValueType *> ns6__EncapsulatedCRLValue;
        /// required attribute 'Id' of XSD type 'xsd:ID'
        std::string Id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__CRLValuesType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__CRLValuesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__CRLValuesType, default initialized and not managed by a soap context
        virtual ns6__CRLValuesType *soap_alloc(void) const { return SOAP_NEW(ns6__CRLValuesType); }
      public:
        /// Constructor with initializations
        ns6__CRLValuesType() : ns6__EncapsulatedCRLValue(), Id(), soap()
        { }
        virtual ~ns6__CRLValuesType() { }
        /// Friend allocator used by soap_new_ns6__CRLValuesType(struct soap*, int)
        friend SOAP_FMAC1 ns6__CRLValuesType * SOAP_FMAC2 SCAP_instantiate_ns6__CRLValuesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:428 */
#ifndef SOAP_TYPE_ns6__OCSPValuesType
#define SOAP_TYPE_ns6__OCSPValuesType (88)
/* complex XSD type 'ns6:OCSPValuesType': */
class SOAP_CMAC ns6__OCSPValuesType {
      public:
        /// Required element 'ns6:EncapsulatedOCSPValue' of XSD type 'ns6:EncapsulatedOCSPValueType'
        std::vector<ns6__EncapsulatedOCSPValueType *> ns6__EncapsulatedOCSPValue;
        /// required attribute 'Id' of XSD type 'xsd:ID'
        std::string Id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__OCSPValuesType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__OCSPValuesType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__OCSPValuesType, default initialized and not managed by a soap context
        virtual ns6__OCSPValuesType *soap_alloc(void) const { return SOAP_NEW(ns6__OCSPValuesType); }
      public:
        /// Constructor with initializations
        ns6__OCSPValuesType() : ns6__EncapsulatedOCSPValue(), Id(), soap()
        { }
        virtual ~ns6__OCSPValuesType() { }
        /// Friend allocator used by soap_new_ns6__OCSPValuesType(struct soap*, int)
        friend SOAP_FMAC1 ns6__OCSPValuesType * SOAP_FMAC2 SCAP_instantiate_ns6__OCSPValuesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:434 */
#ifndef SOAP_TYPE_ns6__ArchiveTimeStampType
#define SOAP_TYPE_ns6__ArchiveTimeStampType (90)
/* complex XSD type 'ns6:ArchiveTimeStampType': */
class SOAP_CMAC ns6__ArchiveTimeStampType {
      public:
        /// Required element 'ns5:CanonicalizationMethod' of XSD type 'ns5:CanonicalizationMethodType'
        ns5__CanonicalizationMethodType *ns5__CanonicalizationMethod;
        /// Required element 'ns6:EncapsulatedTimeStamp' of XSD type 'ns6:EncapsulatedTimeStampType'
        xsd__base64Binary ns6__EncapsulatedTimeStamp;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__ArchiveTimeStampType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__ArchiveTimeStampType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__ArchiveTimeStampType, default initialized and not managed by a soap context
        virtual ns6__ArchiveTimeStampType *soap_alloc(void) const { return SOAP_NEW(ns6__ArchiveTimeStampType); }
      public:
        /// Constructor with initializations
        ns6__ArchiveTimeStampType() : ns5__CanonicalizationMethod(), ns6__EncapsulatedTimeStamp(), soap()
        { }
        virtual ~ns6__ArchiveTimeStampType() { }
        /// Friend allocator used by soap_new_ns6__ArchiveTimeStampType(struct soap*, int)
        friend SOAP_FMAC1 ns6__ArchiveTimeStampType * SOAP_FMAC2 SCAP_instantiate_ns6__ArchiveTimeStampType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:452 */
#ifndef SOAP_TYPE_ns7__SVGListType
#define SOAP_TYPE_ns7__SVGListType (96)
/* complex XSD type 'ns7:SVGListType': */
class SOAP_CMAC ns7__SVGListType {
      public:
        /// Required element 'ns7:SVG' of XSD type 'ns7:SVGType'
        std::vector<xsd__base64Binary> ns7__SVG;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__SVGListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__SVGListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__SVGListType, default initialized and not managed by a soap context
        virtual ns7__SVGListType *soap_alloc(void) const { return SOAP_NEW(ns7__SVGListType); }
      public:
        /// Constructor with initializations
        ns7__SVGListType() : ns7__SVG(), soap()
        { }
        virtual ~ns7__SVGListType() { }
        /// Friend allocator used by soap_new_ns7__SVGListType(struct soap*, int)
        friend SOAP_FMAC1 ns7__SVGListType * SOAP_FMAC2 SCAP_instantiate_ns7__SVGListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:455 */
#ifndef SOAP_TYPE_ns9__AttributeSupplierResponseType
#define SOAP_TYPE_ns9__AttributeSupplierResponseType (97)
/* complex XSD type 'ns9:AttributeSupplierResponseType': */
class SOAP_CMAC ns9__AttributeSupplierResponseType {
      public:
        /// Optional element 'ns9:AttributeSupplier' of XSD type 'ns3:AttributeSupplierType'
        std::vector<ns3__AttributeSupplierType *> AttributeSupplier;
        /// Optional element 'ns9:ErrorMessage' of XSD type 'xsd:string'
        std::string *ErrorMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns9__AttributeSupplierResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns9__AttributeSupplierResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns9__AttributeSupplierResponseType, default initialized and not managed by a soap context
        virtual ns9__AttributeSupplierResponseType *soap_alloc(void) const { return SOAP_NEW(ns9__AttributeSupplierResponseType); }
      public:
        /// Constructor with initializations
        ns9__AttributeSupplierResponseType() : AttributeSupplier(), ErrorMessage(), soap()
        { }
        virtual ~ns9__AttributeSupplierResponseType() { }
        /// Friend allocator used by soap_new_ns9__AttributeSupplierResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns9__AttributeSupplierResponseType * SOAP_FMAC2 SCAP_instantiate_ns9__AttributeSupplierResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:458 */
#ifndef SOAP_TYPE_ns1__PersonalData
#define SOAP_TYPE_ns1__PersonalData (98)
/* complex XSD type 'ns1:PersonalData': */
class SOAP_CMAC ns1__PersonalData {
      public:
        /// Required element 'ns1:Name' of XSD type 'xsd:string'
        std::string Name;
        /// Required element 'ns1:NIC' of XSD type 'xsd:string'
        std::string NIC;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__PersonalData
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__PersonalData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__PersonalData, default initialized and not managed by a soap context
        virtual ns1__PersonalData *soap_alloc(void) const { return SOAP_NEW(ns1__PersonalData); }
      public:
        /// Constructor with initializations
        ns1__PersonalData() : Name(), NIC(), soap()
        { }
        virtual ~ns1__PersonalData() { }
        /// Friend allocator used by soap_new_ns1__PersonalData(struct soap*, int)
        friend SOAP_FMAC1 ns1__PersonalData * SOAP_FMAC2 SCAP_instantiate_ns1__PersonalData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:461 */
#ifndef SOAP_TYPE_ns1__AttributeListType
#define SOAP_TYPE_ns1__AttributeListType (99)
/* complex XSD type 'ns1:AttributeListType': */
class SOAP_CMAC ns1__AttributeListType {
      public:
        /// Required element 'ns1:Attribute' of XSD type 'ns1:AttributeType'
        std::vector<ns1__AttributeType *> Attribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AttributeListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AttributeListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AttributeListType, default initialized and not managed by a soap context
        virtual ns1__AttributeListType *soap_alloc(void) const { return SOAP_NEW(ns1__AttributeListType); }
      public:
        /// Constructor with initializations
        ns1__AttributeListType() : Attribute(), soap()
        { }
        virtual ~ns1__AttributeListType() { }
        /// Friend allocator used by soap_new_ns1__AttributeListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__AttributeListType * SOAP_FMAC2 SCAP_instantiate_ns1__AttributeListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:464 */
#ifndef SOAP_TYPE_ns1__AttributeType
#define SOAP_TYPE_ns1__AttributeType (100)
/* complex XSD type 'ns1:AttributeType': */
class SOAP_CMAC ns1__AttributeType {
      public:
        /// Required element 'ns1:AttributeSupplier' of XSD type 'ns1:AttributeSupplierType'
        ns1__AttributeSupplierType *AttributeSupplier;
        /// Optional element 'ns1:MainAttribute' of XSD type 'ns1:MainAttributeType'
        ns1__MainAttributeType *MainAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AttributeType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AttributeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AttributeType, default initialized and not managed by a soap context
        virtual ns1__AttributeType *soap_alloc(void) const { return SOAP_NEW(ns1__AttributeType); }
      public:
        /// Constructor with initializations
        ns1__AttributeType() : AttributeSupplier(), MainAttribute(), soap()
        { }
        virtual ~ns1__AttributeType() { }
        /// Friend allocator used by soap_new_ns1__AttributeType(struct soap*, int)
        friend SOAP_FMAC1 ns1__AttributeType * SOAP_FMAC2 SCAP_instantiate_ns1__AttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:467 */
#ifndef SOAP_TYPE_ns1__AttributeSupplierType
#define SOAP_TYPE_ns1__AttributeSupplierType (101)
/* complex XSD type 'ns1:AttributeSupplierType': */
class SOAP_CMAC ns1__AttributeSupplierType {
      public:
        /// Required element 'ns1:Id' of XSD type 'xsd:string'
        std::string Id;
        /// Required element 'ns1:Name' of XSD type 'xsd:string'
        std::string Name;
        /// Optional element 'ns1:Type' of XSD type 'xsd:string'
        std::string *Type;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AttributeSupplierType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AttributeSupplierType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AttributeSupplierType, default initialized and not managed by a soap context
        virtual ns1__AttributeSupplierType *soap_alloc(void) const { return SOAP_NEW(ns1__AttributeSupplierType); }
      public:
        /// Constructor with initializations
        ns1__AttributeSupplierType() : Id(), Name(), Type(), soap()
        { }
        virtual ~ns1__AttributeSupplierType() { }
        /// Friend allocator used by soap_new_ns1__AttributeSupplierType(struct soap*, int)
        friend SOAP_FMAC1 ns1__AttributeSupplierType * SOAP_FMAC2 SCAP_instantiate_ns1__AttributeSupplierType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:470 */
#ifndef SOAP_TYPE_ns1__MainAttributeType
#define SOAP_TYPE_ns1__MainAttributeType (102)
/* complex XSD type 'ns1:MainAttributeType': */
class SOAP_CMAC ns1__MainAttributeType {
      public:
        /// Required element 'ns1:AttributeID' of XSD type 'xsd:string'
        std::string AttributeID;
        /// Optional element 'ns1:Description' of XSD type 'xsd:string'
        std::string *Description;
        /// Optional element 'ns1:LegalActList' of XSD type 'ns1:LegalActListType'
        ns1__LegalActListType *LegalActList;
        /// Optional element 'ns1:SubAttributeList' of XSD type 'ns1:SubAttributeListType'
        ns1__SubAttributeListType *SubAttributeList;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MainAttributeType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MainAttributeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MainAttributeType, default initialized and not managed by a soap context
        virtual ns1__MainAttributeType *soap_alloc(void) const { return SOAP_NEW(ns1__MainAttributeType); }
      public:
        /// Constructor with initializations
        ns1__MainAttributeType() : AttributeID(), Description(), LegalActList(), SubAttributeList(), soap()
        { }
        virtual ~ns1__MainAttributeType() { }
        /// Friend allocator used by soap_new_ns1__MainAttributeType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MainAttributeType * SOAP_FMAC2 SCAP_instantiate_ns1__MainAttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:473 */
#ifndef SOAP_TYPE_ns1__LegalActListType
#define SOAP_TYPE_ns1__LegalActListType (103)
/* complex XSD type 'ns1:LegalActListType': */
class SOAP_CMAC ns1__LegalActListType {
      public:
        /// Required element 'ns1:LegalAct' of XSD type 'xsd:string'
        std::vector<std::string> LegalAct;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__LegalActListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__LegalActListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__LegalActListType, default initialized and not managed by a soap context
        virtual ns1__LegalActListType *soap_alloc(void) const { return SOAP_NEW(ns1__LegalActListType); }
      public:
        /// Constructor with initializations
        ns1__LegalActListType() : LegalAct(), soap()
        { }
        virtual ~ns1__LegalActListType() { }
        /// Friend allocator used by soap_new_ns1__LegalActListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__LegalActListType * SOAP_FMAC2 SCAP_instantiate_ns1__LegalActListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:476 */
#ifndef SOAP_TYPE_ns1__SubAttributeListType
#define SOAP_TYPE_ns1__SubAttributeListType (104)
/* complex XSD type 'ns1:SubAttributeListType': */
class SOAP_CMAC ns1__SubAttributeListType {
      public:
        /// Required element 'ns1:SubAttribute' of XSD type 'ns1:SubAttributeType'
        std::vector<ns1__SubAttributeType *> SubAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubAttributeListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SubAttributeListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubAttributeListType, default initialized and not managed by a soap context
        virtual ns1__SubAttributeListType *soap_alloc(void) const { return SOAP_NEW(ns1__SubAttributeListType); }
      public:
        /// Constructor with initializations
        ns1__SubAttributeListType() : SubAttribute(), soap()
        { }
        virtual ~ns1__SubAttributeListType() { }
        /// Friend allocator used by soap_new_ns1__SubAttributeListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubAttributeListType * SOAP_FMAC2 SCAP_instantiate_ns1__SubAttributeListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:479 */
#ifndef SOAP_TYPE_ns1__SubAttributeType
#define SOAP_TYPE_ns1__SubAttributeType (105)
/* complex XSD type 'ns1:SubAttributeType': */
class SOAP_CMAC ns1__SubAttributeType {
      public:
        /// Required element 'ns1:AttributeID' of XSD type 'xsd:string'
        std::string AttributeID;
        /// Optional element 'ns1:Description' of XSD type 'xsd:string'
        std::string *Description;
        /// Optional element 'ns1:LegalActList' of XSD type 'ns1:LegalActListType'
        ns1__LegalActListType *LegalActList;
        /// Optional element 'ns1:Value' of XSD type 'xsd:string'
        std::string *Value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubAttributeType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SubAttributeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubAttributeType, default initialized and not managed by a soap context
        virtual ns1__SubAttributeType *soap_alloc(void) const { return SOAP_NEW(ns1__SubAttributeType); }
      public:
        /// Constructor with initializations
        ns1__SubAttributeType() : AttributeID(), Description(), LegalActList(), Value(), soap()
        { }
        virtual ~ns1__SubAttributeType() { }
        /// Friend allocator used by soap_new_ns1__SubAttributeType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubAttributeType * SOAP_FMAC2 SCAP_instantiate_ns1__SubAttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:482 */
#ifndef SOAP_TYPE_ns1__Status
#define SOAP_TYPE_ns1__Status (106)
/* complex XSD type 'ns1:Status': */
class SOAP_CMAC ns1__Status {
      public:
        /// Required element 'ns1:Code' of XSD type 'xsd:string'
        std::string Code;
        /// Required element 'ns1:Message' of XSD type 'xsd:string'
        std::string Message;
        /// Optional element 'ns1:Field' of XSD type 'xsd:string'
        std::string *Field;
        /// Optional element 'ns1:FieldValue' of XSD type 'xsd:string'
        std::string *FieldValue;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Status
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__Status; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Status, default initialized and not managed by a soap context
        virtual ns1__Status *soap_alloc(void) const { return SOAP_NEW(ns1__Status); }
      public:
        /// Constructor with initializations
        ns1__Status() : Code(), Message(), Field(), FieldValue(), soap()
        { }
        virtual ~ns1__Status() { }
        /// Friend allocator used by soap_new_ns1__Status(struct soap*, int)
        friend SOAP_FMAC1 ns1__Status * SOAP_FMAC2 SCAP_instantiate_ns1__Status(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:485 */
#ifndef SOAP_TYPE_ns1__TransactionTypeList
#define SOAP_TYPE_ns1__TransactionTypeList (107)
/* complex XSD type 'ns1:TransactionTypeList': */
class SOAP_CMAC ns1__TransactionTypeList {
      public:
        /// Required element 'ns1:Transaction' of XSD type 'ns1:TransactionType'
        std::vector<ns1__TransactionType *> Transaction;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TransactionTypeList
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__TransactionTypeList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TransactionTypeList, default initialized and not managed by a soap context
        virtual ns1__TransactionTypeList *soap_alloc(void) const { return SOAP_NEW(ns1__TransactionTypeList); }
      public:
        /// Constructor with initializations
        ns1__TransactionTypeList() : Transaction(), soap()
        { }
        virtual ~ns1__TransactionTypeList() { }
        /// Friend allocator used by soap_new_ns1__TransactionTypeList(struct soap*, int)
        friend SOAP_FMAC1 ns1__TransactionTypeList * SOAP_FMAC2 SCAP_instantiate_ns1__TransactionTypeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:488 */
#ifndef SOAP_TYPE_ns1__TransactionType
#define SOAP_TYPE_ns1__TransactionType (108)
/* complex XSD type 'ns1:TransactionType': */
class SOAP_CMAC ns1__TransactionType {
      public:
        /// Required element 'ns1:TransactionId' of XSD type 'xsd:string'
        std::string TransactionId;
        /// Required element 'ns1:AttributeSupplier' of XSD type 'ns1:AttributeSupplierType'
        ns1__AttributeSupplierType *AttributeSupplier;
        /// Required element 'ns1:MainAttribute' of XSD type 'ns1:MainAttributeType'
        ns1__MainAttributeType *MainAttribute;
        /// Required element 'ns1:AttributeSupplierCertificateChain' of XSD type 'xsd:string'
        std::string AttributeSupplierCertificateChain;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TransactionType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__TransactionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TransactionType, default initialized and not managed by a soap context
        virtual ns1__TransactionType *soap_alloc(void) const { return SOAP_NEW(ns1__TransactionType); }
      public:
        /// Constructor with initializations
        ns1__TransactionType() : TransactionId(), AttributeSupplier(), MainAttribute(), AttributeSupplierCertificateChain(), soap()
        { }
        virtual ~ns1__TransactionType() { }
        /// Friend allocator used by soap_new_ns1__TransactionType(struct soap*, int)
        friend SOAP_FMAC1 ns1__TransactionType * SOAP_FMAC2 SCAP_instantiate_ns1__TransactionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:491 */
#ifndef SOAP_TYPE__ns1__AuthorizationRequest
#define SOAP_TYPE__ns1__AuthorizationRequest (109)
/* complex XSD type 'ns1:AuthorizationRequest': */
class SOAP_CMAC _ns1__AuthorizationRequest {
      public:
        /// Required element 'ns1:AppId' of XSD type 'xsd:string'
        std::string AppId;
        /// Required element 'ns1:TOTP' of XSD type 'xsd:string'
        std::string TOTP;
        /// Required element 'ns1:DocumentSignature' of XSD type 'xsd:base64Binary'
        xsd__base64Binary DocumentSignature;
        /// Required element 'ns1:DocumentHash' of XSD type 'xsd:base64Binary'
        xsd__base64Binary DocumentHash;
        /// Required element 'ns1:SignatureCertificate' of XSD type 'xsd:string'
        std::string SignatureCertificate;
        /// Required element 'ns1:PersonalData' of XSD type 'ns1:PersonalData'
        ns1__PersonalData *PersonalData;
        /// Required element 'ns1:AttributeList' of XSD type 'ns1:AttributeListType'
        ns1__AttributeListType *AttributeList;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__AuthorizationRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__AuthorizationRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__AuthorizationRequest, default initialized and not managed by a soap context
        virtual _ns1__AuthorizationRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__AuthorizationRequest); }
      public:
        /// Constructor with initializations
        _ns1__AuthorizationRequest() : AppId(), TOTP(), DocumentSignature(), DocumentHash(), SignatureCertificate(), PersonalData(), AttributeList(), soap()
        { }
        virtual ~_ns1__AuthorizationRequest() { }
        /// Friend allocator used by soap_new__ns1__AuthorizationRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__AuthorizationRequest * SOAP_FMAC2 SCAP_instantiate__ns1__AuthorizationRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:494 */
#ifndef SOAP_TYPE__ns1__AuthorizationResponse
#define SOAP_TYPE__ns1__AuthorizationResponse (110)
/* complex XSD type 'ns1:AuthorizationResponse': */
class SOAP_CMAC _ns1__AuthorizationResponse {
      public:
        /// Required element 'ns1:Status' of XSD type 'ns1:Status'
        ns1__Status *Status;
        /// Optional element 'ns1:ProcessId' of XSD type 'xsd:string'
        std::string *ProcessId;
        /// Optional element 'ns1:TransactionList' of XSD type 'ns1:TransactionTypeList'
        ns1__TransactionTypeList *TransactionList;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__AuthorizationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__AuthorizationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__AuthorizationResponse, default initialized and not managed by a soap context
        virtual _ns1__AuthorizationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__AuthorizationResponse); }
      public:
        /// Constructor with initializations
        _ns1__AuthorizationResponse() : Status(), ProcessId(), TransactionList(), soap()
        { }
        virtual ~_ns1__AuthorizationResponse() { }
        /// Friend allocator used by soap_new__ns1__AuthorizationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__AuthorizationResponse * SOAP_FMAC2 SCAP_instantiate__ns1__AuthorizationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:497 */
#ifndef SOAP_TYPE__ns1__SignatureRequest
#define SOAP_TYPE__ns1__SignatureRequest (111)
/* complex XSD type 'ns1:SignatureRequest': */
class SOAP_CMAC _ns1__SignatureRequest {
      public:
        /// Required element 'ns1:AppId' of XSD type 'xsd:string'
        std::string AppId;
        /// Required element 'ns1:ProcessId' of XSD type 'xsd:string'
        std::string ProcessId;
        /// Optional element 'ns1:TOTP' of XSD type 'xsd:string'
        std::string *TOTP;
        /// Required element 'ns1:Hash' of XSD type 'xsd:base64Binary'
        xsd__base64Binary Hash;
        /// Required element 'ns1:Transaction' of XSD type 'ns1:TransactionType'
        ns1__TransactionType *Transaction;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SignatureRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SignatureRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SignatureRequest, default initialized and not managed by a soap context
        virtual _ns1__SignatureRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__SignatureRequest); }
      public:
        /// Constructor with initializations
        _ns1__SignatureRequest() : AppId(), ProcessId(), TOTP(), Hash(), Transaction(), soap()
        { }
        virtual ~_ns1__SignatureRequest() { }
        /// Friend allocator used by soap_new__ns1__SignatureRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SignatureRequest * SOAP_FMAC2 SCAP_instantiate__ns1__SignatureRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:500 */
#ifndef SOAP_TYPE__ns1__SignatureResponse
#define SOAP_TYPE__ns1__SignatureResponse (112)
/* complex XSD type 'ns1:SignatureResponse': */
class SOAP_CMAC _ns1__SignatureResponse {
      public:
        /// Required element 'ns1:Status' of XSD type 'ns1:Status'
        ns1__Status *Status;
        /// Optional element 'ns1:ProcessId' of XSD type 'xsd:string'
        std::string *ProcessId;
        /// Optional element 'ns1:DocumentSignature' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *DocumentSignature;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SignatureResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SignatureResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SignatureResponse, default initialized and not managed by a soap context
        virtual _ns1__SignatureResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SignatureResponse); }
      public:
        /// Constructor with initializations
        _ns1__SignatureResponse() : Status(), ProcessId(), DocumentSignature(), soap()
        { }
        virtual ~_ns1__SignatureResponse() { }
        /// Friend allocator used by soap_new__ns1__SignatureResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SignatureResponse * SOAP_FMAC2 SCAP_instantiate__ns1__SignatureResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:296 */
#ifndef SOAP_TYPE_ns5__X509CertificateType
#define SOAP_TYPE_ns5__X509CertificateType (44)
/* simple XSD type 'ns5:X509CertificateType': */
class SOAP_CMAC ns5__X509CertificateType {
      public:
        /// Simple content of XSD type 'xsd:base64Binary' wrapped by this struct
        xsd__base64Binary __item;
        /// required attribute 'Id' of XSD type 'xsd:ID'
        std::string Id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__X509CertificateType
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__X509CertificateType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__X509CertificateType, default initialized and not managed by a soap context
        virtual ns5__X509CertificateType *soap_alloc(void) const { return SOAP_NEW(ns5__X509CertificateType); }
      public:
        /// Constructor with initializations
        ns5__X509CertificateType() : __item(), Id(), soap()
        { }
        virtual ~ns5__X509CertificateType() { }
        /// Friend allocator used by soap_new_ns5__X509CertificateType(struct soap*, int)
        friend SOAP_FMAC1 ns5__X509CertificateType * SOAP_FMAC2 SCAP_instantiate_ns5__X509CertificateType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:299 */
#ifndef SOAP_TYPE_ns5__DigestValueType
#define SOAP_TYPE_ns5__DigestValueType (45)
/* simple XSD type 'ns5:DigestValueType': */
class SOAP_CMAC ns5__DigestValueType {
      public:
        /// Simple content of XSD type 'xsd:base64Binary' wrapped by this struct
        xsd__base64Binary __item;
        /// optional attribute 'Id' of XSD type 'xsd:ID'
        std::string *Id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__DigestValueType
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__DigestValueType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__DigestValueType, default initialized and not managed by a soap context
        virtual ns5__DigestValueType *soap_alloc(void) const { return SOAP_NEW(ns5__DigestValueType); }
      public:
        /// Constructor with initializations
        ns5__DigestValueType() : __item(), Id(), soap()
        { }
        virtual ~ns5__DigestValueType() { }
        /// Friend allocator used by soap_new_ns5__DigestValueType(struct soap*, int)
        friend SOAP_FMAC1 ns5__DigestValueType * SOAP_FMAC2 SCAP_instantiate_ns5__DigestValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:302 */
#ifndef SOAP_TYPE_ns5__SignatureValueType
#define SOAP_TYPE_ns5__SignatureValueType (46)
/* simple XSD type 'ns5:SignatureValueType': */
class SOAP_CMAC ns5__SignatureValueType {
      public:
        /// Simple content of XSD type 'xsd:base64Binary' wrapped by this struct
        xsd__base64Binary __item;
        /// required attribute 'Id' of XSD type 'xsd:ID'
        std::string Id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__SignatureValueType
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__SignatureValueType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__SignatureValueType, default initialized and not managed by a soap context
        virtual ns5__SignatureValueType *soap_alloc(void) const { return SOAP_NEW(ns5__SignatureValueType); }
      public:
        /// Constructor with initializations
        ns5__SignatureValueType() : __item(), Id(), soap()
        { }
        virtual ~ns5__SignatureValueType() { }
        /// Friend allocator used by soap_new_ns5__SignatureValueType(struct soap*, int)
        friend SOAP_FMAC1 ns5__SignatureValueType * SOAP_FMAC2 SCAP_instantiate_ns5__SignatureValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:416 */
#ifndef SOAP_TYPE_ns6__EncapsulatedX509CertificateType
#define SOAP_TYPE_ns6__EncapsulatedX509CertificateType (84)
/* simple XSD type 'ns6:EncapsulatedX509CertificateType': */
class SOAP_CMAC ns6__EncapsulatedX509CertificateType {
      public:
        /// Simple content of XSD type 'xsd:base64Binary' wrapped by this struct
        xsd__base64Binary __item;
        /// required attribute 'Id' of XSD type 'xsd:ID'
        std::string Id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__EncapsulatedX509CertificateType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__EncapsulatedX509CertificateType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__EncapsulatedX509CertificateType, default initialized and not managed by a soap context
        virtual ns6__EncapsulatedX509CertificateType *soap_alloc(void) const { return SOAP_NEW(ns6__EncapsulatedX509CertificateType); }
      public:
        /// Constructor with initializations
        ns6__EncapsulatedX509CertificateType() : __item(), Id(), soap()
        { }
        virtual ~ns6__EncapsulatedX509CertificateType() { }
        /// Friend allocator used by soap_new_ns6__EncapsulatedX509CertificateType(struct soap*, int)
        friend SOAP_FMAC1 ns6__EncapsulatedX509CertificateType * SOAP_FMAC2 SCAP_instantiate_ns6__EncapsulatedX509CertificateType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:425 */
#ifndef SOAP_TYPE_ns6__EncapsulatedCRLValueType
#define SOAP_TYPE_ns6__EncapsulatedCRLValueType (87)
/* simple XSD type 'ns6:EncapsulatedCRLValueType': */
class SOAP_CMAC ns6__EncapsulatedCRLValueType {
      public:
        /// Simple content of XSD type 'xsd:base64Binary' wrapped by this struct
        xsd__base64Binary __item;
        /// required attribute 'Id' of XSD type 'xsd:ID'
        std::string Id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__EncapsulatedCRLValueType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__EncapsulatedCRLValueType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__EncapsulatedCRLValueType, default initialized and not managed by a soap context
        virtual ns6__EncapsulatedCRLValueType *soap_alloc(void) const { return SOAP_NEW(ns6__EncapsulatedCRLValueType); }
      public:
        /// Constructor with initializations
        ns6__EncapsulatedCRLValueType() : __item(), Id(), soap()
        { }
        virtual ~ns6__EncapsulatedCRLValueType() { }
        /// Friend allocator used by soap_new_ns6__EncapsulatedCRLValueType(struct soap*, int)
        friend SOAP_FMAC1 ns6__EncapsulatedCRLValueType * SOAP_FMAC2 SCAP_instantiate_ns6__EncapsulatedCRLValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:431 */
#ifndef SOAP_TYPE_ns6__EncapsulatedOCSPValueType
#define SOAP_TYPE_ns6__EncapsulatedOCSPValueType (89)
/* simple XSD type 'ns6:EncapsulatedOCSPValueType': */
class SOAP_CMAC ns6__EncapsulatedOCSPValueType {
      public:
        /// Simple content of XSD type 'xsd:base64Binary' wrapped by this struct
        xsd__base64Binary __item;
        /// required attribute 'Id' of XSD type 'xsd:ID'
        std::string Id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns6__EncapsulatedOCSPValueType
        virtual int soap_type(void) const { return SOAP_TYPE_ns6__EncapsulatedOCSPValueType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns6__EncapsulatedOCSPValueType, default initialized and not managed by a soap context
        virtual ns6__EncapsulatedOCSPValueType *soap_alloc(void) const { return SOAP_NEW(ns6__EncapsulatedOCSPValueType); }
      public:
        /// Constructor with initializations
        ns6__EncapsulatedOCSPValueType() : __item(), Id(), soap()
        { }
        virtual ~ns6__EncapsulatedOCSPValueType() { }
        /// Friend allocator used by soap_new_ns6__EncapsulatedOCSPValueType(struct soap*, int)
        friend SOAP_FMAC1 ns6__EncapsulatedOCSPValueType * SOAP_FMAC2 SCAP_instantiate_ns6__EncapsulatedOCSPValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:94 */
#ifndef SOAP_TYPE_wsa__EndpointReferenceType
#define SOAP_TYPE_wsa__EndpointReferenceType (309)
/* complex XSD type 'wsa:EndpointReferenceType': */
struct SOAP_CMAC wsa__EndpointReferenceType {
      public:
        /** Required element 'wsa:Address' of XSD type 'xsd:string' */
        char *Address;
        /** Optional element 'wsa:ReferenceProperties' of XSD type 'wsa:ReferencePropertiesType' */
        struct wsa__ReferencePropertiesType *ReferenceProperties;
        /** Optional element 'wsa:ReferenceParameters' of XSD type 'wsa:ReferenceParametersType' */
        struct wsa__ReferenceParametersType *ReferenceParameters;
        /** Optional element 'wsa:PortType' of XSD type 'xsd:QName' */
        char **PortType;
        /** Optional element 'wsa:ServiceName' of XSD type 'wsa:ServiceNameType' */
        struct wsa__ServiceNameType *ServiceName;
        /** Sequence of elements '-any' of XSD type 'xsd:anyType' stored in dynamic array __any of length __size */
        int __size;
        char **__any;
        /** Optional attribute '-anyAttribute' of XSD type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa__EndpointReferenceType */
        int soap_type() const { return SOAP_TYPE_wsa__EndpointReferenceType; }
        /** Constructor with member initializations */
        wsa__EndpointReferenceType() : Address(), ReferenceProperties(), ReferenceParameters(), PortType(), ServiceName(), __size(), __any(), __anyAttribute()
        { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa__EndpointReferenceType * SOAP_FMAC2 SCAP_instantiate_wsa__EndpointReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:97 */
#ifndef SOAP_TYPE_wsa__ReferencePropertiesType
#define SOAP_TYPE_wsa__ReferencePropertiesType (310)
/* complex XSD type 'wsa:ReferencePropertiesType': */
struct SOAP_CMAC wsa__ReferencePropertiesType {
      public:
        /** Sequence of elements '-any' of XSD type 'xsd:anyType' stored in dynamic array __any of length __size */
        int __size;
        char **__any;
      public:
        /** Return unique type id SOAP_TYPE_wsa__ReferencePropertiesType */
        int soap_type() const { return SOAP_TYPE_wsa__ReferencePropertiesType; }
        /** Constructor with member initializations */
        wsa__ReferencePropertiesType() : __size(), __any()
        { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa__ReferencePropertiesType * SOAP_FMAC2 SCAP_instantiate_wsa__ReferencePropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:100 */
#ifndef SOAP_TYPE_wsa__ReferenceParametersType
#define SOAP_TYPE_wsa__ReferenceParametersType (311)
/* complex XSD type 'wsa:ReferenceParametersType': */
struct SOAP_CMAC wsa__ReferenceParametersType {
      public:
        /** Sequence of elements '-any' of XSD type 'xsd:anyType' stored in dynamic array __any of length __size */
        int __size;
        char **__any;
      public:
        /** Return unique type id SOAP_TYPE_wsa__ReferenceParametersType */
        int soap_type() const { return SOAP_TYPE_wsa__ReferenceParametersType; }
        /** Constructor with member initializations */
        wsa__ReferenceParametersType() : __size(), __any()
        { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa__ReferenceParametersType * SOAP_FMAC2 SCAP_instantiate_wsa__ReferenceParametersType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:103 */
#ifndef SOAP_TYPE_wsa__ServiceNameType
#define SOAP_TYPE_wsa__ServiceNameType (312)
/* simple XSD type 'wsa:ServiceNameType': */
struct SOAP_CMAC wsa__ServiceNameType {
      public:
        /** Simple content of XSD type 'xsd:QName' wrapped by this struct */
        char *__item;
        /** Optional attribute 'PortName' of XSD type 'xsd:string' */
        char *PortName;
        /** Optional attribute '-anyAttribute' of XSD type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa__ServiceNameType */
        int soap_type() const { return SOAP_TYPE_wsa__ServiceNameType; }
        /** Constructor with member initializations */
        wsa__ServiceNameType() : __item(), PortName(), __anyAttribute()
        { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa__ServiceNameType * SOAP_FMAC2 SCAP_instantiate_wsa__ServiceNameType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:106 */
#ifndef SOAP_TYPE_wsa__Relationship
#define SOAP_TYPE_wsa__Relationship (313)
/* simple XSD type 'wsa:Relationship': */
struct SOAP_CMAC wsa__Relationship {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'RelationshipType' of XSD type 'xsd:QName' */
        char *RelationshipType;
        /** Optional attribute '-anyAttribute' of XSD type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa__Relationship */
        int soap_type() const { return SOAP_TYPE_wsa__Relationship; }
        /** Constructor with member initializations */
        wsa__Relationship() : __item(), RelationshipType(), __anyAttribute()
        { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa__Relationship * SOAP_FMAC2 SCAP_instantiate_wsa__Relationship(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:250 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (330)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Optional element 'wsa:MessageID' of XSD type 'wsa:MessageID' */
        char *wsa__MessageID;
        /** Optional element 'wsa:RelatesTo' of XSD type 'wsa:RelatesTo' */
        struct wsa__Relationship *wsa__RelatesTo;
        /** Optional element 'wsa:From' of XSD type 'wsa:From' */
        struct wsa__EndpointReferenceType *wsa__From;
        /** MustUnderstand */
        struct wsa__EndpointReferenceType *wsa__ReplyTo;
        /** MustUnderstand */
        struct wsa__EndpointReferenceType *wsa__FaultTo;
        /** MustUnderstand */
        char *wsa__To;
        /** MustUnderstand */
        char *wsa__Action;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() : wsa__MessageID(), wsa__RelatesTo(), wsa__From(), wsa__ReplyTo(), wsa__FaultTo(), wsa__To(), wsa__Action()
        { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 SCAP_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa.h:266 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (335)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault()
        { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 SCAP_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa.h:267 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (337)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode()
        { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 SCAP_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa.h:268 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (339)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text()
        { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 SCAP_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa.h:273 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (343)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail()
        { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 SCAP_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* SCAP-Services.h:3383 */
#ifndef SOAP_TYPE___ns1__Attributes
#define SOAP_TYPE___ns1__Attributes (347)
/* Wrapper: */
struct SOAP_CMAC __ns1__Attributes {
      public:
        /** Optional element 'ns2:AttributeRequest' of XSD type 'ns2:AttributeRequestType' */
        ns2__AttributeRequestType *ns2__AttributeRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Attributes */
        int soap_type() const { return SOAP_TYPE___ns1__Attributes; }
        /** Constructor with member initializations */
        __ns1__Attributes() : ns2__AttributeRequest()
        { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__Attributes * SOAP_FMAC2 SCAP_instantiate___ns1__Attributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:3471 */
#ifndef SOAP_TYPE___ns2__Authorization
#define SOAP_TYPE___ns2__Authorization (351)
/* Wrapper: */
struct SOAP_CMAC __ns2__Authorization {
      public:
        /** Optional element 'ns1:AuthorizationRequest' of XSD type 'ns1:AuthorizationRequest' */
        _ns1__AuthorizationRequest *ns1__AuthorizationRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns2__Authorization */
        int soap_type() const { return SOAP_TYPE___ns2__Authorization; }
        /** Constructor with member initializations */
        __ns2__Authorization() : ns1__AuthorizationRequest()
        { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns2__Authorization * SOAP_FMAC2 SCAP_instantiate___ns2__Authorization(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:3559 */
#ifndef SOAP_TYPE___ns3__Signature
#define SOAP_TYPE___ns3__Signature (355)
/* Wrapper: */
struct SOAP_CMAC __ns3__Signature {
      public:
        /** Optional element 'ns1:SignatureRequest' of XSD type 'ns1:SignatureRequest' */
        _ns1__SignatureRequest *ns1__SignatureRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns3__Signature */
        int soap_type() const { return SOAP_TYPE___ns3__Signature; }
        /** Constructor with member initializations */
        __ns3__Signature() : ns1__SignatureRequest()
        { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns3__Signature * SOAP_FMAC2 SCAP_instantiate___ns3__Signature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:3644 */
#ifndef SOAP_TYPE___ns8__AttributeSuppliers
#define SOAP_TYPE___ns8__AttributeSuppliers (358)
/* Wrapper: */
struct SOAP_CMAC __ns8__AttributeSuppliers {
      public:
        /** Return unique type id SOAP_TYPE___ns8__AttributeSuppliers */
        int soap_type() const { return SOAP_TYPE___ns8__AttributeSuppliers; }
        /** Constructor with member initializations */
        __ns8__AttributeSuppliers()
        { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns8__AttributeSuppliers * SOAP_FMAC2 SCAP_instantiate___ns8__AttributeSuppliers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* SCAP-Services.h:102 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* SCAP-Services.h:102 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* SCAP-Services.h:207 */
#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (17)
typedef std::string xsd__ID;
#endif

/* SCAP-Services.h:210 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (18)
typedef std::string xsd__anyURI;
#endif

/* SCAP-Services.h:213 */
#ifndef SOAP_TYPE_xsd__date
#define SOAP_TYPE_xsd__date (19)
typedef std::string xsd__date;
#endif

/* SCAP-Services.h:216 */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (20)
typedef std::string xsd__integer;
#endif

/* SCAP-Services.h:437 */
#ifndef SOAP_TYPE__ns6__Issuer
#define SOAP_TYPE__ns6__Issuer (91)
typedef _XML _ns6__Issuer;
#endif

/* SCAP-Services.h:440 */
#ifndef SOAP_TYPE__ns6__IssueTime
#define SOAP_TYPE__ns6__IssueTime (92)
typedef _XML _ns6__IssueTime;
#endif

/* SCAP-Services.h:443 */
#ifndef SOAP_TYPE__ns6__Number
#define SOAP_TYPE__ns6__Number (93)
typedef _XML _ns6__Number;
#endif

/* SCAP-Services.h:446 */
#ifndef SOAP_TYPE__ns6__ByName
#define SOAP_TYPE__ns6__ByName (94)
typedef _XML _ns6__ByName;
#endif

/* SCAP-Services.h:449 */
#ifndef SOAP_TYPE__ns6__ProducedAt
#define SOAP_TYPE__ns6__ProducedAt (95)
typedef _XML _ns6__ProducedAt;
#endif

/* SCAP-Services.h:584 */
#ifndef SOAP_TYPE_ns5__X509IssuerNameType
#define SOAP_TYPE_ns5__X509IssuerNameType (113)
typedef std::string ns5__X509IssuerNameType;
#endif

/* SCAP-Services.h:588 */
#ifndef SOAP_TYPE_ns5__X509SerialNumberType
#define SOAP_TYPE_ns5__X509SerialNumberType (114)
typedef xsd__integer ns5__X509SerialNumberType;
#endif

/* SCAP-Services.h:609 */
#ifndef SOAP_TYPE_ns4__ProcessIDType
#define SOAP_TYPE_ns4__ProcessIDType (115)
typedef std::string ns4__ProcessIDType;
#endif

/* SCAP-Services.h:614 */
#ifndef SOAP_TYPE_ns4__NameType
#define SOAP_TYPE_ns4__NameType (116)
typedef std::string ns4__NameType;
#endif

/* SCAP-Services.h:618 */
#ifndef SOAP_TYPE_ns4__ValidityType
#define SOAP_TYPE_ns4__ValidityType (117)
typedef xsd__date ns4__ValidityType;
#endif

/* SCAP-Services.h:622 */
#ifndef SOAP_TYPE_ns4__DateType
#define SOAP_TYPE_ns4__DateType (118)
typedef xsd__date ns4__DateType;
#endif

/* SCAP-Services.h:627 */
#ifndef SOAP_TYPE_ns4__NICType
#define SOAP_TYPE_ns4__NICType (119)
typedef std::string ns4__NICType;
#endif

/* SCAP-Services.h:632 */
#ifndef SOAP_TYPE_ns4__NIPCType
#define SOAP_TYPE_ns4__NIPCType (120)
typedef std::string ns4__NIPCType;
#endif

/* SCAP-Services.h:637 */
#ifndef SOAP_TYPE_ns4__CompanyNameType
#define SOAP_TYPE_ns4__CompanyNameType (121)
typedef std::string ns4__CompanyNameType;
#endif

/* SCAP-Services.h:642 */
#ifndef SOAP_TYPE_ns4__ExtraIDValueType
#define SOAP_TYPE_ns4__ExtraIDValueType (122)
typedef std::string ns4__ExtraIDValueType;
#endif

/* SCAP-Services.h:647 */
#ifndef SOAP_TYPE_ns4__AttributeIDType
#define SOAP_TYPE_ns4__AttributeIDType (123)
typedef std::string ns4__AttributeIDType;
#endif

/* SCAP-Services.h:652 */
#ifndef SOAP_TYPE_ns4__LegalActType
#define SOAP_TYPE_ns4__LegalActType (124)
typedef std::string ns4__LegalActType;
#endif

/* SCAP-Services.h:657 */
#ifndef SOAP_TYPE_ns4__SubAttributeValueType
#define SOAP_TYPE_ns4__SubAttributeValueType (125)
typedef std::string ns4__SubAttributeValueType;
#endif

/* SCAP-Services.h:662 */
#ifndef SOAP_TYPE_ns4__DescriptionType
#define SOAP_TYPE_ns4__DescriptionType (126)
typedef std::string ns4__DescriptionType;
#endif

/* SCAP-Services.h:667 */
#ifndef SOAP_TYPE_ns4__ResponseCodeType
#define SOAP_TYPE_ns4__ResponseCodeType (127)
typedef std::string ns4__ResponseCodeType;
#endif

/* SCAP-Services.h:672 */
#ifndef SOAP_TYPE_ns4__ResponseCodeMessage
#define SOAP_TYPE_ns4__ResponseCodeMessage (128)
typedef std::string ns4__ResponseCodeMessage;
#endif

/* SCAP-Services.h:684 */
#ifndef SOAP_TYPE_ns6__SigningTimeType
#define SOAP_TYPE_ns6__SigningTimeType (130)
typedef time_t ns6__SigningTimeType;
#endif

/* SCAP-Services.h:688 */
#ifndef SOAP_TYPE_ns6__EncapsulatedTimeStampType
#define SOAP_TYPE_ns6__EncapsulatedTimeStampType (131)
typedef xsd__base64Binary ns6__EncapsulatedTimeStampType;
#endif

/* SCAP-Services.h:692 */
#ifndef SOAP_TYPE_ns6__IssuerType
#define SOAP_TYPE_ns6__IssuerType (132)
typedef std::string ns6__IssuerType;
#endif

/* SCAP-Services.h:696 */
#ifndef SOAP_TYPE_ns6__IssueTimeType
#define SOAP_TYPE_ns6__IssueTimeType (133)
typedef time_t ns6__IssueTimeType;
#endif

/* SCAP-Services.h:700 */
#ifndef SOAP_TYPE_ns6__NumberType
#define SOAP_TYPE_ns6__NumberType (134)
typedef xsd__integer ns6__NumberType;
#endif

/* SCAP-Services.h:704 */
#ifndef SOAP_TYPE_ns6__ByNameType
#define SOAP_TYPE_ns6__ByNameType (135)
typedef std::string ns6__ByNameType;
#endif

/* SCAP-Services.h:708 */
#ifndef SOAP_TYPE_ns6__ProducedAtType
#define SOAP_TYPE_ns6__ProducedAtType (136)
typedef time_t ns6__ProducedAtType;
#endif

/* SCAP-Services.h:720 */
#ifndef SOAP_TYPE_ns7__SVGType
#define SOAP_TYPE_ns7__SVGType (137)
typedef xsd__base64Binary ns7__SVGType;
#endif

/* SCAP-Services.h:2846 */
#ifndef SOAP_TYPE__ns2__AttributeRequest
#define SOAP_TYPE__ns2__AttributeRequest (248)
typedef ns2__AttributeRequestType _ns2__AttributeRequest;
#endif

/* SCAP-Services.h:2849 */
#ifndef SOAP_TYPE__ns2__AttributeResponse
#define SOAP_TYPE__ns2__AttributeResponse (249)
typedef ns2__AttributeResponseType _ns2__AttributeResponse;
#endif

/* SCAP-Services.h:2852 */
#ifndef SOAP_TYPE__ns2__PSAAttributeRequest
#define SOAP_TYPE__ns2__PSAAttributeRequest (250)
typedef ns2__PSAAttributeRequestType _ns2__PSAAttributeRequest;
#endif

/* SCAP-Services.h:2855 */
#ifndef SOAP_TYPE__ns2__SingleAttributeResponse
#define SOAP_TYPE__ns2__SingleAttributeResponse (251)
typedef ns2__SingleAttributeResponseType _ns2__SingleAttributeResponse;
#endif

/* SCAP-Services.h:2874 */
#ifndef SOAP_TYPE__ns5__Signature
#define SOAP_TYPE__ns5__Signature (252)
typedef ns5__SignatureType _ns5__Signature;
#endif

/* SCAP-Services.h:2877 */
#ifndef SOAP_TYPE__ns5__SignedInfo
#define SOAP_TYPE__ns5__SignedInfo (253)
typedef ns5__SignedInfoType _ns5__SignedInfo;
#endif

/* SCAP-Services.h:2880 */
#ifndef SOAP_TYPE__ns5__CanonicalizationMethod
#define SOAP_TYPE__ns5__CanonicalizationMethod (254)
typedef ns5__CanonicalizationMethodType _ns5__CanonicalizationMethod;
#endif

/* SCAP-Services.h:2883 */
#ifndef SOAP_TYPE__ns5__SignatureMethod
#define SOAP_TYPE__ns5__SignatureMethod (255)
typedef ns5__SignatureMethodType _ns5__SignatureMethod;
#endif

/* SCAP-Services.h:2886 */
#ifndef SOAP_TYPE__ns5__Reference
#define SOAP_TYPE__ns5__Reference (256)
typedef ns5__ReferenceType _ns5__Reference;
#endif

/* SCAP-Services.h:2889 */
#ifndef SOAP_TYPE__ns5__Transforms
#define SOAP_TYPE__ns5__Transforms (257)
typedef ns5__TransformsType _ns5__Transforms;
#endif

/* SCAP-Services.h:2892 */
#ifndef SOAP_TYPE__ns5__Transform
#define SOAP_TYPE__ns5__Transform (258)
typedef ns5__TransformType _ns5__Transform;
#endif

/* SCAP-Services.h:2895 */
#ifndef SOAP_TYPE__ns5__DigestMethod
#define SOAP_TYPE__ns5__DigestMethod (259)
typedef ns5__DigestMethodType _ns5__DigestMethod;
#endif

/* SCAP-Services.h:2898 */
#ifndef SOAP_TYPE__ns5__KeyInfo
#define SOAP_TYPE__ns5__KeyInfo (260)
typedef ns5__KeyInfoType _ns5__KeyInfo;
#endif

/* SCAP-Services.h:2901 */
#ifndef SOAP_TYPE__ns5__X509Data
#define SOAP_TYPE__ns5__X509Data (261)
typedef ns5__X509DataType _ns5__X509Data;
#endif

/* SCAP-Services.h:2904 */
#ifndef SOAP_TYPE__ns5__Object
#define SOAP_TYPE__ns5__Object (262)
typedef ns5__ObjectType _ns5__Object;
#endif

/* SCAP-Services.h:2907 */
#ifndef SOAP_TYPE__ns5__X509Certificate
#define SOAP_TYPE__ns5__X509Certificate (263)
typedef ns5__X509CertificateType _ns5__X509Certificate;
#endif

/* SCAP-Services.h:2910 */
#ifndef SOAP_TYPE__ns5__DigestValue
#define SOAP_TYPE__ns5__DigestValue (264)
typedef ns5__DigestValueType _ns5__DigestValue;
#endif

/* SCAP-Services.h:2913 */
#ifndef SOAP_TYPE__ns5__SignatureValue
#define SOAP_TYPE__ns5__SignatureValue (265)
typedef ns5__SignatureValueType _ns5__SignatureValue;
#endif

/* SCAP-Services.h:2916 */
#ifndef SOAP_TYPE__ns5__X509IssuerName
#define SOAP_TYPE__ns5__X509IssuerName (266)
typedef ns5__X509IssuerNameType _ns5__X509IssuerName;
#endif

/* SCAP-Services.h:2919 */
#ifndef SOAP_TYPE__ns5__X509SerialNumber
#define SOAP_TYPE__ns5__X509SerialNumber (267)
typedef ns5__X509SerialNumberType _ns5__X509SerialNumber;
#endif

/* SCAP-Services.h:2938 */
#ifndef SOAP_TYPE__ns3__Attribute
#define SOAP_TYPE__ns3__Attribute (268)
typedef ns3__AttributeType _ns3__Attribute;
#endif

/* SCAP-Services.h:2941 */
#ifndef SOAP_TYPE__ns3__SignatureAttribute
#define SOAP_TYPE__ns3__SignatureAttribute (269)
typedef ns5__SignatureType _ns3__SignatureAttribute;
#endif

/* SCAP-Services.h:2976 */
#ifndef SOAP_TYPE__ns6__QualifyingProperties
#define SOAP_TYPE__ns6__QualifyingProperties (270)
typedef ns6__QualifyingPropertiesType _ns6__QualifyingProperties;
#endif

/* SCAP-Services.h:2979 */
#ifndef SOAP_TYPE__ns6__SignedProperties
#define SOAP_TYPE__ns6__SignedProperties (271)
typedef ns6__SignedPropertiesType _ns6__SignedProperties;
#endif

/* SCAP-Services.h:2982 */
#ifndef SOAP_TYPE__ns6__SignedSignatureProperties
#define SOAP_TYPE__ns6__SignedSignatureProperties (272)
typedef ns6__SignedSignaturePropertiesType _ns6__SignedSignatureProperties;
#endif

/* SCAP-Services.h:2985 */
#ifndef SOAP_TYPE__ns6__SigningCertificate
#define SOAP_TYPE__ns6__SigningCertificate (273)
typedef ns6__SigningCertificateType _ns6__SigningCertificate;
#endif

/* SCAP-Services.h:2988 */
#ifndef SOAP_TYPE__ns6__Cert
#define SOAP_TYPE__ns6__Cert (274)
typedef ns6__CertType _ns6__Cert;
#endif

/* SCAP-Services.h:2991 */
#ifndef SOAP_TYPE__ns6__CertDigest
#define SOAP_TYPE__ns6__CertDigest (275)
typedef ns6__CertDigestType _ns6__CertDigest;
#endif

/* SCAP-Services.h:2994 */
#ifndef SOAP_TYPE__ns6__IssuerSerial
#define SOAP_TYPE__ns6__IssuerSerial (276)
typedef ns6__IssuerSerialType _ns6__IssuerSerial;
#endif

/* SCAP-Services.h:2997 */
#ifndef SOAP_TYPE__ns6__SigningTime
#define SOAP_TYPE__ns6__SigningTime (277)
typedef ns6__SigningTimeType _ns6__SigningTime;
#endif

/* SCAP-Services.h:3000 */
#ifndef SOAP_TYPE__ns6__SignerRole
#define SOAP_TYPE__ns6__SignerRole (278)
typedef ns6__SignerRoleType _ns6__SignerRole;
#endif

/* SCAP-Services.h:3003 */
#ifndef SOAP_TYPE__ns6__ClaimedRoles
#define SOAP_TYPE__ns6__ClaimedRoles (279)
typedef ns6__ClaimedRolesListType _ns6__ClaimedRoles;
#endif

/* SCAP-Services.h:3006 */
#ifndef SOAP_TYPE__ns6__ClaimedRole
#define SOAP_TYPE__ns6__ClaimedRole (280)
typedef ns6__ClaimedRoleType _ns6__ClaimedRole;
#endif

/* SCAP-Services.h:3009 */
#ifndef SOAP_TYPE__ns6__UnsignedProperties
#define SOAP_TYPE__ns6__UnsignedProperties (281)
typedef ns6__UnsignedPropertiesType _ns6__UnsignedProperties;
#endif

/* SCAP-Services.h:3012 */
#ifndef SOAP_TYPE__ns6__UnsignedSignatureProperties
#define SOAP_TYPE__ns6__UnsignedSignatureProperties (282)
typedef ns6__UnsignedSignaturePropertiesType _ns6__UnsignedSignatureProperties;
#endif

/* SCAP-Services.h:3015 */
#ifndef SOAP_TYPE__ns6__CounterSignature
#define SOAP_TYPE__ns6__CounterSignature (283)
typedef ns6__CounterSignatureType _ns6__CounterSignature;
#endif

/* SCAP-Services.h:3018 */
#ifndef SOAP_TYPE__ns6__SignatureTimeStamp
#define SOAP_TYPE__ns6__SignatureTimeStamp (284)
typedef ns6__SignatureTimeStampType _ns6__SignatureTimeStamp;
#endif

/* SCAP-Services.h:3021 */
#ifndef SOAP_TYPE__ns6__EncapsulatedTimeStamp
#define SOAP_TYPE__ns6__EncapsulatedTimeStamp (285)
typedef ns6__EncapsulatedTimeStampType _ns6__EncapsulatedTimeStamp;
#endif

/* SCAP-Services.h:3024 */
#ifndef SOAP_TYPE__ns6__CompleteCertificateRefs
#define SOAP_TYPE__ns6__CompleteCertificateRefs (286)
typedef ns6__CompleteCertificateRefsType _ns6__CompleteCertificateRefs;
#endif

/* SCAP-Services.h:3027 */
#ifndef SOAP_TYPE__ns6__CertRefs
#define SOAP_TYPE__ns6__CertRefs (287)
typedef ns6__CertRefsType _ns6__CertRefs;
#endif

/* SCAP-Services.h:3030 */
#ifndef SOAP_TYPE__ns6__CompleteRevocationRefs
#define SOAP_TYPE__ns6__CompleteRevocationRefs (288)
typedef ns6__CompleteRevocationRefsType _ns6__CompleteRevocationRefs;
#endif

/* SCAP-Services.h:3033 */
#ifndef SOAP_TYPE__ns6__CRLRefs
#define SOAP_TYPE__ns6__CRLRefs (289)
typedef ns6__CRLRefsType _ns6__CRLRefs;
#endif

/* SCAP-Services.h:3036 */
#ifndef SOAP_TYPE__ns6__CRLRef
#define SOAP_TYPE__ns6__CRLRef (290)
typedef ns6__CRLRefType _ns6__CRLRef;
#endif

/* SCAP-Services.h:3039 */
#ifndef SOAP_TYPE__ns6__DigestAlgAndValue
#define SOAP_TYPE__ns6__DigestAlgAndValue (291)
typedef ns6__DigestAlgAndValueType _ns6__DigestAlgAndValue;
#endif

/* SCAP-Services.h:3042 */
#ifndef SOAP_TYPE__ns6__CRLIdentifier
#define SOAP_TYPE__ns6__CRLIdentifier (292)
typedef ns6__CRLIdentifierType _ns6__CRLIdentifier;
#endif

/* SCAP-Services.h:3045 */
#ifndef SOAP_TYPE__ns6__OCSPRefs
#define SOAP_TYPE__ns6__OCSPRefs (293)
typedef ns6__OCSPRefsType _ns6__OCSPRefs;
#endif

/* SCAP-Services.h:3048 */
#ifndef SOAP_TYPE__ns6__OCSPRef
#define SOAP_TYPE__ns6__OCSPRef (294)
typedef ns6__OCSPRefType _ns6__OCSPRef;
#endif

/* SCAP-Services.h:3051 */
#ifndef SOAP_TYPE__ns6__OCSPIdentifier
#define SOAP_TYPE__ns6__OCSPIdentifier (295)
typedef ns6__OCSPIdentifierType _ns6__OCSPIdentifier;
#endif

/* SCAP-Services.h:3054 */
#ifndef SOAP_TYPE__ns6__ResponderID
#define SOAP_TYPE__ns6__ResponderID (296)
typedef ns6__ResponderIDType _ns6__ResponderID;
#endif

/* SCAP-Services.h:3057 */
#ifndef SOAP_TYPE__ns6__SigAndRefsTimeStamp
#define SOAP_TYPE__ns6__SigAndRefsTimeStamp (297)
typedef ns6__SigAndRefsTimeStampType _ns6__SigAndRefsTimeStamp;
#endif

/* SCAP-Services.h:3060 */
#ifndef SOAP_TYPE__ns6__CertificateValues
#define SOAP_TYPE__ns6__CertificateValues (298)
typedef ns6__CertificateValuesType _ns6__CertificateValues;
#endif

/* SCAP-Services.h:3063 */
#ifndef SOAP_TYPE__ns6__EncapsulatedX509Certificate
#define SOAP_TYPE__ns6__EncapsulatedX509Certificate (299)
typedef ns6__EncapsulatedX509CertificateType _ns6__EncapsulatedX509Certificate;
#endif

/* SCAP-Services.h:3066 */
#ifndef SOAP_TYPE__ns6__RevocationValues
#define SOAP_TYPE__ns6__RevocationValues (300)
typedef ns6__RevocationValuesType _ns6__RevocationValues;
#endif

/* SCAP-Services.h:3069 */
#ifndef SOAP_TYPE__ns6__CRLValues
#define SOAP_TYPE__ns6__CRLValues (301)
typedef ns6__CRLValuesType _ns6__CRLValues;
#endif

/* SCAP-Services.h:3072 */
#ifndef SOAP_TYPE__ns6__EncapsulatedCRLValue
#define SOAP_TYPE__ns6__EncapsulatedCRLValue (302)
typedef ns6__EncapsulatedCRLValueType _ns6__EncapsulatedCRLValue;
#endif

/* SCAP-Services.h:3075 */
#ifndef SOAP_TYPE__ns6__OCSPValues
#define SOAP_TYPE__ns6__OCSPValues (303)
typedef ns6__OCSPValuesType _ns6__OCSPValues;
#endif

/* SCAP-Services.h:3078 */
#ifndef SOAP_TYPE__ns6__EncapsulatedOCSPValue
#define SOAP_TYPE__ns6__EncapsulatedOCSPValue (304)
typedef ns6__EncapsulatedOCSPValueType _ns6__EncapsulatedOCSPValue;
#endif

/* SCAP-Services.h:3081 */
#ifndef SOAP_TYPE__ns6__ArchiveTimeStamp
#define SOAP_TYPE__ns6__ArchiveTimeStamp (305)
typedef ns6__ArchiveTimeStampType _ns6__ArchiveTimeStamp;
#endif

/* SCAP-Services.h:3100 */
#ifndef SOAP_TYPE__ns7__SVGList
#define SOAP_TYPE__ns7__SVGList (306)
typedef ns7__SVGListType _ns7__SVGList;
#endif

/* SCAP-Services.h:3103 */
#ifndef SOAP_TYPE__ns7__SVG
#define SOAP_TYPE__ns7__SVG (307)
typedef ns7__SVGType _ns7__SVG;
#endif

/* SCAP-Services.h:3138 */
#ifndef SOAP_TYPE__ns9__AttributeSupplierResponse
#define SOAP_TYPE__ns9__AttributeSupplierResponse (308)
typedef ns9__AttributeSupplierResponseType _ns9__AttributeSupplierResponse;
#endif

/* wsa.h:220 */
#ifndef SOAP_TYPE__wsa__EndpointReference
#define SOAP_TYPE__wsa__EndpointReference (321)
typedef struct wsa__EndpointReferenceType _wsa__EndpointReference;
#endif

/* wsa.h:223 */
#ifndef SOAP_TYPE__wsa__MessageID
#define SOAP_TYPE__wsa__MessageID (322)
typedef char *_wsa__MessageID;
#endif

/* wsa.h:226 */
#ifndef SOAP_TYPE__wsa__RelatesTo
#define SOAP_TYPE__wsa__RelatesTo (323)
typedef struct wsa__Relationship _wsa__RelatesTo;
#endif

/* wsa.h:229 */
#ifndef SOAP_TYPE__wsa__To
#define SOAP_TYPE__wsa__To (324)
typedef char *_wsa__To;
#endif

/* wsa.h:232 */
#ifndef SOAP_TYPE__wsa__Action
#define SOAP_TYPE__wsa__Action (325)
typedef char *_wsa__Action;
#endif

/* wsa.h:235 */
#ifndef SOAP_TYPE__wsa__From
#define SOAP_TYPE__wsa__From (326)
typedef struct wsa__EndpointReferenceType _wsa__From;
#endif

/* wsa.h:238 */
#ifndef SOAP_TYPE__wsa__ReplyTo
#define SOAP_TYPE__wsa__ReplyTo (327)
typedef struct wsa__EndpointReferenceType _wsa__ReplyTo;
#endif

/* wsa.h:241 */
#ifndef SOAP_TYPE__wsa__FaultTo
#define SOAP_TYPE__wsa__FaultTo (328)
typedef struct wsa__EndpointReferenceType _wsa__FaultTo;
#endif

/* wsa.h:244 */
#ifndef SOAP_TYPE__wsa__ReplyAfter
#define SOAP_TYPE__wsa__ReplyAfter (329)
typedef unsigned int _wsa__ReplyAfter;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_unsignedByte
#define SOAP_TYPE_unsignedByte (13)
#endif

/* _wsa__ReplyAfter has binding name '_wsa__ReplyAfter' for type '' */
#ifndef SOAP_TYPE__wsa__ReplyAfter
#define SOAP_TYPE__wsa__ReplyAfter (329)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (12)
#endif

/* _ns6__SigningTime has binding name '_ns6__SigningTime' for type '' */
#ifndef SOAP_TYPE__ns6__SigningTime
#define SOAP_TYPE__ns6__SigningTime (277)
#endif

/* ns6__ProducedAtType has binding name 'ns6__ProducedAtType' for type 'ns6:ProducedAtType' */
#ifndef SOAP_TYPE_ns6__ProducedAtType
#define SOAP_TYPE_ns6__ProducedAtType (136)
#endif

/* ns6__IssueTimeType has binding name 'ns6__IssueTimeType' for type 'ns6:IssueTimeType' */
#ifndef SOAP_TYPE_ns6__IssueTimeType
#define SOAP_TYPE_ns6__IssueTimeType (133)
#endif

/* ns6__SigningTimeType has binding name 'ns6__SigningTimeType' for type 'ns6:SigningTimeType' */
#ifndef SOAP_TYPE_ns6__SigningTimeType
#define SOAP_TYPE_ns6__SigningTimeType (130)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (129)
#endif

/* enum wsa__FaultSubcodeValues has binding name 'wsa__FaultSubcodeValues' for type 'wsa:FaultSubcodeValues' */
#ifndef SOAP_TYPE_wsa__FaultSubcodeValues
#define SOAP_TYPE_wsa__FaultSubcodeValues (315)
#endif

/* enum wsa__RelationshipTypeValues has binding name 'wsa__RelationshipTypeValues' for type 'wsa:RelationshipTypeValues' */
#ifndef SOAP_TYPE_wsa__RelationshipTypeValues
#define SOAP_TYPE_wsa__RelationshipTypeValues (314)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (140)
#endif

/* _ns9__AttributeSupplierResponse has binding name '_ns9__AttributeSupplierResponse' for type '' */
#ifndef SOAP_TYPE__ns9__AttributeSupplierResponse
#define SOAP_TYPE__ns9__AttributeSupplierResponse (308)
#endif

/* _ns7__SVG has binding name '_ns7__SVG' for type '' */
#ifndef SOAP_TYPE__ns7__SVG
#define SOAP_TYPE__ns7__SVG (307)
#endif

/* _ns7__SVGList has binding name '_ns7__SVGList' for type '' */
#ifndef SOAP_TYPE__ns7__SVGList
#define SOAP_TYPE__ns7__SVGList (306)
#endif

/* _ns6__ArchiveTimeStamp has binding name '_ns6__ArchiveTimeStamp' for type '' */
#ifndef SOAP_TYPE__ns6__ArchiveTimeStamp
#define SOAP_TYPE__ns6__ArchiveTimeStamp (305)
#endif

/* _ns6__EncapsulatedOCSPValue has binding name '_ns6__EncapsulatedOCSPValue' for type '' */
#ifndef SOAP_TYPE__ns6__EncapsulatedOCSPValue
#define SOAP_TYPE__ns6__EncapsulatedOCSPValue (304)
#endif

/* _ns6__OCSPValues has binding name '_ns6__OCSPValues' for type '' */
#ifndef SOAP_TYPE__ns6__OCSPValues
#define SOAP_TYPE__ns6__OCSPValues (303)
#endif

/* _ns6__EncapsulatedCRLValue has binding name '_ns6__EncapsulatedCRLValue' for type '' */
#ifndef SOAP_TYPE__ns6__EncapsulatedCRLValue
#define SOAP_TYPE__ns6__EncapsulatedCRLValue (302)
#endif

/* _ns6__CRLValues has binding name '_ns6__CRLValues' for type '' */
#ifndef SOAP_TYPE__ns6__CRLValues
#define SOAP_TYPE__ns6__CRLValues (301)
#endif

/* _ns6__RevocationValues has binding name '_ns6__RevocationValues' for type '' */
#ifndef SOAP_TYPE__ns6__RevocationValues
#define SOAP_TYPE__ns6__RevocationValues (300)
#endif

/* _ns6__EncapsulatedX509Certificate has binding name '_ns6__EncapsulatedX509Certificate' for type '' */
#ifndef SOAP_TYPE__ns6__EncapsulatedX509Certificate
#define SOAP_TYPE__ns6__EncapsulatedX509Certificate (299)
#endif

/* _ns6__CertificateValues has binding name '_ns6__CertificateValues' for type '' */
#ifndef SOAP_TYPE__ns6__CertificateValues
#define SOAP_TYPE__ns6__CertificateValues (298)
#endif

/* _ns6__SigAndRefsTimeStamp has binding name '_ns6__SigAndRefsTimeStamp' for type '' */
#ifndef SOAP_TYPE__ns6__SigAndRefsTimeStamp
#define SOAP_TYPE__ns6__SigAndRefsTimeStamp (297)
#endif

/* _ns6__ResponderID has binding name '_ns6__ResponderID' for type '' */
#ifndef SOAP_TYPE__ns6__ResponderID
#define SOAP_TYPE__ns6__ResponderID (296)
#endif

/* _ns6__OCSPIdentifier has binding name '_ns6__OCSPIdentifier' for type '' */
#ifndef SOAP_TYPE__ns6__OCSPIdentifier
#define SOAP_TYPE__ns6__OCSPIdentifier (295)
#endif

/* _ns6__OCSPRef has binding name '_ns6__OCSPRef' for type '' */
#ifndef SOAP_TYPE__ns6__OCSPRef
#define SOAP_TYPE__ns6__OCSPRef (294)
#endif

/* _ns6__OCSPRefs has binding name '_ns6__OCSPRefs' for type '' */
#ifndef SOAP_TYPE__ns6__OCSPRefs
#define SOAP_TYPE__ns6__OCSPRefs (293)
#endif

/* _ns6__CRLIdentifier has binding name '_ns6__CRLIdentifier' for type '' */
#ifndef SOAP_TYPE__ns6__CRLIdentifier
#define SOAP_TYPE__ns6__CRLIdentifier (292)
#endif

/* _ns6__DigestAlgAndValue has binding name '_ns6__DigestAlgAndValue' for type '' */
#ifndef SOAP_TYPE__ns6__DigestAlgAndValue
#define SOAP_TYPE__ns6__DigestAlgAndValue (291)
#endif

/* _ns6__CRLRef has binding name '_ns6__CRLRef' for type '' */
#ifndef SOAP_TYPE__ns6__CRLRef
#define SOAP_TYPE__ns6__CRLRef (290)
#endif

/* _ns6__CRLRefs has binding name '_ns6__CRLRefs' for type '' */
#ifndef SOAP_TYPE__ns6__CRLRefs
#define SOAP_TYPE__ns6__CRLRefs (289)
#endif

/* _ns6__CompleteRevocationRefs has binding name '_ns6__CompleteRevocationRefs' for type '' */
#ifndef SOAP_TYPE__ns6__CompleteRevocationRefs
#define SOAP_TYPE__ns6__CompleteRevocationRefs (288)
#endif

/* _ns6__CertRefs has binding name '_ns6__CertRefs' for type '' */
#ifndef SOAP_TYPE__ns6__CertRefs
#define SOAP_TYPE__ns6__CertRefs (287)
#endif

/* _ns6__CompleteCertificateRefs has binding name '_ns6__CompleteCertificateRefs' for type '' */
#ifndef SOAP_TYPE__ns6__CompleteCertificateRefs
#define SOAP_TYPE__ns6__CompleteCertificateRefs (286)
#endif

/* _ns6__EncapsulatedTimeStamp has binding name '_ns6__EncapsulatedTimeStamp' for type '' */
#ifndef SOAP_TYPE__ns6__EncapsulatedTimeStamp
#define SOAP_TYPE__ns6__EncapsulatedTimeStamp (285)
#endif

/* _ns6__SignatureTimeStamp has binding name '_ns6__SignatureTimeStamp' for type '' */
#ifndef SOAP_TYPE__ns6__SignatureTimeStamp
#define SOAP_TYPE__ns6__SignatureTimeStamp (284)
#endif

/* _ns6__CounterSignature has binding name '_ns6__CounterSignature' for type '' */
#ifndef SOAP_TYPE__ns6__CounterSignature
#define SOAP_TYPE__ns6__CounterSignature (283)
#endif

/* _ns6__UnsignedSignatureProperties has binding name '_ns6__UnsignedSignatureProperties' for type '' */
#ifndef SOAP_TYPE__ns6__UnsignedSignatureProperties
#define SOAP_TYPE__ns6__UnsignedSignatureProperties (282)
#endif

/* _ns6__UnsignedProperties has binding name '_ns6__UnsignedProperties' for type '' */
#ifndef SOAP_TYPE__ns6__UnsignedProperties
#define SOAP_TYPE__ns6__UnsignedProperties (281)
#endif

/* _ns6__ClaimedRole has binding name '_ns6__ClaimedRole' for type '' */
#ifndef SOAP_TYPE__ns6__ClaimedRole
#define SOAP_TYPE__ns6__ClaimedRole (280)
#endif

/* _ns6__ClaimedRoles has binding name '_ns6__ClaimedRoles' for type '' */
#ifndef SOAP_TYPE__ns6__ClaimedRoles
#define SOAP_TYPE__ns6__ClaimedRoles (279)
#endif

/* _ns6__SignerRole has binding name '_ns6__SignerRole' for type '' */
#ifndef SOAP_TYPE__ns6__SignerRole
#define SOAP_TYPE__ns6__SignerRole (278)
#endif

/* _ns6__IssuerSerial has binding name '_ns6__IssuerSerial' for type '' */
#ifndef SOAP_TYPE__ns6__IssuerSerial
#define SOAP_TYPE__ns6__IssuerSerial (276)
#endif

/* _ns6__CertDigest has binding name '_ns6__CertDigest' for type '' */
#ifndef SOAP_TYPE__ns6__CertDigest
#define SOAP_TYPE__ns6__CertDigest (275)
#endif

/* _ns6__Cert has binding name '_ns6__Cert' for type '' */
#ifndef SOAP_TYPE__ns6__Cert
#define SOAP_TYPE__ns6__Cert (274)
#endif

/* _ns6__SigningCertificate has binding name '_ns6__SigningCertificate' for type '' */
#ifndef SOAP_TYPE__ns6__SigningCertificate
#define SOAP_TYPE__ns6__SigningCertificate (273)
#endif

/* _ns6__SignedSignatureProperties has binding name '_ns6__SignedSignatureProperties' for type '' */
#ifndef SOAP_TYPE__ns6__SignedSignatureProperties
#define SOAP_TYPE__ns6__SignedSignatureProperties (272)
#endif

/* _ns6__SignedProperties has binding name '_ns6__SignedProperties' for type '' */
#ifndef SOAP_TYPE__ns6__SignedProperties
#define SOAP_TYPE__ns6__SignedProperties (271)
#endif

/* _ns6__QualifyingProperties has binding name '_ns6__QualifyingProperties' for type '' */
#ifndef SOAP_TYPE__ns6__QualifyingProperties
#define SOAP_TYPE__ns6__QualifyingProperties (270)
#endif

/* _ns3__SignatureAttribute has binding name '_ns3__SignatureAttribute' for type '' */
#ifndef SOAP_TYPE__ns3__SignatureAttribute
#define SOAP_TYPE__ns3__SignatureAttribute (269)
#endif

/* _ns3__Attribute has binding name '_ns3__Attribute' for type '' */
#ifndef SOAP_TYPE__ns3__Attribute
#define SOAP_TYPE__ns3__Attribute (268)
#endif

/* _ns5__X509SerialNumber has binding name '_ns5__X509SerialNumber' for type '' */
#ifndef SOAP_TYPE__ns5__X509SerialNumber
#define SOAP_TYPE__ns5__X509SerialNumber (267)
#endif

/* _ns5__X509IssuerName has binding name '_ns5__X509IssuerName' for type '' */
#ifndef SOAP_TYPE__ns5__X509IssuerName
#define SOAP_TYPE__ns5__X509IssuerName (266)
#endif

/* _ns5__SignatureValue has binding name '_ns5__SignatureValue' for type '' */
#ifndef SOAP_TYPE__ns5__SignatureValue
#define SOAP_TYPE__ns5__SignatureValue (265)
#endif

/* _ns5__DigestValue has binding name '_ns5__DigestValue' for type '' */
#ifndef SOAP_TYPE__ns5__DigestValue
#define SOAP_TYPE__ns5__DigestValue (264)
#endif

/* _ns5__X509Certificate has binding name '_ns5__X509Certificate' for type '' */
#ifndef SOAP_TYPE__ns5__X509Certificate
#define SOAP_TYPE__ns5__X509Certificate (263)
#endif

/* _ns5__Object has binding name '_ns5__Object' for type '' */
#ifndef SOAP_TYPE__ns5__Object
#define SOAP_TYPE__ns5__Object (262)
#endif

/* _ns5__X509Data has binding name '_ns5__X509Data' for type '' */
#ifndef SOAP_TYPE__ns5__X509Data
#define SOAP_TYPE__ns5__X509Data (261)
#endif

/* _ns5__KeyInfo has binding name '_ns5__KeyInfo' for type '' */
#ifndef SOAP_TYPE__ns5__KeyInfo
#define SOAP_TYPE__ns5__KeyInfo (260)
#endif

/* _ns5__DigestMethod has binding name '_ns5__DigestMethod' for type '' */
#ifndef SOAP_TYPE__ns5__DigestMethod
#define SOAP_TYPE__ns5__DigestMethod (259)
#endif

/* _ns5__Transform has binding name '_ns5__Transform' for type '' */
#ifndef SOAP_TYPE__ns5__Transform
#define SOAP_TYPE__ns5__Transform (258)
#endif

/* _ns5__Transforms has binding name '_ns5__Transforms' for type '' */
#ifndef SOAP_TYPE__ns5__Transforms
#define SOAP_TYPE__ns5__Transforms (257)
#endif

/* _ns5__Reference has binding name '_ns5__Reference' for type '' */
#ifndef SOAP_TYPE__ns5__Reference
#define SOAP_TYPE__ns5__Reference (256)
#endif

/* _ns5__SignatureMethod has binding name '_ns5__SignatureMethod' for type '' */
#ifndef SOAP_TYPE__ns5__SignatureMethod
#define SOAP_TYPE__ns5__SignatureMethod (255)
#endif

/* _ns5__CanonicalizationMethod has binding name '_ns5__CanonicalizationMethod' for type '' */
#ifndef SOAP_TYPE__ns5__CanonicalizationMethod
#define SOAP_TYPE__ns5__CanonicalizationMethod (254)
#endif

/* _ns5__SignedInfo has binding name '_ns5__SignedInfo' for type '' */
#ifndef SOAP_TYPE__ns5__SignedInfo
#define SOAP_TYPE__ns5__SignedInfo (253)
#endif

/* _ns5__Signature has binding name '_ns5__Signature' for type '' */
#ifndef SOAP_TYPE__ns5__Signature
#define SOAP_TYPE__ns5__Signature (252)
#endif

/* _ns2__SingleAttributeResponse has binding name '_ns2__SingleAttributeResponse' for type '' */
#ifndef SOAP_TYPE__ns2__SingleAttributeResponse
#define SOAP_TYPE__ns2__SingleAttributeResponse (251)
#endif

/* _ns2__PSAAttributeRequest has binding name '_ns2__PSAAttributeRequest' for type '' */
#ifndef SOAP_TYPE__ns2__PSAAttributeRequest
#define SOAP_TYPE__ns2__PSAAttributeRequest (250)
#endif

/* _ns2__AttributeResponse has binding name '_ns2__AttributeResponse' for type '' */
#ifndef SOAP_TYPE__ns2__AttributeResponse
#define SOAP_TYPE__ns2__AttributeResponse (249)
#endif

/* _ns2__AttributeRequest has binding name '_ns2__AttributeRequest' for type '' */
#ifndef SOAP_TYPE__ns2__AttributeRequest
#define SOAP_TYPE__ns2__AttributeRequest (248)
#endif

/* ns7__SVGType has binding name 'ns7__SVGType' for type 'ns7:SVGType' */
#ifndef SOAP_TYPE_ns7__SVGType
#define SOAP_TYPE_ns7__SVGType (137)
#endif

/* ns6__ByNameType has binding name 'ns6__ByNameType' for type 'ns6:ByNameType' */
#ifndef SOAP_TYPE_ns6__ByNameType
#define SOAP_TYPE_ns6__ByNameType (135)
#endif

/* ns6__NumberType has binding name 'ns6__NumberType' for type 'ns6:NumberType' */
#ifndef SOAP_TYPE_ns6__NumberType
#define SOAP_TYPE_ns6__NumberType (134)
#endif

/* ns6__IssuerType has binding name 'ns6__IssuerType' for type 'ns6:IssuerType' */
#ifndef SOAP_TYPE_ns6__IssuerType
#define SOAP_TYPE_ns6__IssuerType (132)
#endif

/* ns6__EncapsulatedTimeStampType has binding name 'ns6__EncapsulatedTimeStampType' for type 'ns6:EncapsulatedTimeStampType' */
#ifndef SOAP_TYPE_ns6__EncapsulatedTimeStampType
#define SOAP_TYPE_ns6__EncapsulatedTimeStampType (131)
#endif

/* ns4__ResponseCodeMessage has binding name 'ns4__ResponseCodeMessage' for type 'ns4:ResponseCodeMessage' */
#ifndef SOAP_TYPE_ns4__ResponseCodeMessage
#define SOAP_TYPE_ns4__ResponseCodeMessage (128)
#endif

/* ns4__ResponseCodeType has binding name 'ns4__ResponseCodeType' for type 'ns4:ResponseCodeType' */
#ifndef SOAP_TYPE_ns4__ResponseCodeType
#define SOAP_TYPE_ns4__ResponseCodeType (127)
#endif

/* ns4__DescriptionType has binding name 'ns4__DescriptionType' for type 'ns4:DescriptionType' */
#ifndef SOAP_TYPE_ns4__DescriptionType
#define SOAP_TYPE_ns4__DescriptionType (126)
#endif

/* ns4__SubAttributeValueType has binding name 'ns4__SubAttributeValueType' for type 'ns4:SubAttributeValueType' */
#ifndef SOAP_TYPE_ns4__SubAttributeValueType
#define SOAP_TYPE_ns4__SubAttributeValueType (125)
#endif

/* ns4__LegalActType has binding name 'ns4__LegalActType' for type 'ns4:LegalActType' */
#ifndef SOAP_TYPE_ns4__LegalActType
#define SOAP_TYPE_ns4__LegalActType (124)
#endif

/* ns4__AttributeIDType has binding name 'ns4__AttributeIDType' for type 'ns4:AttributeIDType' */
#ifndef SOAP_TYPE_ns4__AttributeIDType
#define SOAP_TYPE_ns4__AttributeIDType (123)
#endif

/* ns4__ExtraIDValueType has binding name 'ns4__ExtraIDValueType' for type 'ns4:ExtraIDValueType' */
#ifndef SOAP_TYPE_ns4__ExtraIDValueType
#define SOAP_TYPE_ns4__ExtraIDValueType (122)
#endif

/* ns4__CompanyNameType has binding name 'ns4__CompanyNameType' for type 'ns4:CompanyNameType' */
#ifndef SOAP_TYPE_ns4__CompanyNameType
#define SOAP_TYPE_ns4__CompanyNameType (121)
#endif

/* ns4__NIPCType has binding name 'ns4__NIPCType' for type 'ns4:NIPCType' */
#ifndef SOAP_TYPE_ns4__NIPCType
#define SOAP_TYPE_ns4__NIPCType (120)
#endif

/* ns4__NICType has binding name 'ns4__NICType' for type 'ns4:NICType' */
#ifndef SOAP_TYPE_ns4__NICType
#define SOAP_TYPE_ns4__NICType (119)
#endif

/* ns4__DateType has binding name 'ns4__DateType' for type 'ns4:DateType' */
#ifndef SOAP_TYPE_ns4__DateType
#define SOAP_TYPE_ns4__DateType (118)
#endif

/* ns4__ValidityType has binding name 'ns4__ValidityType' for type 'ns4:ValidityType' */
#ifndef SOAP_TYPE_ns4__ValidityType
#define SOAP_TYPE_ns4__ValidityType (117)
#endif

/* ns4__NameType has binding name 'ns4__NameType' for type 'ns4:NameType' */
#ifndef SOAP_TYPE_ns4__NameType
#define SOAP_TYPE_ns4__NameType (116)
#endif

/* ns4__ProcessIDType has binding name 'ns4__ProcessIDType' for type 'ns4:ProcessIDType' */
#ifndef SOAP_TYPE_ns4__ProcessIDType
#define SOAP_TYPE_ns4__ProcessIDType (115)
#endif

/* ns5__X509SerialNumberType has binding name 'ns5__X509SerialNumberType' for type 'ns5:X509SerialNumberType' */
#ifndef SOAP_TYPE_ns5__X509SerialNumberType
#define SOAP_TYPE_ns5__X509SerialNumberType (114)
#endif

/* ns5__X509IssuerNameType has binding name 'ns5__X509IssuerNameType' for type 'ns5:X509IssuerNameType' */
#ifndef SOAP_TYPE_ns5__X509IssuerNameType
#define SOAP_TYPE_ns5__X509IssuerNameType (113)
#endif

/* _ns1__SignatureResponse has binding name '_ns1__SignatureResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SignatureResponse
#define SOAP_TYPE__ns1__SignatureResponse (112)
#endif

/* _ns1__SignatureRequest has binding name '_ns1__SignatureRequest' for type '' */
#ifndef SOAP_TYPE__ns1__SignatureRequest
#define SOAP_TYPE__ns1__SignatureRequest (111)
#endif

/* _ns1__AuthorizationResponse has binding name '_ns1__AuthorizationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__AuthorizationResponse
#define SOAP_TYPE__ns1__AuthorizationResponse (110)
#endif

/* _ns1__AuthorizationRequest has binding name '_ns1__AuthorizationRequest' for type '' */
#ifndef SOAP_TYPE__ns1__AuthorizationRequest
#define SOAP_TYPE__ns1__AuthorizationRequest (109)
#endif

/* ns1__TransactionType has binding name 'ns1__TransactionType' for type 'ns1:TransactionType' */
#ifndef SOAP_TYPE_ns1__TransactionType
#define SOAP_TYPE_ns1__TransactionType (108)
#endif

/* ns1__TransactionTypeList has binding name 'ns1__TransactionTypeList' for type 'ns1:TransactionTypeList' */
#ifndef SOAP_TYPE_ns1__TransactionTypeList
#define SOAP_TYPE_ns1__TransactionTypeList (107)
#endif

/* ns1__Status has binding name 'ns1__Status' for type 'ns1:Status' */
#ifndef SOAP_TYPE_ns1__Status
#define SOAP_TYPE_ns1__Status (106)
#endif

/* ns1__SubAttributeType has binding name 'ns1__SubAttributeType' for type 'ns1:SubAttributeType' */
#ifndef SOAP_TYPE_ns1__SubAttributeType
#define SOAP_TYPE_ns1__SubAttributeType (105)
#endif

/* ns1__SubAttributeListType has binding name 'ns1__SubAttributeListType' for type 'ns1:SubAttributeListType' */
#ifndef SOAP_TYPE_ns1__SubAttributeListType
#define SOAP_TYPE_ns1__SubAttributeListType (104)
#endif

/* ns1__LegalActListType has binding name 'ns1__LegalActListType' for type 'ns1:LegalActListType' */
#ifndef SOAP_TYPE_ns1__LegalActListType
#define SOAP_TYPE_ns1__LegalActListType (103)
#endif

/* ns1__MainAttributeType has binding name 'ns1__MainAttributeType' for type 'ns1:MainAttributeType' */
#ifndef SOAP_TYPE_ns1__MainAttributeType
#define SOAP_TYPE_ns1__MainAttributeType (102)
#endif

/* ns1__AttributeSupplierType has binding name 'ns1__AttributeSupplierType' for type 'ns1:AttributeSupplierType' */
#ifndef SOAP_TYPE_ns1__AttributeSupplierType
#define SOAP_TYPE_ns1__AttributeSupplierType (101)
#endif

/* ns1__AttributeType has binding name 'ns1__AttributeType' for type 'ns1:AttributeType' */
#ifndef SOAP_TYPE_ns1__AttributeType
#define SOAP_TYPE_ns1__AttributeType (100)
#endif

/* ns1__AttributeListType has binding name 'ns1__AttributeListType' for type 'ns1:AttributeListType' */
#ifndef SOAP_TYPE_ns1__AttributeListType
#define SOAP_TYPE_ns1__AttributeListType (99)
#endif

/* ns1__PersonalData has binding name 'ns1__PersonalData' for type 'ns1:PersonalData' */
#ifndef SOAP_TYPE_ns1__PersonalData
#define SOAP_TYPE_ns1__PersonalData (98)
#endif

/* ns9__AttributeSupplierResponseType has binding name 'ns9__AttributeSupplierResponseType' for type 'ns9:AttributeSupplierResponseType' */
#ifndef SOAP_TYPE_ns9__AttributeSupplierResponseType
#define SOAP_TYPE_ns9__AttributeSupplierResponseType (97)
#endif

/* ns7__SVGListType has binding name 'ns7__SVGListType' for type 'ns7:SVGListType' */
#ifndef SOAP_TYPE_ns7__SVGListType
#define SOAP_TYPE_ns7__SVGListType (96)
#endif

/* ns6__ArchiveTimeStampType has binding name 'ns6__ArchiveTimeStampType' for type 'ns6:ArchiveTimeStampType' */
#ifndef SOAP_TYPE_ns6__ArchiveTimeStampType
#define SOAP_TYPE_ns6__ArchiveTimeStampType (90)
#endif

/* ns6__EncapsulatedOCSPValueType has binding name 'ns6__EncapsulatedOCSPValueType' for type 'ns6:EncapsulatedOCSPValueType' */
#ifndef SOAP_TYPE_ns6__EncapsulatedOCSPValueType
#define SOAP_TYPE_ns6__EncapsulatedOCSPValueType (89)
#endif

/* ns6__OCSPValuesType has binding name 'ns6__OCSPValuesType' for type 'ns6:OCSPValuesType' */
#ifndef SOAP_TYPE_ns6__OCSPValuesType
#define SOAP_TYPE_ns6__OCSPValuesType (88)
#endif

/* ns6__EncapsulatedCRLValueType has binding name 'ns6__EncapsulatedCRLValueType' for type 'ns6:EncapsulatedCRLValueType' */
#ifndef SOAP_TYPE_ns6__EncapsulatedCRLValueType
#define SOAP_TYPE_ns6__EncapsulatedCRLValueType (87)
#endif

/* ns6__CRLValuesType has binding name 'ns6__CRLValuesType' for type 'ns6:CRLValuesType' */
#ifndef SOAP_TYPE_ns6__CRLValuesType
#define SOAP_TYPE_ns6__CRLValuesType (86)
#endif

/* ns6__RevocationValuesType has binding name 'ns6__RevocationValuesType' for type 'ns6:RevocationValuesType' */
#ifndef SOAP_TYPE_ns6__RevocationValuesType
#define SOAP_TYPE_ns6__RevocationValuesType (85)
#endif

/* ns6__EncapsulatedX509CertificateType has binding name 'ns6__EncapsulatedX509CertificateType' for type 'ns6:EncapsulatedX509CertificateType' */
#ifndef SOAP_TYPE_ns6__EncapsulatedX509CertificateType
#define SOAP_TYPE_ns6__EncapsulatedX509CertificateType (84)
#endif

/* ns6__CertificateValuesType has binding name 'ns6__CertificateValuesType' for type 'ns6:CertificateValuesType' */
#ifndef SOAP_TYPE_ns6__CertificateValuesType
#define SOAP_TYPE_ns6__CertificateValuesType (83)
#endif

/* ns6__SigAndRefsTimeStampType has binding name 'ns6__SigAndRefsTimeStampType' for type 'ns6:SigAndRefsTimeStampType' */
#ifndef SOAP_TYPE_ns6__SigAndRefsTimeStampType
#define SOAP_TYPE_ns6__SigAndRefsTimeStampType (82)
#endif

/* ns6__ResponderIDType has binding name 'ns6__ResponderIDType' for type 'ns6:ResponderIDType' */
#ifndef SOAP_TYPE_ns6__ResponderIDType
#define SOAP_TYPE_ns6__ResponderIDType (81)
#endif

/* ns6__OCSPIdentifierType has binding name 'ns6__OCSPIdentifierType' for type 'ns6:OCSPIdentifierType' */
#ifndef SOAP_TYPE_ns6__OCSPIdentifierType
#define SOAP_TYPE_ns6__OCSPIdentifierType (80)
#endif

/* ns6__OCSPRefType has binding name 'ns6__OCSPRefType' for type 'ns6:OCSPRefType' */
#ifndef SOAP_TYPE_ns6__OCSPRefType
#define SOAP_TYPE_ns6__OCSPRefType (79)
#endif

/* ns6__OCSPRefsType has binding name 'ns6__OCSPRefsType' for type 'ns6:OCSPRefsType' */
#ifndef SOAP_TYPE_ns6__OCSPRefsType
#define SOAP_TYPE_ns6__OCSPRefsType (78)
#endif

/* ns6__CRLIdentifierType has binding name 'ns6__CRLIdentifierType' for type 'ns6:CRLIdentifierType' */
#ifndef SOAP_TYPE_ns6__CRLIdentifierType
#define SOAP_TYPE_ns6__CRLIdentifierType (77)
#endif

/* ns6__DigestAlgAndValueType has binding name 'ns6__DigestAlgAndValueType' for type 'ns6:DigestAlgAndValueType' */
#ifndef SOAP_TYPE_ns6__DigestAlgAndValueType
#define SOAP_TYPE_ns6__DigestAlgAndValueType (76)
#endif

/* ns6__CRLRefType has binding name 'ns6__CRLRefType' for type 'ns6:CRLRefType' */
#ifndef SOAP_TYPE_ns6__CRLRefType
#define SOAP_TYPE_ns6__CRLRefType (75)
#endif

/* ns6__CRLRefsType has binding name 'ns6__CRLRefsType' for type 'ns6:CRLRefsType' */
#ifndef SOAP_TYPE_ns6__CRLRefsType
#define SOAP_TYPE_ns6__CRLRefsType (74)
#endif

/* ns6__CompleteRevocationRefsType has binding name 'ns6__CompleteRevocationRefsType' for type 'ns6:CompleteRevocationRefsType' */
#ifndef SOAP_TYPE_ns6__CompleteRevocationRefsType
#define SOAP_TYPE_ns6__CompleteRevocationRefsType (73)
#endif

/* ns6__CertRefsType has binding name 'ns6__CertRefsType' for type 'ns6:CertRefsType' */
#ifndef SOAP_TYPE_ns6__CertRefsType
#define SOAP_TYPE_ns6__CertRefsType (72)
#endif

/* ns6__CompleteCertificateRefsType has binding name 'ns6__CompleteCertificateRefsType' for type 'ns6:CompleteCertificateRefsType' */
#ifndef SOAP_TYPE_ns6__CompleteCertificateRefsType
#define SOAP_TYPE_ns6__CompleteCertificateRefsType (71)
#endif

/* ns6__SignatureTimeStampType has binding name 'ns6__SignatureTimeStampType' for type 'ns6:SignatureTimeStampType' */
#ifndef SOAP_TYPE_ns6__SignatureTimeStampType
#define SOAP_TYPE_ns6__SignatureTimeStampType (70)
#endif

/* ns6__CounterSignatureType has binding name 'ns6__CounterSignatureType' for type 'ns6:CounterSignatureType' */
#ifndef SOAP_TYPE_ns6__CounterSignatureType
#define SOAP_TYPE_ns6__CounterSignatureType (69)
#endif

/* ns6__UnsignedSignaturePropertiesType has binding name 'ns6__UnsignedSignaturePropertiesType' for type 'ns6:UnsignedSignaturePropertiesType' */
#ifndef SOAP_TYPE_ns6__UnsignedSignaturePropertiesType
#define SOAP_TYPE_ns6__UnsignedSignaturePropertiesType (68)
#endif

/* ns6__UnsignedPropertiesType has binding name 'ns6__UnsignedPropertiesType' for type 'ns6:UnsignedPropertiesType' */
#ifndef SOAP_TYPE_ns6__UnsignedPropertiesType
#define SOAP_TYPE_ns6__UnsignedPropertiesType (67)
#endif

/* ns6__ClaimedRoleType has binding name 'ns6__ClaimedRoleType' for type 'ns6:ClaimedRoleType' */
#ifndef SOAP_TYPE_ns6__ClaimedRoleType
#define SOAP_TYPE_ns6__ClaimedRoleType (66)
#endif

/* ns6__ClaimedRolesListType has binding name 'ns6__ClaimedRolesListType' for type 'ns6:ClaimedRolesListType' */
#ifndef SOAP_TYPE_ns6__ClaimedRolesListType
#define SOAP_TYPE_ns6__ClaimedRolesListType (65)
#endif

/* ns6__SignerRoleType has binding name 'ns6__SignerRoleType' for type 'ns6:SignerRoleType' */
#ifndef SOAP_TYPE_ns6__SignerRoleType
#define SOAP_TYPE_ns6__SignerRoleType (64)
#endif

/* ns6__IssuerSerialType has binding name 'ns6__IssuerSerialType' for type 'ns6:IssuerSerialType' */
#ifndef SOAP_TYPE_ns6__IssuerSerialType
#define SOAP_TYPE_ns6__IssuerSerialType (63)
#endif

/* ns6__CertDigestType has binding name 'ns6__CertDigestType' for type 'ns6:CertDigestType' */
#ifndef SOAP_TYPE_ns6__CertDigestType
#define SOAP_TYPE_ns6__CertDigestType (62)
#endif

/* ns6__CertType has binding name 'ns6__CertType' for type 'ns6:CertType' */
#ifndef SOAP_TYPE_ns6__CertType
#define SOAP_TYPE_ns6__CertType (61)
#endif

/* ns6__SigningCertificateType has binding name 'ns6__SigningCertificateType' for type 'ns6:SigningCertificateType' */
#ifndef SOAP_TYPE_ns6__SigningCertificateType
#define SOAP_TYPE_ns6__SigningCertificateType (60)
#endif

/* ns6__SignedSignaturePropertiesType has binding name 'ns6__SignedSignaturePropertiesType' for type 'ns6:SignedSignaturePropertiesType' */
#ifndef SOAP_TYPE_ns6__SignedSignaturePropertiesType
#define SOAP_TYPE_ns6__SignedSignaturePropertiesType (59)
#endif

/* ns6__SignedPropertiesType has binding name 'ns6__SignedPropertiesType' for type 'ns6:SignedPropertiesType' */
#ifndef SOAP_TYPE_ns6__SignedPropertiesType
#define SOAP_TYPE_ns6__SignedPropertiesType (58)
#endif

/* ns6__QualifyingPropertiesType has binding name 'ns6__QualifyingPropertiesType' for type 'ns6:QualifyingPropertiesType' */
#ifndef SOAP_TYPE_ns6__QualifyingPropertiesType
#define SOAP_TYPE_ns6__QualifyingPropertiesType (57)
#endif

/* ns3__ResponseCodeStatusType has binding name 'ns3__ResponseCodeStatusType' for type 'ns3:ResponseCodeStatusType' */
#ifndef SOAP_TYPE_ns3__ResponseCodeStatusType
#define SOAP_TYPE_ns3__ResponseCodeStatusType (56)
#endif

/* ns3__SubAttributeType has binding name 'ns3__SubAttributeType' for type 'ns3:SubAttributeType' */
#ifndef SOAP_TYPE_ns3__SubAttributeType
#define SOAP_TYPE_ns3__SubAttributeType (55)
#endif

/* ns3__SubAttributeListType has binding name 'ns3__SubAttributeListType' for type 'ns3:SubAttributeListType' */
#ifndef SOAP_TYPE_ns3__SubAttributeListType
#define SOAP_TYPE_ns3__SubAttributeListType (54)
#endif

/* ns3__LegalActListType has binding name 'ns3__LegalActListType' for type 'ns3:LegalActListType' */
#ifndef SOAP_TYPE_ns3__LegalActListType
#define SOAP_TYPE_ns3__LegalActListType (53)
#endif

/* ns3__MainAttributeType has binding name 'ns3__MainAttributeType' for type 'ns3:MainAttributeType' */
#ifndef SOAP_TYPE_ns3__MainAttributeType
#define SOAP_TYPE_ns3__MainAttributeType (52)
#endif

/* ns3__ExtraIDType has binding name 'ns3__ExtraIDType' for type 'ns3:ExtraIDType' */
#ifndef SOAP_TYPE_ns3__ExtraIDType
#define SOAP_TYPE_ns3__ExtraIDType (51)
#endif

/* ns3__ExtraIDListType has binding name 'ns3__ExtraIDListType' for type 'ns3:ExtraIDListType' */
#ifndef SOAP_TYPE_ns3__ExtraIDListType
#define SOAP_TYPE_ns3__ExtraIDListType (50)
#endif

/* ns3__PersonalDataType has binding name 'ns3__PersonalDataType' for type 'ns3:PersonalDataType' */
#ifndef SOAP_TYPE_ns3__PersonalDataType
#define SOAP_TYPE_ns3__PersonalDataType (49)
#endif

/* ns3__AttributeSupplierType has binding name 'ns3__AttributeSupplierType' for type 'ns3:AttributeSupplierType' */
#ifndef SOAP_TYPE_ns3__AttributeSupplierType
#define SOAP_TYPE_ns3__AttributeSupplierType (48)
#endif

/* ns3__AttributeType has binding name 'ns3__AttributeType' for type 'ns3:AttributeType' */
#ifndef SOAP_TYPE_ns3__AttributeType
#define SOAP_TYPE_ns3__AttributeType (47)
#endif

/* ns5__SignatureValueType has binding name 'ns5__SignatureValueType' for type 'ns5:SignatureValueType' */
#ifndef SOAP_TYPE_ns5__SignatureValueType
#define SOAP_TYPE_ns5__SignatureValueType (46)
#endif

/* ns5__DigestValueType has binding name 'ns5__DigestValueType' for type 'ns5:DigestValueType' */
#ifndef SOAP_TYPE_ns5__DigestValueType
#define SOAP_TYPE_ns5__DigestValueType (45)
#endif

/* ns5__X509CertificateType has binding name 'ns5__X509CertificateType' for type 'ns5:X509CertificateType' */
#ifndef SOAP_TYPE_ns5__X509CertificateType
#define SOAP_TYPE_ns5__X509CertificateType (44)
#endif

/* ns5__ObjectType has binding name 'ns5__ObjectType' for type 'ns5:ObjectType' */
#ifndef SOAP_TYPE_ns5__ObjectType
#define SOAP_TYPE_ns5__ObjectType (43)
#endif

/* ns5__X509DataType has binding name 'ns5__X509DataType' for type 'ns5:X509DataType' */
#ifndef SOAP_TYPE_ns5__X509DataType
#define SOAP_TYPE_ns5__X509DataType (42)
#endif

/* ns5__KeyInfoType has binding name 'ns5__KeyInfoType' for type 'ns5:KeyInfoType' */
#ifndef SOAP_TYPE_ns5__KeyInfoType
#define SOAP_TYPE_ns5__KeyInfoType (41)
#endif

/* ns5__DigestMethodType has binding name 'ns5__DigestMethodType' for type 'ns5:DigestMethodType' */
#ifndef SOAP_TYPE_ns5__DigestMethodType
#define SOAP_TYPE_ns5__DigestMethodType (40)
#endif

/* ns5__TransformType has binding name 'ns5__TransformType' for type 'ns5:TransformType' */
#ifndef SOAP_TYPE_ns5__TransformType
#define SOAP_TYPE_ns5__TransformType (39)
#endif

/* ns5__TransformsType has binding name 'ns5__TransformsType' for type 'ns5:TransformsType' */
#ifndef SOAP_TYPE_ns5__TransformsType
#define SOAP_TYPE_ns5__TransformsType (38)
#endif

/* ns5__ReferenceType has binding name 'ns5__ReferenceType' for type 'ns5:ReferenceType' */
#ifndef SOAP_TYPE_ns5__ReferenceType
#define SOAP_TYPE_ns5__ReferenceType (37)
#endif

/* ns5__SignatureMethodType has binding name 'ns5__SignatureMethodType' for type 'ns5:SignatureMethodType' */
#ifndef SOAP_TYPE_ns5__SignatureMethodType
#define SOAP_TYPE_ns5__SignatureMethodType (36)
#endif

/* ns5__CanonicalizationMethodType has binding name 'ns5__CanonicalizationMethodType' for type 'ns5:CanonicalizationMethodType' */
#ifndef SOAP_TYPE_ns5__CanonicalizationMethodType
#define SOAP_TYPE_ns5__CanonicalizationMethodType (35)
#endif

/* ns5__SignedInfoType has binding name 'ns5__SignedInfoType' for type 'ns5:SignedInfoType' */
#ifndef SOAP_TYPE_ns5__SignedInfoType
#define SOAP_TYPE_ns5__SignedInfoType (34)
#endif

/* ns5__SignatureType has binding name 'ns5__SignatureType' for type 'ns5:SignatureType' */
#ifndef SOAP_TYPE_ns5__SignatureType
#define SOAP_TYPE_ns5__SignatureType (33)
#endif

/* ns2__ResponseResult has binding name 'ns2__ResponseResult' for type 'ns2:ResponseResult' */
#ifndef SOAP_TYPE_ns2__ResponseResult
#define SOAP_TYPE_ns2__ResponseResult (32)
#endif

/* ns2__UnsignedAttributesBasicType has binding name 'ns2__UnsignedAttributesBasicType' for type 'ns2:UnsignedAttributesBasicType' */
#ifndef SOAP_TYPE_ns2__UnsignedAttributesBasicType
#define SOAP_TYPE_ns2__UnsignedAttributesBasicType (31)
#endif

/* ns2__SignedAttributesType has binding name 'ns2__SignedAttributesType' for type 'ns2:SignedAttributesType' */
#ifndef SOAP_TYPE_ns2__SignedAttributesType
#define SOAP_TYPE_ns2__SignedAttributesType (30)
#endif

/* ns2__UnsignedAttributesType has binding name 'ns2__UnsignedAttributesType' for type 'ns2:UnsignedAttributesType' */
#ifndef SOAP_TYPE_ns2__UnsignedAttributesType
#define SOAP_TYPE_ns2__UnsignedAttributesType (29)
#endif

/* ns2__AttributesType has binding name 'ns2__AttributesType' for type 'ns2:AttributesType' */
#ifndef SOAP_TYPE_ns2__AttributesType
#define SOAP_TYPE_ns2__AttributesType (28)
#endif

/* ns2__UnsignedAttributeResponseType has binding name 'ns2__UnsignedAttributeResponseType' for type 'ns2:UnsignedAttributeResponseType' */
#ifndef SOAP_TYPE_ns2__UnsignedAttributeResponseType
#define SOAP_TYPE_ns2__UnsignedAttributeResponseType (27)
#endif

/* ns2__SingleAttributeResponseType has binding name 'ns2__SingleAttributeResponseType' for type 'ns2:SingleAttributeResponseType' */
#ifndef SOAP_TYPE_ns2__SingleAttributeResponseType
#define SOAP_TYPE_ns2__SingleAttributeResponseType (26)
#endif

/* ns2__AttributeResponseType has binding name 'ns2__AttributeResponseType' for type 'ns2:AttributeResponseType' */
#ifndef SOAP_TYPE_ns2__AttributeResponseType
#define SOAP_TYPE_ns2__AttributeResponseType (25)
#endif

/* ns2__AttributeSupplierListType has binding name 'ns2__AttributeSupplierListType' for type 'ns2:AttributeSupplierListType' */
#ifndef SOAP_TYPE_ns2__AttributeSupplierListType
#define SOAP_TYPE_ns2__AttributeSupplierListType (24)
#endif

/* ns2__PSAAttributeRequestType has binding name 'ns2__PSAAttributeRequestType' for type 'ns2:PSAAttributeRequestType' */
#ifndef SOAP_TYPE_ns2__PSAAttributeRequestType
#define SOAP_TYPE_ns2__PSAAttributeRequestType (23)
#endif

/* ns2__SingleAttributeRequestType has binding name 'ns2__SingleAttributeRequestType' for type 'ns2:SingleAttributeRequestType' */
#ifndef SOAP_TYPE_ns2__SingleAttributeRequestType
#define SOAP_TYPE_ns2__SingleAttributeRequestType (22)
#endif

/* ns2__AttributeRequestType has binding name 'ns2__AttributeRequestType' for type 'ns2:AttributeRequestType' */
#ifndef SOAP_TYPE_ns2__AttributeRequestType
#define SOAP_TYPE_ns2__AttributeRequestType (21)
#endif

/* xsd__integer has binding name 'xsd__integer' for type 'xsd:integer' */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (20)
#endif

/* xsd__date has binding name 'xsd__date' for type 'xsd:date' */
#ifndef SOAP_TYPE_xsd__date
#define SOAP_TYPE_xsd__date (19)
#endif

/* xsd__anyURI has binding name 'xsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (18)
#endif

/* xsd__ID has binding name 'xsd__ID' for type 'xsd:ID' */
#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (17)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (16)
#endif

/* xsd__base64Binary has binding name 'xsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (11)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (343)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (339)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (337)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (335)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (330)
#endif

/* _wsa__FaultTo has binding name '_wsa__FaultTo' for type '' */
#ifndef SOAP_TYPE__wsa__FaultTo
#define SOAP_TYPE__wsa__FaultTo (328)
#endif

/* _wsa__ReplyTo has binding name '_wsa__ReplyTo' for type '' */
#ifndef SOAP_TYPE__wsa__ReplyTo
#define SOAP_TYPE__wsa__ReplyTo (327)
#endif

/* _wsa__From has binding name '_wsa__From' for type '' */
#ifndef SOAP_TYPE__wsa__From
#define SOAP_TYPE__wsa__From (326)
#endif

/* _wsa__RelatesTo has binding name '_wsa__RelatesTo' for type '' */
#ifndef SOAP_TYPE__wsa__RelatesTo
#define SOAP_TYPE__wsa__RelatesTo (323)
#endif

/* _wsa__EndpointReference has binding name '_wsa__EndpointReference' for type '' */
#ifndef SOAP_TYPE__wsa__EndpointReference
#define SOAP_TYPE__wsa__EndpointReference (321)
#endif

/* struct wsa__Relationship has binding name 'wsa__Relationship' for type 'wsa:Relationship' */
#ifndef SOAP_TYPE_wsa__Relationship
#define SOAP_TYPE_wsa__Relationship (313)
#endif

/* struct wsa__ServiceNameType has binding name 'wsa__ServiceNameType' for type 'wsa:ServiceNameType' */
#ifndef SOAP_TYPE_wsa__ServiceNameType
#define SOAP_TYPE_wsa__ServiceNameType (312)
#endif

/* struct wsa__ReferenceParametersType has binding name 'wsa__ReferenceParametersType' for type 'wsa:ReferenceParametersType' */
#ifndef SOAP_TYPE_wsa__ReferenceParametersType
#define SOAP_TYPE_wsa__ReferenceParametersType (311)
#endif

/* struct wsa__ReferencePropertiesType has binding name 'wsa__ReferencePropertiesType' for type 'wsa:ReferencePropertiesType' */
#ifndef SOAP_TYPE_wsa__ReferencePropertiesType
#define SOAP_TYPE_wsa__ReferencePropertiesType (310)
#endif

/* struct wsa__EndpointReferenceType has binding name 'wsa__EndpointReferenceType' for type 'wsa:EndpointReferenceType' */
#ifndef SOAP_TYPE_wsa__EndpointReferenceType
#define SOAP_TYPE_wsa__EndpointReferenceType (309)
#endif

/* _ns1__SignatureRequest * has binding name 'PointerTo_ns1__SignatureRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SignatureRequest
#define SOAP_TYPE_PointerTo_ns1__SignatureRequest (352)
#endif

/* _ns1__AuthorizationRequest * has binding name 'PointerTo_ns1__AuthorizationRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__AuthorizationRequest
#define SOAP_TYPE_PointerTo_ns1__AuthorizationRequest (348)
#endif

/* ns2__AttributeRequestType * has binding name 'PointerTons2__AttributeRequestType' for type 'ns2:AttributeRequestType' */
#ifndef SOAP_TYPE_PointerTons2__AttributeRequestType
#define SOAP_TYPE_PointerTons2__AttributeRequestType (344)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (340)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (338)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (336)
#endif

/* struct wsa__EndpointReferenceType * has binding name 'PointerTo_wsa__FaultTo' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa__FaultTo
#define SOAP_TYPE_PointerTo_wsa__FaultTo (334)
#endif

/* struct wsa__EndpointReferenceType * has binding name 'PointerTo_wsa__ReplyTo' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa__ReplyTo
#define SOAP_TYPE_PointerTo_wsa__ReplyTo (333)
#endif

/* struct wsa__EndpointReferenceType * has binding name 'PointerTo_wsa__From' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa__From
#define SOAP_TYPE_PointerTo_wsa__From (332)
#endif

/* struct wsa__Relationship * has binding name 'PointerTo_wsa__RelatesTo' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa__RelatesTo
#define SOAP_TYPE_PointerTo_wsa__RelatesTo (331)
#endif

/* _wsa__Action has binding name '_wsa__Action' for type '' */
#ifndef SOAP_TYPE__wsa__Action
#define SOAP_TYPE__wsa__Action (325)
#endif

/* _wsa__To has binding name '_wsa__To' for type '' */
#ifndef SOAP_TYPE__wsa__To
#define SOAP_TYPE__wsa__To (324)
#endif

/* _wsa__MessageID has binding name '_wsa__MessageID' for type '' */
#ifndef SOAP_TYPE__wsa__MessageID
#define SOAP_TYPE__wsa__MessageID (322)
#endif

/* char ** has binding name 'PointerTo_XML' for type '' */
#ifndef SOAP_TYPE_PointerTo_XML
#define SOAP_TYPE_PointerTo_XML (320)
#endif

/* struct wsa__ServiceNameType * has binding name 'PointerTowsa__ServiceNameType' for type 'wsa:ServiceNameType' */
#ifndef SOAP_TYPE_PointerTowsa__ServiceNameType
#define SOAP_TYPE_PointerTowsa__ServiceNameType (319)
#endif

/* char ** has binding name 'PointerTo_QName' for type '' */
#ifndef SOAP_TYPE_PointerTo_QName
#define SOAP_TYPE_PointerTo_QName (318)
#endif

/* struct wsa__ReferenceParametersType * has binding name 'PointerTowsa__ReferenceParametersType' for type 'wsa:ReferenceParametersType' */
#ifndef SOAP_TYPE_PointerTowsa__ReferenceParametersType
#define SOAP_TYPE_PointerTowsa__ReferenceParametersType (317)
#endif

/* struct wsa__ReferencePropertiesType * has binding name 'PointerTowsa__ReferencePropertiesType' for type 'wsa:ReferencePropertiesType' */
#ifndef SOAP_TYPE_PointerTowsa__ReferencePropertiesType
#define SOAP_TYPE_PointerTowsa__ReferencePropertiesType (316)
#endif

/* std::string * has binding name 'PointerToxsd__ID' for type 'xsd:ID' */
#ifndef SOAP_TYPE_PointerToxsd__ID
#define SOAP_TYPE_PointerToxsd__ID (247)
#endif

/* xsd__base64Binary * has binding name 'PointerToxsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_PointerToxsd__base64Binary
#define SOAP_TYPE_PointerToxsd__base64Binary (246)
#endif

/* ns1__TransactionTypeList * has binding name 'PointerTons1__TransactionTypeList' for type 'ns1:TransactionTypeList' */
#ifndef SOAP_TYPE_PointerTons1__TransactionTypeList
#define SOAP_TYPE_PointerTons1__TransactionTypeList (245)
#endif

/* ns1__Status * has binding name 'PointerTons1__Status' for type 'ns1:Status' */
#ifndef SOAP_TYPE_PointerTons1__Status
#define SOAP_TYPE_PointerTons1__Status (244)
#endif

/* ns1__AttributeListType * has binding name 'PointerTons1__AttributeListType' for type 'ns1:AttributeListType' */
#ifndef SOAP_TYPE_PointerTons1__AttributeListType
#define SOAP_TYPE_PointerTons1__AttributeListType (243)
#endif

/* ns1__PersonalData * has binding name 'PointerTons1__PersonalData' for type 'ns1:PersonalData' */
#ifndef SOAP_TYPE_PointerTons1__PersonalData
#define SOAP_TYPE_PointerTons1__PersonalData (242)
#endif

/* ns1__TransactionType * has binding name 'PointerTons1__TransactionType' for type 'ns1:TransactionType' */
#ifndef SOAP_TYPE_PointerTons1__TransactionType
#define SOAP_TYPE_PointerTons1__TransactionType (240)
#endif

/* ns1__SubAttributeType * has binding name 'PointerTons1__SubAttributeType' for type 'ns1:SubAttributeType' */
#ifndef SOAP_TYPE_PointerTons1__SubAttributeType
#define SOAP_TYPE_PointerTons1__SubAttributeType (238)
#endif

/* ns1__SubAttributeListType * has binding name 'PointerTons1__SubAttributeListType' for type 'ns1:SubAttributeListType' */
#ifndef SOAP_TYPE_PointerTons1__SubAttributeListType
#define SOAP_TYPE_PointerTons1__SubAttributeListType (236)
#endif

/* ns1__LegalActListType * has binding name 'PointerTons1__LegalActListType' for type 'ns1:LegalActListType' */
#ifndef SOAP_TYPE_PointerTons1__LegalActListType
#define SOAP_TYPE_PointerTons1__LegalActListType (235)
#endif

/* ns1__MainAttributeType * has binding name 'PointerTons1__MainAttributeType' for type 'ns1:MainAttributeType' */
#ifndef SOAP_TYPE_PointerTons1__MainAttributeType
#define SOAP_TYPE_PointerTons1__MainAttributeType (234)
#endif

/* ns1__AttributeSupplierType * has binding name 'PointerTons1__AttributeSupplierType' for type 'ns1:AttributeSupplierType' */
#ifndef SOAP_TYPE_PointerTons1__AttributeSupplierType
#define SOAP_TYPE_PointerTons1__AttributeSupplierType (233)
#endif

/* ns1__AttributeType * has binding name 'PointerTons1__AttributeType' for type 'ns1:AttributeType' */
#ifndef SOAP_TYPE_PointerTons1__AttributeType
#define SOAP_TYPE_PointerTons1__AttributeType (231)
#endif

/* ns6__EncapsulatedOCSPValueType * has binding name 'PointerTons6__EncapsulatedOCSPValueType' for type 'ns6:EncapsulatedOCSPValueType' */
#ifndef SOAP_TYPE_PointerTons6__EncapsulatedOCSPValueType
#define SOAP_TYPE_PointerTons6__EncapsulatedOCSPValueType (228)
#endif

/* ns6__EncapsulatedCRLValueType * has binding name 'PointerTons6__EncapsulatedCRLValueType' for type 'ns6:EncapsulatedCRLValueType' */
#ifndef SOAP_TYPE_PointerTons6__EncapsulatedCRLValueType
#define SOAP_TYPE_PointerTons6__EncapsulatedCRLValueType (226)
#endif

/* ns6__OCSPValuesType * has binding name 'PointerTons6__OCSPValuesType' for type 'ns6:OCSPValuesType' */
#ifndef SOAP_TYPE_PointerTons6__OCSPValuesType
#define SOAP_TYPE_PointerTons6__OCSPValuesType (225)
#endif

/* ns6__CRLValuesType * has binding name 'PointerTons6__CRLValuesType' for type 'ns6:CRLValuesType' */
#ifndef SOAP_TYPE_PointerTons6__CRLValuesType
#define SOAP_TYPE_PointerTons6__CRLValuesType (224)
#endif

/* ns6__EncapsulatedX509CertificateType * has binding name 'PointerTons6__EncapsulatedX509CertificateType' for type 'ns6:EncapsulatedX509CertificateType' */
#ifndef SOAP_TYPE_PointerTons6__EncapsulatedX509CertificateType
#define SOAP_TYPE_PointerTons6__EncapsulatedX509CertificateType (222)
#endif

/* ns6__ResponderIDType * has binding name 'PointerTons6__ResponderIDType' for type 'ns6:ResponderIDType' */
#ifndef SOAP_TYPE_PointerTons6__ResponderIDType
#define SOAP_TYPE_PointerTons6__ResponderIDType (221)
#endif

/* ns6__OCSPIdentifierType * has binding name 'PointerTons6__OCSPIdentifierType' for type 'ns6:OCSPIdentifierType' */
#ifndef SOAP_TYPE_PointerTons6__OCSPIdentifierType
#define SOAP_TYPE_PointerTons6__OCSPIdentifierType (220)
#endif

/* ns6__OCSPRefType * has binding name 'PointerTons6__OCSPRefType' for type 'ns6:OCSPRefType' */
#ifndef SOAP_TYPE_PointerTons6__OCSPRefType
#define SOAP_TYPE_PointerTons6__OCSPRefType (218)
#endif

/* ns6__CRLIdentifierType * has binding name 'PointerTons6__CRLIdentifierType' for type 'ns6:CRLIdentifierType' */
#ifndef SOAP_TYPE_PointerTons6__CRLIdentifierType
#define SOAP_TYPE_PointerTons6__CRLIdentifierType (217)
#endif

/* ns6__DigestAlgAndValueType * has binding name 'PointerTons6__DigestAlgAndValueType' for type 'ns6:DigestAlgAndValueType' */
#ifndef SOAP_TYPE_PointerTons6__DigestAlgAndValueType
#define SOAP_TYPE_PointerTons6__DigestAlgAndValueType (216)
#endif

/* ns6__CRLRefType * has binding name 'PointerTons6__CRLRefType' for type 'ns6:CRLRefType' */
#ifndef SOAP_TYPE_PointerTons6__CRLRefType
#define SOAP_TYPE_PointerTons6__CRLRefType (214)
#endif

/* ns6__OCSPRefsType * has binding name 'PointerTons6__OCSPRefsType' for type 'ns6:OCSPRefsType' */
#ifndef SOAP_TYPE_PointerTons6__OCSPRefsType
#define SOAP_TYPE_PointerTons6__OCSPRefsType (213)
#endif

/* ns6__CRLRefsType * has binding name 'PointerTons6__CRLRefsType' for type 'ns6:CRLRefsType' */
#ifndef SOAP_TYPE_PointerTons6__CRLRefsType
#define SOAP_TYPE_PointerTons6__CRLRefsType (212)
#endif

/* ns6__CertRefsType * has binding name 'PointerTons6__CertRefsType' for type 'ns6:CertRefsType' */
#ifndef SOAP_TYPE_PointerTons6__CertRefsType
#define SOAP_TYPE_PointerTons6__CertRefsType (210)
#endif

/* ns6__ArchiveTimeStampType * has binding name 'PointerTons6__ArchiveTimeStampType' for type 'ns6:ArchiveTimeStampType' */
#ifndef SOAP_TYPE_PointerTons6__ArchiveTimeStampType
#define SOAP_TYPE_PointerTons6__ArchiveTimeStampType (209)
#endif

/* ns6__RevocationValuesType * has binding name 'PointerTons6__RevocationValuesType' for type 'ns6:RevocationValuesType' */
#ifndef SOAP_TYPE_PointerTons6__RevocationValuesType
#define SOAP_TYPE_PointerTons6__RevocationValuesType (208)
#endif

/* ns6__CertificateValuesType * has binding name 'PointerTons6__CertificateValuesType' for type 'ns6:CertificateValuesType' */
#ifndef SOAP_TYPE_PointerTons6__CertificateValuesType
#define SOAP_TYPE_PointerTons6__CertificateValuesType (207)
#endif

/* ns6__SigAndRefsTimeStampType * has binding name 'PointerTons6__SigAndRefsTimeStampType' for type 'ns6:SigAndRefsTimeStampType' */
#ifndef SOAP_TYPE_PointerTons6__SigAndRefsTimeStampType
#define SOAP_TYPE_PointerTons6__SigAndRefsTimeStampType (206)
#endif

/* ns6__CompleteRevocationRefsType * has binding name 'PointerTons6__CompleteRevocationRefsType' for type 'ns6:CompleteRevocationRefsType' */
#ifndef SOAP_TYPE_PointerTons6__CompleteRevocationRefsType
#define SOAP_TYPE_PointerTons6__CompleteRevocationRefsType (205)
#endif

/* ns6__CompleteCertificateRefsType * has binding name 'PointerTons6__CompleteCertificateRefsType' for type 'ns6:CompleteCertificateRefsType' */
#ifndef SOAP_TYPE_PointerTons6__CompleteCertificateRefsType
#define SOAP_TYPE_PointerTons6__CompleteCertificateRefsType (204)
#endif

/* ns6__SignatureTimeStampType * has binding name 'PointerTons6__SignatureTimeStampType' for type 'ns6:SignatureTimeStampType' */
#ifndef SOAP_TYPE_PointerTons6__SignatureTimeStampType
#define SOAP_TYPE_PointerTons6__SignatureTimeStampType (203)
#endif

/* ns6__CounterSignatureType * has binding name 'PointerTons6__CounterSignatureType' for type 'ns6:CounterSignatureType' */
#ifndef SOAP_TYPE_PointerTons6__CounterSignatureType
#define SOAP_TYPE_PointerTons6__CounterSignatureType (202)
#endif

/* ns6__UnsignedSignaturePropertiesType * has binding name 'PointerTons6__UnsignedSignaturePropertiesType' for type 'ns6:UnsignedSignaturePropertiesType' */
#ifndef SOAP_TYPE_PointerTons6__UnsignedSignaturePropertiesType
#define SOAP_TYPE_PointerTons6__UnsignedSignaturePropertiesType (201)
#endif

/* ns6__ClaimedRoleType * has binding name 'PointerTons6__ClaimedRoleType' for type 'ns6:ClaimedRoleType' */
#ifndef SOAP_TYPE_PointerTons6__ClaimedRoleType
#define SOAP_TYPE_PointerTons6__ClaimedRoleType (199)
#endif

/* ns6__ClaimedRolesListType * has binding name 'PointerTons6__ClaimedRolesListType' for type 'ns6:ClaimedRolesListType' */
#ifndef SOAP_TYPE_PointerTons6__ClaimedRolesListType
#define SOAP_TYPE_PointerTons6__ClaimedRolesListType (198)
#endif

/* ns6__IssuerSerialType * has binding name 'PointerTons6__IssuerSerialType' for type 'ns6:IssuerSerialType' */
#ifndef SOAP_TYPE_PointerTons6__IssuerSerialType
#define SOAP_TYPE_PointerTons6__IssuerSerialType (197)
#endif

/* ns6__CertDigestType * has binding name 'PointerTons6__CertDigestType' for type 'ns6:CertDigestType' */
#ifndef SOAP_TYPE_PointerTons6__CertDigestType
#define SOAP_TYPE_PointerTons6__CertDigestType (196)
#endif

/* ns6__CertType * has binding name 'PointerTons6__CertType' for type 'ns6:CertType' */
#ifndef SOAP_TYPE_PointerTons6__CertType
#define SOAP_TYPE_PointerTons6__CertType (195)
#endif

/* ns6__SignerRoleType * has binding name 'PointerTons6__SignerRoleType' for type 'ns6:SignerRoleType' */
#ifndef SOAP_TYPE_PointerTons6__SignerRoleType
#define SOAP_TYPE_PointerTons6__SignerRoleType (194)
#endif

/* ns6__SigningCertificateType * has binding name 'PointerTons6__SigningCertificateType' for type 'ns6:SigningCertificateType' */
#ifndef SOAP_TYPE_PointerTons6__SigningCertificateType
#define SOAP_TYPE_PointerTons6__SigningCertificateType (193)
#endif

/* ns6__SignedSignaturePropertiesType * has binding name 'PointerTons6__SignedSignaturePropertiesType' for type 'ns6:SignedSignaturePropertiesType' */
#ifndef SOAP_TYPE_PointerTons6__SignedSignaturePropertiesType
#define SOAP_TYPE_PointerTons6__SignedSignaturePropertiesType (192)
#endif

/* ns6__UnsignedPropertiesType * has binding name 'PointerTons6__UnsignedPropertiesType' for type 'ns6:UnsignedPropertiesType' */
#ifndef SOAP_TYPE_PointerTons6__UnsignedPropertiesType
#define SOAP_TYPE_PointerTons6__UnsignedPropertiesType (191)
#endif

/* ns6__SignedPropertiesType * has binding name 'PointerTons6__SignedPropertiesType' for type 'ns6:SignedPropertiesType' */
#ifndef SOAP_TYPE_PointerTons6__SignedPropertiesType
#define SOAP_TYPE_PointerTons6__SignedPropertiesType (190)
#endif

/* std::string * has binding name 'PointerTons4__ResponseCodeMessage' for type 'ns4:ResponseCodeMessage' */
#ifndef SOAP_TYPE_PointerTons4__ResponseCodeMessage
#define SOAP_TYPE_PointerTons4__ResponseCodeMessage (189)
#endif

/* std::string * has binding name 'PointerTons4__SubAttributeValueType' for type 'ns4:SubAttributeValueType' */
#ifndef SOAP_TYPE_PointerTons4__SubAttributeValueType
#define SOAP_TYPE_PointerTons4__SubAttributeValueType (188)
#endif

/* ns3__SubAttributeType * has binding name 'PointerTons3__SubAttributeType' for type 'ns3:SubAttributeType' */
#ifndef SOAP_TYPE_PointerTons3__SubAttributeType
#define SOAP_TYPE_PointerTons3__SubAttributeType (186)
#endif

/* ns3__SubAttributeListType * has binding name 'PointerTons3__SubAttributeListType' for type 'ns3:SubAttributeListType' */
#ifndef SOAP_TYPE_PointerTons3__SubAttributeListType
#define SOAP_TYPE_PointerTons3__SubAttributeListType (184)
#endif

/* ns3__LegalActListType * has binding name 'PointerTons3__LegalActListType' for type 'ns3:LegalActListType' */
#ifndef SOAP_TYPE_PointerTons3__LegalActListType
#define SOAP_TYPE_PointerTons3__LegalActListType (183)
#endif

/* std::string * has binding name 'PointerTons4__DescriptionType' for type 'ns4:DescriptionType' */
#ifndef SOAP_TYPE_PointerTons4__DescriptionType
#define SOAP_TYPE_PointerTons4__DescriptionType (182)
#endif

/* ns3__ExtraIDType * has binding name 'PointerTons3__ExtraIDType' for type 'ns3:ExtraIDType' */
#ifndef SOAP_TYPE_PointerTons3__ExtraIDType
#define SOAP_TYPE_PointerTons3__ExtraIDType (180)
#endif

/* ns3__ExtraIDListType * has binding name 'PointerTons3__ExtraIDListType' for type 'ns3:ExtraIDListType' */
#ifndef SOAP_TYPE_PointerTons3__ExtraIDListType
#define SOAP_TYPE_PointerTons3__ExtraIDListType (179)
#endif

/* ns3__MainAttributeType * has binding name 'PointerTons3__MainAttributeType' for type 'ns3:MainAttributeType' */
#ifndef SOAP_TYPE_PointerTons3__MainAttributeType
#define SOAP_TYPE_PointerTons3__MainAttributeType (178)
#endif

/* ns7__SVGListType * has binding name 'PointerTons7__SVGListType' for type 'ns7:SVGListType' */
#ifndef SOAP_TYPE_PointerTons7__SVGListType
#define SOAP_TYPE_PointerTons7__SVGListType (176)
#endif

/* ns6__QualifyingPropertiesType * has binding name 'PointerTons6__QualifyingPropertiesType' for type 'ns6:QualifyingPropertiesType' */
#ifndef SOAP_TYPE_PointerTons6__QualifyingPropertiesType
#define SOAP_TYPE_PointerTons6__QualifyingPropertiesType (175)
#endif

/* ns5__X509CertificateType * has binding name 'PointerTons5__X509CertificateType' for type 'ns5:X509CertificateType' */
#ifndef SOAP_TYPE_PointerTons5__X509CertificateType
#define SOAP_TYPE_PointerTons5__X509CertificateType (173)
#endif

/* ns5__X509DataType * has binding name 'PointerTons5__X509DataType' for type 'ns5:X509DataType' */
#ifndef SOAP_TYPE_PointerTons5__X509DataType
#define SOAP_TYPE_PointerTons5__X509DataType (172)
#endif

/* ns5__TransformType * has binding name 'PointerTons5__TransformType' for type 'ns5:TransformType' */
#ifndef SOAP_TYPE_PointerTons5__TransformType
#define SOAP_TYPE_PointerTons5__TransformType (170)
#endif

/* std::string * has binding name 'PointerToxsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_PointerToxsd__anyURI
#define SOAP_TYPE_PointerToxsd__anyURI (169)
#endif

/* ns5__DigestValueType * has binding name 'PointerTons5__DigestValueType' for type 'ns5:DigestValueType' */
#ifndef SOAP_TYPE_PointerTons5__DigestValueType
#define SOAP_TYPE_PointerTons5__DigestValueType (168)
#endif

/* ns5__DigestMethodType * has binding name 'PointerTons5__DigestMethodType' for type 'ns5:DigestMethodType' */
#ifndef SOAP_TYPE_PointerTons5__DigestMethodType
#define SOAP_TYPE_PointerTons5__DigestMethodType (167)
#endif

/* ns5__TransformsType * has binding name 'PointerTons5__TransformsType' for type 'ns5:TransformsType' */
#ifndef SOAP_TYPE_PointerTons5__TransformsType
#define SOAP_TYPE_PointerTons5__TransformsType (166)
#endif

/* ns5__ReferenceType * has binding name 'PointerTons5__ReferenceType' for type 'ns5:ReferenceType' */
#ifndef SOAP_TYPE_PointerTons5__ReferenceType
#define SOAP_TYPE_PointerTons5__ReferenceType (164)
#endif

/* ns5__SignatureMethodType * has binding name 'PointerTons5__SignatureMethodType' for type 'ns5:SignatureMethodType' */
#ifndef SOAP_TYPE_PointerTons5__SignatureMethodType
#define SOAP_TYPE_PointerTons5__SignatureMethodType (163)
#endif

/* ns5__CanonicalizationMethodType * has binding name 'PointerTons5__CanonicalizationMethodType' for type 'ns5:CanonicalizationMethodType' */
#ifndef SOAP_TYPE_PointerTons5__CanonicalizationMethodType
#define SOAP_TYPE_PointerTons5__CanonicalizationMethodType (162)
#endif

/* ns5__ObjectType * has binding name 'PointerTons5__ObjectType' for type 'ns5:ObjectType' */
#ifndef SOAP_TYPE_PointerTons5__ObjectType
#define SOAP_TYPE_PointerTons5__ObjectType (160)
#endif

/* ns5__KeyInfoType * has binding name 'PointerTons5__KeyInfoType' for type 'ns5:KeyInfoType' */
#ifndef SOAP_TYPE_PointerTons5__KeyInfoType
#define SOAP_TYPE_PointerTons5__KeyInfoType (159)
#endif

/* ns5__SignatureValueType * has binding name 'PointerTons5__SignatureValueType' for type 'ns5:SignatureValueType' */
#ifndef SOAP_TYPE_PointerTons5__SignatureValueType
#define SOAP_TYPE_PointerTons5__SignatureValueType (158)
#endif

/* ns5__SignedInfoType * has binding name 'PointerTons5__SignedInfoType' for type 'ns5:SignedInfoType' */
#ifndef SOAP_TYPE_PointerTons5__SignedInfoType
#define SOAP_TYPE_PointerTons5__SignedInfoType (157)
#endif

/* ns3__AttributeType * has binding name 'PointerTons3__AttributeType' for type 'ns3:AttributeType' */
#ifndef SOAP_TYPE_PointerTons3__AttributeType
#define SOAP_TYPE_PointerTons3__AttributeType (155)
#endif

/* ns5__SignatureType * has binding name 'PointerTons5__SignatureType' for type 'ns5:SignatureType' */
#ifndef SOAP_TYPE_PointerTons5__SignatureType
#define SOAP_TYPE_PointerTons5__SignatureType (153)
#endif

/* ns2__UnsignedAttributesBasicType * has binding name 'PointerTons2__UnsignedAttributesBasicType' for type 'ns2:UnsignedAttributesBasicType' */
#ifndef SOAP_TYPE_PointerTons2__UnsignedAttributesBasicType
#define SOAP_TYPE_PointerTons2__UnsignedAttributesBasicType (152)
#endif

/* ns2__SignedAttributesType * has binding name 'PointerTons2__SignedAttributesType' for type 'ns2:SignedAttributesType' */
#ifndef SOAP_TYPE_PointerTons2__SignedAttributesType
#define SOAP_TYPE_PointerTons2__SignedAttributesType (151)
#endif

/* ns2__ResponseResult * has binding name 'PointerTons2__ResponseResult' for type 'ns2:ResponseResult' */
#ifndef SOAP_TYPE_PointerTons2__ResponseResult
#define SOAP_TYPE_PointerTons2__ResponseResult (150)
#endif

/* ns2__UnsignedAttributesType * has binding name 'PointerTons2__UnsignedAttributesType' for type 'ns2:UnsignedAttributesType' */
#ifndef SOAP_TYPE_PointerTons2__UnsignedAttributesType
#define SOAP_TYPE_PointerTons2__UnsignedAttributesType (149)
#endif

/* ns2__AttributesType * has binding name 'PointerTons2__AttributesType' for type 'ns2:AttributesType' */
#ifndef SOAP_TYPE_PointerTons2__AttributesType
#define SOAP_TYPE_PointerTons2__AttributesType (147)
#endif

/* std::string * has binding name 'PointerTons4__CompanyNameType' for type 'ns4:CompanyNameType' */
#ifndef SOAP_TYPE_PointerTons4__CompanyNameType
#define SOAP_TYPE_PointerTons4__CompanyNameType (145)
#endif

/* std::string * has binding name 'PointerTons4__NIPCType' for type 'ns4:NIPCType' */
#ifndef SOAP_TYPE_PointerTons4__NIPCType
#define SOAP_TYPE_PointerTons4__NIPCType (144)
#endif

/* ns3__AttributeSupplierType * has binding name 'PointerTons3__AttributeSupplierType' for type 'ns3:AttributeSupplierType' */
#ifndef SOAP_TYPE_PointerTons3__AttributeSupplierType
#define SOAP_TYPE_PointerTons3__AttributeSupplierType (143)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (142)
#endif

/* bool * has binding name 'PointerTobool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_PointerTobool
#define SOAP_TYPE_PointerTobool (141)
#endif

/* ns2__AttributeSupplierListType * has binding name 'PointerTons2__AttributeSupplierListType' for type 'ns2:AttributeSupplierListType' */
#ifndef SOAP_TYPE_PointerTons2__AttributeSupplierListType
#define SOAP_TYPE_PointerTons2__AttributeSupplierListType (139)
#endif

/* ns3__PersonalDataType * has binding name 'PointerTons3__PersonalDataType' for type 'ns3:PersonalDataType' */
#ifndef SOAP_TYPE_PointerTons3__PersonalDataType
#define SOAP_TYPE_PointerTons3__PersonalDataType (138)
#endif

/* _ns6__ProducedAt has binding name '_ns6__ProducedAt' for type '' */
#ifndef SOAP_TYPE__ns6__ProducedAt
#define SOAP_TYPE__ns6__ProducedAt (95)
#endif

/* _ns6__ByName has binding name '_ns6__ByName' for type '' */
#ifndef SOAP_TYPE__ns6__ByName
#define SOAP_TYPE__ns6__ByName (94)
#endif

/* _ns6__Number has binding name '_ns6__Number' for type '' */
#ifndef SOAP_TYPE__ns6__Number
#define SOAP_TYPE__ns6__Number (93)
#endif

/* _ns6__IssueTime has binding name '_ns6__IssueTime' for type '' */
#ifndef SOAP_TYPE__ns6__IssueTime
#define SOAP_TYPE__ns6__IssueTime (92)
#endif

/* _ns6__Issuer has binding name '_ns6__Issuer' for type '' */
#ifndef SOAP_TYPE__ns6__Issuer
#define SOAP_TYPE__ns6__Issuer (91)
#endif

/* unsigned char * has binding name 'PointerTounsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_PointerTounsignedByte
#define SOAP_TYPE_PointerTounsignedByte (14)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<ns1__TransactionType *>  has binding name 'std__vectorTemplateOfPointerTons1__TransactionType' for type 'ns1:TransactionType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__TransactionType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__TransactionType (241)
#endif

/* std::vector<ns1__SubAttributeType *>  has binding name 'std__vectorTemplateOfPointerTons1__SubAttributeType' for type 'ns1:SubAttributeType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubAttributeType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubAttributeType (239)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfstd__string
#define SOAP_TYPE_std__vectorTemplateOfstd__string (237)
#endif

/* std::vector<ns1__AttributeType *>  has binding name 'std__vectorTemplateOfPointerTons1__AttributeType' for type 'ns1:AttributeType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__AttributeType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__AttributeType (232)
#endif

/* std::vector<xsd__base64Binary>  has binding name 'std__vectorTemplateOfns7__SVGType' for type 'ns7:SVGType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns7__SVGType
#define SOAP_TYPE_std__vectorTemplateOfns7__SVGType (230)
#endif

/* std::vector<ns6__EncapsulatedOCSPValueType *>  has binding name 'std__vectorTemplateOfPointerTons6__EncapsulatedOCSPValueType' for type 'ns6:EncapsulatedOCSPValueType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons6__EncapsulatedOCSPValueType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons6__EncapsulatedOCSPValueType (229)
#endif

/* std::vector<ns6__EncapsulatedCRLValueType *>  has binding name 'std__vectorTemplateOfPointerTons6__EncapsulatedCRLValueType' for type 'ns6:EncapsulatedCRLValueType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons6__EncapsulatedCRLValueType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons6__EncapsulatedCRLValueType (227)
#endif

/* std::vector<ns6__EncapsulatedX509CertificateType *>  has binding name 'std__vectorTemplateOfPointerTons6__EncapsulatedX509CertificateType' for type 'ns6:EncapsulatedX509CertificateType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons6__EncapsulatedX509CertificateType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons6__EncapsulatedX509CertificateType (223)
#endif

/* std::vector<ns6__OCSPRefType *>  has binding name 'std__vectorTemplateOfPointerTons6__OCSPRefType' for type 'ns6:OCSPRefType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons6__OCSPRefType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons6__OCSPRefType (219)
#endif

/* std::vector<ns6__CRLRefType *>  has binding name 'std__vectorTemplateOfPointerTons6__CRLRefType' for type 'ns6:CRLRefType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons6__CRLRefType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons6__CRLRefType (215)
#endif

/* std::vector<ns6__CertType *>  has binding name 'std__vectorTemplateOfPointerTons6__CertType' for type 'ns6:CertType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons6__CertType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons6__CertType (211)
#endif

/* std::vector<ns6__ClaimedRoleType *>  has binding name 'std__vectorTemplateOfPointerTons6__ClaimedRoleType' for type 'ns6:ClaimedRoleType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons6__ClaimedRoleType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons6__ClaimedRoleType (200)
#endif

/* std::vector<ns3__SubAttributeType *>  has binding name 'std__vectorTemplateOfPointerTons3__SubAttributeType' for type 'ns3:SubAttributeType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__SubAttributeType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__SubAttributeType (187)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfns4__LegalActType' for type 'ns4:LegalActType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns4__LegalActType
#define SOAP_TYPE_std__vectorTemplateOfns4__LegalActType (185)
#endif

/* std::vector<ns3__ExtraIDType *>  has binding name 'std__vectorTemplateOfPointerTons3__ExtraIDType' for type 'ns3:ExtraIDType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__ExtraIDType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__ExtraIDType (181)
#endif

/* std::vector<ns5__X509CertificateType *>  has binding name 'std__vectorTemplateOfPointerTons5__X509CertificateType' for type 'ns5:X509CertificateType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons5__X509CertificateType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons5__X509CertificateType (174)
#endif

/* std::vector<ns5__TransformType *>  has binding name 'std__vectorTemplateOfPointerTons5__TransformType' for type 'ns5:TransformType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons5__TransformType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons5__TransformType (171)
#endif

/* std::vector<ns5__ReferenceType *>  has binding name 'std__vectorTemplateOfPointerTons5__ReferenceType' for type 'ns5:ReferenceType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons5__ReferenceType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons5__ReferenceType (165)
#endif

/* std::vector<ns5__ObjectType *>  has binding name 'std__vectorTemplateOfPointerTons5__ObjectType' for type 'ns5:ObjectType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons5__ObjectType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons5__ObjectType (161)
#endif

/* std::vector<ns3__AttributeType *>  has binding name 'std__vectorTemplateOfPointerTons3__AttributeType' for type 'ns3:AttributeType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__AttributeType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__AttributeType (156)
#endif

/* std::vector<ns5__SignatureType *>  has binding name 'std__vectorTemplateOfPointerTons5__SignatureType' for type 'ns5:SignatureType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons5__SignatureType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons5__SignatureType (154)
#endif

/* std::vector<ns2__AttributesType *>  has binding name 'std__vectorTemplateOfPointerTons2__AttributesType' for type 'ns2:AttributesType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__AttributesType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__AttributesType (148)
#endif

/* std::vector<ns3__AttributeSupplierType *>  has binding name 'std__vectorTemplateOfPointerTons3__AttributeSupplierType' for type 'ns3:AttributeSupplierType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons3__AttributeSupplierType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons3__AttributeSupplierType (146)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of SCAPStub.h */

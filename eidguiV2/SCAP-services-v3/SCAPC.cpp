/* SCAPC.cpp
   Generated by gSOAP 2.8.49 for SCAP-Services.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "SCAPH.h"

SOAP_SOURCE_STAMP("@(#) SCAPC.cpp ver 2.8.49 2018-09-03 14:50:01 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_ns6__ProducedAtType:
		return soap_in_ns6__ProducedAtType(soap, NULL, NULL, "ns6:ProducedAtType");
	case SOAP_TYPE_ns6__IssueTimeType:
		return soap_in_ns6__IssueTimeType(soap, NULL, NULL, "ns6:IssueTimeType");
	case SOAP_TYPE_ns6__SigningTimeType:
		return soap_in_ns6__SigningTimeType(soap, NULL, NULL, "ns6:SigningTimeType");
	case SOAP_TYPE_dateTime:
		return soap_in_dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_wsa__FaultSubcodeValues:
		return soap_in_wsa__FaultSubcodeValues(soap, NULL, NULL, "wsa:FaultSubcodeValues");
	case SOAP_TYPE_wsa__RelationshipTypeValues:
		return soap_in_wsa__RelationshipTypeValues(soap, NULL, NULL, "wsa:RelationshipTypeValues");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns7__SVGType:
		return soap_in_ns7__SVGType(soap, NULL, NULL, "ns7:SVGType");
	case SOAP_TYPE_ns6__ByNameType:
		return soap_in_ns6__ByNameType(soap, NULL, NULL, "ns6:ByNameType");
	case SOAP_TYPE_ns6__NumberType:
		return soap_in_ns6__NumberType(soap, NULL, NULL, "ns6:NumberType");
	case SOAP_TYPE_ns6__IssuerType:
		return soap_in_ns6__IssuerType(soap, NULL, NULL, "ns6:IssuerType");
	case SOAP_TYPE_ns6__EncapsulatedTimeStampType:
		return soap_in_ns6__EncapsulatedTimeStampType(soap, NULL, NULL, "ns6:EncapsulatedTimeStampType");
	case SOAP_TYPE_ns4__ResponseCodeMessage:
		return soap_in_ns4__ResponseCodeMessage(soap, NULL, NULL, "ns4:ResponseCodeMessage");
	case SOAP_TYPE_ns4__ResponseCodeType:
		return soap_in_ns4__ResponseCodeType(soap, NULL, NULL, "ns4:ResponseCodeType");
	case SOAP_TYPE_ns4__DescriptionType:
		return soap_in_ns4__DescriptionType(soap, NULL, NULL, "ns4:DescriptionType");
	case SOAP_TYPE_ns4__SubAttributeValueType:
		return soap_in_ns4__SubAttributeValueType(soap, NULL, NULL, "ns4:SubAttributeValueType");
	case SOAP_TYPE_ns4__LegalActType:
		return soap_in_ns4__LegalActType(soap, NULL, NULL, "ns4:LegalActType");
	case SOAP_TYPE_ns4__AttributeIDType:
		return soap_in_ns4__AttributeIDType(soap, NULL, NULL, "ns4:AttributeIDType");
	case SOAP_TYPE_ns4__ExtraIDValueType:
		return soap_in_ns4__ExtraIDValueType(soap, NULL, NULL, "ns4:ExtraIDValueType");
	case SOAP_TYPE_ns4__CompanyNameType:
		return soap_in_ns4__CompanyNameType(soap, NULL, NULL, "ns4:CompanyNameType");
	case SOAP_TYPE_ns4__NIPCType:
		return soap_in_ns4__NIPCType(soap, NULL, NULL, "ns4:NIPCType");
	case SOAP_TYPE_ns4__NICType:
		return soap_in_ns4__NICType(soap, NULL, NULL, "ns4:NICType");
	case SOAP_TYPE_ns4__DateType:
		return soap_in_ns4__DateType(soap, NULL, NULL, "ns4:DateType");
	case SOAP_TYPE_ns4__ValidityType:
		return soap_in_ns4__ValidityType(soap, NULL, NULL, "ns4:ValidityType");
	case SOAP_TYPE_ns4__NameType:
		return soap_in_ns4__NameType(soap, NULL, NULL, "ns4:NameType");
	case SOAP_TYPE_ns4__ProcessIDType:
		return soap_in_ns4__ProcessIDType(soap, NULL, NULL, "ns4:ProcessIDType");
	case SOAP_TYPE_ns5__X509SerialNumberType:
		return soap_in_ns5__X509SerialNumberType(soap, NULL, NULL, "ns5:X509SerialNumberType");
	case SOAP_TYPE_ns5__X509IssuerNameType:
		return soap_in_ns5__X509IssuerNameType(soap, NULL, NULL, "ns5:X509IssuerNameType");
	case SOAP_TYPE_ns1__TransactionType:
		return soap_in_ns1__TransactionType(soap, NULL, NULL, "ns1:TransactionType");
	case SOAP_TYPE_ns1__TransactionTypeList:
		return soap_in_ns1__TransactionTypeList(soap, NULL, NULL, "ns1:TransactionTypeList");
	case SOAP_TYPE_ns1__Status:
		return soap_in_ns1__Status(soap, NULL, NULL, "ns1:Status");
	case SOAP_TYPE_ns1__SubAttributeType:
		return soap_in_ns1__SubAttributeType(soap, NULL, NULL, "ns1:SubAttributeType");
	case SOAP_TYPE_ns1__SubAttributeListType:
		return soap_in_ns1__SubAttributeListType(soap, NULL, NULL, "ns1:SubAttributeListType");
	case SOAP_TYPE_ns1__LegalActListType:
		return soap_in_ns1__LegalActListType(soap, NULL, NULL, "ns1:LegalActListType");
	case SOAP_TYPE_ns1__MainAttributeType:
		return soap_in_ns1__MainAttributeType(soap, NULL, NULL, "ns1:MainAttributeType");
	case SOAP_TYPE_ns1__AttributeSupplierType:
		return soap_in_ns1__AttributeSupplierType(soap, NULL, NULL, "ns1:AttributeSupplierType");
	case SOAP_TYPE_ns1__AttributeType:
		return soap_in_ns1__AttributeType(soap, NULL, NULL, "ns1:AttributeType");
	case SOAP_TYPE_ns1__AttributeListType:
		return soap_in_ns1__AttributeListType(soap, NULL, NULL, "ns1:AttributeListType");
	case SOAP_TYPE_ns1__PersonalData:
		return soap_in_ns1__PersonalData(soap, NULL, NULL, "ns1:PersonalData");
	case SOAP_TYPE_ns9__AttributeSupplierResponseType:
		return soap_in_ns9__AttributeSupplierResponseType(soap, NULL, NULL, "ns9:AttributeSupplierResponseType");
	case SOAP_TYPE_ns7__SVGListType:
		return soap_in_ns7__SVGListType(soap, NULL, NULL, "ns7:SVGListType");
	case SOAP_TYPE_ns6__ArchiveTimeStampType:
		return soap_in_ns6__ArchiveTimeStampType(soap, NULL, NULL, "ns6:ArchiveTimeStampType");
	case SOAP_TYPE_ns6__EncapsulatedOCSPValueType:
		return soap_in_ns6__EncapsulatedOCSPValueType(soap, NULL, NULL, "ns6:EncapsulatedOCSPValueType");
	case SOAP_TYPE_ns6__OCSPValuesType:
		return soap_in_ns6__OCSPValuesType(soap, NULL, NULL, "ns6:OCSPValuesType");
	case SOAP_TYPE_ns6__EncapsulatedCRLValueType:
		return soap_in_ns6__EncapsulatedCRLValueType(soap, NULL, NULL, "ns6:EncapsulatedCRLValueType");
	case SOAP_TYPE_ns6__CRLValuesType:
		return soap_in_ns6__CRLValuesType(soap, NULL, NULL, "ns6:CRLValuesType");
	case SOAP_TYPE_ns6__RevocationValuesType:
		return soap_in_ns6__RevocationValuesType(soap, NULL, NULL, "ns6:RevocationValuesType");
	case SOAP_TYPE_ns6__EncapsulatedX509CertificateType:
		return soap_in_ns6__EncapsulatedX509CertificateType(soap, NULL, NULL, "ns6:EncapsulatedX509CertificateType");
	case SOAP_TYPE_ns6__CertificateValuesType:
		return soap_in_ns6__CertificateValuesType(soap, NULL, NULL, "ns6:CertificateValuesType");
	case SOAP_TYPE_ns6__SigAndRefsTimeStampType:
		return soap_in_ns6__SigAndRefsTimeStampType(soap, NULL, NULL, "ns6:SigAndRefsTimeStampType");
	case SOAP_TYPE_ns6__ResponderIDType:
		return soap_in_ns6__ResponderIDType(soap, NULL, NULL, "ns6:ResponderIDType");
	case SOAP_TYPE_ns6__OCSPIdentifierType:
		return soap_in_ns6__OCSPIdentifierType(soap, NULL, NULL, "ns6:OCSPIdentifierType");
	case SOAP_TYPE_ns6__OCSPRefType:
		return soap_in_ns6__OCSPRefType(soap, NULL, NULL, "ns6:OCSPRefType");
	case SOAP_TYPE_ns6__OCSPRefsType:
		return soap_in_ns6__OCSPRefsType(soap, NULL, NULL, "ns6:OCSPRefsType");
	case SOAP_TYPE_ns6__CRLIdentifierType:
		return soap_in_ns6__CRLIdentifierType(soap, NULL, NULL, "ns6:CRLIdentifierType");
	case SOAP_TYPE_ns6__DigestAlgAndValueType:
		return soap_in_ns6__DigestAlgAndValueType(soap, NULL, NULL, "ns6:DigestAlgAndValueType");
	case SOAP_TYPE_ns6__CRLRefType:
		return soap_in_ns6__CRLRefType(soap, NULL, NULL, "ns6:CRLRefType");
	case SOAP_TYPE_ns6__CRLRefsType:
		return soap_in_ns6__CRLRefsType(soap, NULL, NULL, "ns6:CRLRefsType");
	case SOAP_TYPE_ns6__CompleteRevocationRefsType:
		return soap_in_ns6__CompleteRevocationRefsType(soap, NULL, NULL, "ns6:CompleteRevocationRefsType");
	case SOAP_TYPE_ns6__CertRefsType:
		return soap_in_ns6__CertRefsType(soap, NULL, NULL, "ns6:CertRefsType");
	case SOAP_TYPE_ns6__CompleteCertificateRefsType:
		return soap_in_ns6__CompleteCertificateRefsType(soap, NULL, NULL, "ns6:CompleteCertificateRefsType");
	case SOAP_TYPE_ns6__SignatureTimeStampType:
		return soap_in_ns6__SignatureTimeStampType(soap, NULL, NULL, "ns6:SignatureTimeStampType");
	case SOAP_TYPE_ns6__CounterSignatureType:
		return soap_in_ns6__CounterSignatureType(soap, NULL, NULL, "ns6:CounterSignatureType");
	case SOAP_TYPE_ns6__UnsignedSignaturePropertiesType:
		return soap_in_ns6__UnsignedSignaturePropertiesType(soap, NULL, NULL, "ns6:UnsignedSignaturePropertiesType");
	case SOAP_TYPE_ns6__UnsignedPropertiesType:
		return soap_in_ns6__UnsignedPropertiesType(soap, NULL, NULL, "ns6:UnsignedPropertiesType");
	case SOAP_TYPE_ns6__ClaimedRoleType:
		return soap_in_ns6__ClaimedRoleType(soap, NULL, NULL, "ns6:ClaimedRoleType");
	case SOAP_TYPE_ns6__ClaimedRolesListType:
		return soap_in_ns6__ClaimedRolesListType(soap, NULL, NULL, "ns6:ClaimedRolesListType");
	case SOAP_TYPE_ns6__SignerRoleType:
		return soap_in_ns6__SignerRoleType(soap, NULL, NULL, "ns6:SignerRoleType");
	case SOAP_TYPE_ns6__IssuerSerialType:
		return soap_in_ns6__IssuerSerialType(soap, NULL, NULL, "ns6:IssuerSerialType");
	case SOAP_TYPE_ns6__CertDigestType:
		return soap_in_ns6__CertDigestType(soap, NULL, NULL, "ns6:CertDigestType");
	case SOAP_TYPE_ns6__CertType:
		return soap_in_ns6__CertType(soap, NULL, NULL, "ns6:CertType");
	case SOAP_TYPE_ns6__SigningCertificateType:
		return soap_in_ns6__SigningCertificateType(soap, NULL, NULL, "ns6:SigningCertificateType");
	case SOAP_TYPE_ns6__SignedSignaturePropertiesType:
		return soap_in_ns6__SignedSignaturePropertiesType(soap, NULL, NULL, "ns6:SignedSignaturePropertiesType");
	case SOAP_TYPE_ns6__SignedPropertiesType:
		return soap_in_ns6__SignedPropertiesType(soap, NULL, NULL, "ns6:SignedPropertiesType");
	case SOAP_TYPE_ns6__QualifyingPropertiesType:
		return soap_in_ns6__QualifyingPropertiesType(soap, NULL, NULL, "ns6:QualifyingPropertiesType");
	case SOAP_TYPE_ns3__ResponseCodeStatusType:
		return soap_in_ns3__ResponseCodeStatusType(soap, NULL, NULL, "ns3:ResponseCodeStatusType");
	case SOAP_TYPE_ns3__SubAttributeType:
		return soap_in_ns3__SubAttributeType(soap, NULL, NULL, "ns3:SubAttributeType");
	case SOAP_TYPE_ns3__SubAttributeListType:
		return soap_in_ns3__SubAttributeListType(soap, NULL, NULL, "ns3:SubAttributeListType");
	case SOAP_TYPE_ns3__LegalActListType:
		return soap_in_ns3__LegalActListType(soap, NULL, NULL, "ns3:LegalActListType");
	case SOAP_TYPE_ns3__MainAttributeType:
		return soap_in_ns3__MainAttributeType(soap, NULL, NULL, "ns3:MainAttributeType");
	case SOAP_TYPE_ns3__ExtraIDType:
		return soap_in_ns3__ExtraIDType(soap, NULL, NULL, "ns3:ExtraIDType");
	case SOAP_TYPE_ns3__ExtraIDListType:
		return soap_in_ns3__ExtraIDListType(soap, NULL, NULL, "ns3:ExtraIDListType");
	case SOAP_TYPE_ns3__PersonalDataType:
		return soap_in_ns3__PersonalDataType(soap, NULL, NULL, "ns3:PersonalDataType");
	case SOAP_TYPE_ns3__AttributeSupplierType:
		return soap_in_ns3__AttributeSupplierType(soap, NULL, NULL, "ns3:AttributeSupplierType");
	case SOAP_TYPE_ns3__AttributeType:
		return soap_in_ns3__AttributeType(soap, NULL, NULL, "ns3:AttributeType");
	case SOAP_TYPE_ns5__SignatureValueType:
		return soap_in_ns5__SignatureValueType(soap, NULL, NULL, "ns5:SignatureValueType");
	case SOAP_TYPE_ns5__DigestValueType:
		return soap_in_ns5__DigestValueType(soap, NULL, NULL, "ns5:DigestValueType");
	case SOAP_TYPE_ns5__X509CertificateType:
		return soap_in_ns5__X509CertificateType(soap, NULL, NULL, "ns5:X509CertificateType");
	case SOAP_TYPE_ns5__ObjectType:
		return soap_in_ns5__ObjectType(soap, NULL, NULL, "ns5:ObjectType");
	case SOAP_TYPE_ns5__X509DataType:
		return soap_in_ns5__X509DataType(soap, NULL, NULL, "ns5:X509DataType");
	case SOAP_TYPE_ns5__KeyInfoType:
		return soap_in_ns5__KeyInfoType(soap, NULL, NULL, "ns5:KeyInfoType");
	case SOAP_TYPE_ns5__DigestMethodType:
		return soap_in_ns5__DigestMethodType(soap, NULL, NULL, "ns5:DigestMethodType");
	case SOAP_TYPE_ns5__TransformType:
		return soap_in_ns5__TransformType(soap, NULL, NULL, "ns5:TransformType");
	case SOAP_TYPE_ns5__TransformsType:
		return soap_in_ns5__TransformsType(soap, NULL, NULL, "ns5:TransformsType");
	case SOAP_TYPE_ns5__ReferenceType:
		return soap_in_ns5__ReferenceType(soap, NULL, NULL, "ns5:ReferenceType");
	case SOAP_TYPE_ns5__SignatureMethodType:
		return soap_in_ns5__SignatureMethodType(soap, NULL, NULL, "ns5:SignatureMethodType");
	case SOAP_TYPE_ns5__CanonicalizationMethodType:
		return soap_in_ns5__CanonicalizationMethodType(soap, NULL, NULL, "ns5:CanonicalizationMethodType");
	case SOAP_TYPE_ns5__SignedInfoType:
		return soap_in_ns5__SignedInfoType(soap, NULL, NULL, "ns5:SignedInfoType");
	case SOAP_TYPE_ns5__SignatureType:
		return soap_in_ns5__SignatureType(soap, NULL, NULL, "ns5:SignatureType");
	case SOAP_TYPE_ns2__ResponseResult:
		return soap_in_ns2__ResponseResult(soap, NULL, NULL, "ns2:ResponseResult");
	case SOAP_TYPE_ns2__UnsignedAttributesBasicType:
		return soap_in_ns2__UnsignedAttributesBasicType(soap, NULL, NULL, "ns2:UnsignedAttributesBasicType");
	case SOAP_TYPE_ns2__SignedAttributesType:
		return soap_in_ns2__SignedAttributesType(soap, NULL, NULL, "ns2:SignedAttributesType");
	case SOAP_TYPE_ns2__UnsignedAttributesType:
		return soap_in_ns2__UnsignedAttributesType(soap, NULL, NULL, "ns2:UnsignedAttributesType");
	case SOAP_TYPE_ns2__AttributesType:
		return soap_in_ns2__AttributesType(soap, NULL, NULL, "ns2:AttributesType");
	case SOAP_TYPE_ns2__UnsignedAttributeResponseType:
		return soap_in_ns2__UnsignedAttributeResponseType(soap, NULL, NULL, "ns2:UnsignedAttributeResponseType");
	case SOAP_TYPE_ns2__SingleAttributeResponseType:
		return soap_in_ns2__SingleAttributeResponseType(soap, NULL, NULL, "ns2:SingleAttributeResponseType");
	case SOAP_TYPE_ns2__AttributeResponseType:
		return soap_in_ns2__AttributeResponseType(soap, NULL, NULL, "ns2:AttributeResponseType");
	case SOAP_TYPE_ns2__AttributeSupplierListType:
		return soap_in_ns2__AttributeSupplierListType(soap, NULL, NULL, "ns2:AttributeSupplierListType");
	case SOAP_TYPE_ns2__PSAAttributeRequestType:
		return soap_in_ns2__PSAAttributeRequestType(soap, NULL, NULL, "ns2:PSAAttributeRequestType");
	case SOAP_TYPE_ns2__SingleAttributeRequestType:
		return soap_in_ns2__SingleAttributeRequestType(soap, NULL, NULL, "ns2:SingleAttributeRequestType");
	case SOAP_TYPE_ns2__AttributeRequestType:
		return soap_in_ns2__AttributeRequestType(soap, NULL, NULL, "ns2:AttributeRequestType");
	case SOAP_TYPE_xsd__integer:
		return soap_in_xsd__integer(soap, NULL, NULL, "xsd:integer");
	case SOAP_TYPE_xsd__date:
		return soap_in_xsd__date(soap, NULL, NULL, "xsd:date");
	case SOAP_TYPE_xsd__anyURI:
		return soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_xsd__ID:
		return soap_in_xsd__ID(soap, NULL, NULL, "xsd:ID");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_wsa__Relationship:
		return soap_in_wsa__Relationship(soap, NULL, NULL, "wsa:Relationship");
	case SOAP_TYPE_wsa__ServiceNameType:
		return soap_in_wsa__ServiceNameType(soap, NULL, NULL, "wsa:ServiceNameType");
	case SOAP_TYPE_wsa__ReferenceParametersType:
		return soap_in_wsa__ReferenceParametersType(soap, NULL, NULL, "wsa:ReferenceParametersType");
	case SOAP_TYPE_wsa__ReferencePropertiesType:
		return soap_in_wsa__ReferencePropertiesType(soap, NULL, NULL, "wsa:ReferencePropertiesType");
	case SOAP_TYPE_wsa__EndpointReferenceType:
		return soap_in_wsa__EndpointReferenceType(soap, NULL, NULL, "wsa:EndpointReferenceType");
	case SOAP_TYPE_PointerTo_ns1__SignatureRequest:
		return soap_in_PointerTo_ns1__SignatureRequest(soap, NULL, NULL, "ns1:SignatureRequest");
	case SOAP_TYPE_PointerTo_ns1__AuthorizationRequest:
		return soap_in_PointerTo_ns1__AuthorizationRequest(soap, NULL, NULL, "ns1:AuthorizationRequest");
	case SOAP_TYPE_PointerTons2__AttributeRequestType:
		return soap_in_PointerTons2__AttributeRequestType(soap, NULL, NULL, "ns2:AttributeRequestType");
	case SOAP_TYPE_PointerTo_wsa__FaultTo:
		return soap_in_PointerTo_wsa__FaultTo(soap, NULL, NULL, "wsa:FaultTo");
	case SOAP_TYPE_PointerTo_wsa__ReplyTo:
		return soap_in_PointerTo_wsa__ReplyTo(soap, NULL, NULL, "wsa:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa__From:
		return soap_in_PointerTo_wsa__From(soap, NULL, NULL, "wsa:From");
	case SOAP_TYPE_PointerTo_wsa__RelatesTo:
		return soap_in_PointerTo_wsa__RelatesTo(soap, NULL, NULL, "wsa:RelatesTo");
	case SOAP_TYPE_PointerTowsa__ServiceNameType:
		return soap_in_PointerTowsa__ServiceNameType(soap, NULL, NULL, "wsa:ServiceNameType");
	case SOAP_TYPE_PointerTo_QName:
		return soap_in_PointerTo_QName(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_PointerTowsa__ReferenceParametersType:
		return soap_in_PointerTowsa__ReferenceParametersType(soap, NULL, NULL, "wsa:ReferenceParametersType");
	case SOAP_TYPE_PointerTowsa__ReferencePropertiesType:
		return soap_in_PointerTowsa__ReferencePropertiesType(soap, NULL, NULL, "wsa:ReferencePropertiesType");
	case SOAP_TYPE_PointerToxsd__ID:
		return soap_in_PointerToxsd__ID(soap, NULL, NULL, "xsd:ID");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_in_PointerToxsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTons1__TransactionTypeList:
		return soap_in_PointerTons1__TransactionTypeList(soap, NULL, NULL, "ns1:TransactionTypeList");
	case SOAP_TYPE_PointerTons1__Status:
		return soap_in_PointerTons1__Status(soap, NULL, NULL, "ns1:Status");
	case SOAP_TYPE_PointerTons1__AttributeListType:
		return soap_in_PointerTons1__AttributeListType(soap, NULL, NULL, "ns1:AttributeListType");
	case SOAP_TYPE_PointerTons1__PersonalData:
		return soap_in_PointerTons1__PersonalData(soap, NULL, NULL, "ns1:PersonalData");
	case SOAP_TYPE_PointerTons1__TransactionType:
		return soap_in_PointerTons1__TransactionType(soap, NULL, NULL, "ns1:TransactionType");
	case SOAP_TYPE_PointerTons1__SubAttributeType:
		return soap_in_PointerTons1__SubAttributeType(soap, NULL, NULL, "ns1:SubAttributeType");
	case SOAP_TYPE_PointerTons1__SubAttributeListType:
		return soap_in_PointerTons1__SubAttributeListType(soap, NULL, NULL, "ns1:SubAttributeListType");
	case SOAP_TYPE_PointerTons1__LegalActListType:
		return soap_in_PointerTons1__LegalActListType(soap, NULL, NULL, "ns1:LegalActListType");
	case SOAP_TYPE_PointerTons1__MainAttributeType:
		return soap_in_PointerTons1__MainAttributeType(soap, NULL, NULL, "ns1:MainAttributeType");
	case SOAP_TYPE_PointerTons1__AttributeSupplierType:
		return soap_in_PointerTons1__AttributeSupplierType(soap, NULL, NULL, "ns1:AttributeSupplierType");
	case SOAP_TYPE_PointerTons1__AttributeType:
		return soap_in_PointerTons1__AttributeType(soap, NULL, NULL, "ns1:AttributeType");
	case SOAP_TYPE_PointerTons6__EncapsulatedOCSPValueType:
		return soap_in_PointerTons6__EncapsulatedOCSPValueType(soap, NULL, NULL, "ns6:EncapsulatedOCSPValueType");
	case SOAP_TYPE_PointerTons6__EncapsulatedCRLValueType:
		return soap_in_PointerTons6__EncapsulatedCRLValueType(soap, NULL, NULL, "ns6:EncapsulatedCRLValueType");
	case SOAP_TYPE_PointerTons6__OCSPValuesType:
		return soap_in_PointerTons6__OCSPValuesType(soap, NULL, NULL, "ns6:OCSPValuesType");
	case SOAP_TYPE_PointerTons6__CRLValuesType:
		return soap_in_PointerTons6__CRLValuesType(soap, NULL, NULL, "ns6:CRLValuesType");
	case SOAP_TYPE_PointerTons6__EncapsulatedX509CertificateType:
		return soap_in_PointerTons6__EncapsulatedX509CertificateType(soap, NULL, NULL, "ns6:EncapsulatedX509CertificateType");
	case SOAP_TYPE_PointerTons6__ResponderIDType:
		return soap_in_PointerTons6__ResponderIDType(soap, NULL, NULL, "ns6:ResponderIDType");
	case SOAP_TYPE_PointerTons6__OCSPIdentifierType:
		return soap_in_PointerTons6__OCSPIdentifierType(soap, NULL, NULL, "ns6:OCSPIdentifierType");
	case SOAP_TYPE_PointerTons6__OCSPRefType:
		return soap_in_PointerTons6__OCSPRefType(soap, NULL, NULL, "ns6:OCSPRefType");
	case SOAP_TYPE_PointerTons6__CRLIdentifierType:
		return soap_in_PointerTons6__CRLIdentifierType(soap, NULL, NULL, "ns6:CRLIdentifierType");
	case SOAP_TYPE_PointerTons6__DigestAlgAndValueType:
		return soap_in_PointerTons6__DigestAlgAndValueType(soap, NULL, NULL, "ns6:DigestAlgAndValueType");
	case SOAP_TYPE_PointerTons6__CRLRefType:
		return soap_in_PointerTons6__CRLRefType(soap, NULL, NULL, "ns6:CRLRefType");
	case SOAP_TYPE_PointerTons6__OCSPRefsType:
		return soap_in_PointerTons6__OCSPRefsType(soap, NULL, NULL, "ns6:OCSPRefsType");
	case SOAP_TYPE_PointerTons6__CRLRefsType:
		return soap_in_PointerTons6__CRLRefsType(soap, NULL, NULL, "ns6:CRLRefsType");
	case SOAP_TYPE_PointerTons6__CertRefsType:
		return soap_in_PointerTons6__CertRefsType(soap, NULL, NULL, "ns6:CertRefsType");
	case SOAP_TYPE_PointerTons6__ArchiveTimeStampType:
		return soap_in_PointerTons6__ArchiveTimeStampType(soap, NULL, NULL, "ns6:ArchiveTimeStampType");
	case SOAP_TYPE_PointerTons6__RevocationValuesType:
		return soap_in_PointerTons6__RevocationValuesType(soap, NULL, NULL, "ns6:RevocationValuesType");
	case SOAP_TYPE_PointerTons6__CertificateValuesType:
		return soap_in_PointerTons6__CertificateValuesType(soap, NULL, NULL, "ns6:CertificateValuesType");
	case SOAP_TYPE_PointerTons6__SigAndRefsTimeStampType:
		return soap_in_PointerTons6__SigAndRefsTimeStampType(soap, NULL, NULL, "ns6:SigAndRefsTimeStampType");
	case SOAP_TYPE_PointerTons6__CompleteRevocationRefsType:
		return soap_in_PointerTons6__CompleteRevocationRefsType(soap, NULL, NULL, "ns6:CompleteRevocationRefsType");
	case SOAP_TYPE_PointerTons6__CompleteCertificateRefsType:
		return soap_in_PointerTons6__CompleteCertificateRefsType(soap, NULL, NULL, "ns6:CompleteCertificateRefsType");
	case SOAP_TYPE_PointerTons6__SignatureTimeStampType:
		return soap_in_PointerTons6__SignatureTimeStampType(soap, NULL, NULL, "ns6:SignatureTimeStampType");
	case SOAP_TYPE_PointerTons6__CounterSignatureType:
		return soap_in_PointerTons6__CounterSignatureType(soap, NULL, NULL, "ns6:CounterSignatureType");
	case SOAP_TYPE_PointerTons6__UnsignedSignaturePropertiesType:
		return soap_in_PointerTons6__UnsignedSignaturePropertiesType(soap, NULL, NULL, "ns6:UnsignedSignaturePropertiesType");
	case SOAP_TYPE_PointerTons6__ClaimedRoleType:
		return soap_in_PointerTons6__ClaimedRoleType(soap, NULL, NULL, "ns6:ClaimedRoleType");
	case SOAP_TYPE_PointerTons6__ClaimedRolesListType:
		return soap_in_PointerTons6__ClaimedRolesListType(soap, NULL, NULL, "ns6:ClaimedRolesListType");
	case SOAP_TYPE_PointerTons6__IssuerSerialType:
		return soap_in_PointerTons6__IssuerSerialType(soap, NULL, NULL, "ns6:IssuerSerialType");
	case SOAP_TYPE_PointerTons6__CertDigestType:
		return soap_in_PointerTons6__CertDigestType(soap, NULL, NULL, "ns6:CertDigestType");
	case SOAP_TYPE_PointerTons6__CertType:
		return soap_in_PointerTons6__CertType(soap, NULL, NULL, "ns6:CertType");
	case SOAP_TYPE_PointerTons6__SignerRoleType:
		return soap_in_PointerTons6__SignerRoleType(soap, NULL, NULL, "ns6:SignerRoleType");
	case SOAP_TYPE_PointerTons6__SigningCertificateType:
		return soap_in_PointerTons6__SigningCertificateType(soap, NULL, NULL, "ns6:SigningCertificateType");
	case SOAP_TYPE_PointerTons6__SignedSignaturePropertiesType:
		return soap_in_PointerTons6__SignedSignaturePropertiesType(soap, NULL, NULL, "ns6:SignedSignaturePropertiesType");
	case SOAP_TYPE_PointerTons6__UnsignedPropertiesType:
		return soap_in_PointerTons6__UnsignedPropertiesType(soap, NULL, NULL, "ns6:UnsignedPropertiesType");
	case SOAP_TYPE_PointerTons6__SignedPropertiesType:
		return soap_in_PointerTons6__SignedPropertiesType(soap, NULL, NULL, "ns6:SignedPropertiesType");
	case SOAP_TYPE_PointerTons4__ResponseCodeMessage:
		return soap_in_PointerTons4__ResponseCodeMessage(soap, NULL, NULL, "ns4:ResponseCodeMessage");
	case SOAP_TYPE_PointerTons4__SubAttributeValueType:
		return soap_in_PointerTons4__SubAttributeValueType(soap, NULL, NULL, "ns4:SubAttributeValueType");
	case SOAP_TYPE_PointerTons3__SubAttributeType:
		return soap_in_PointerTons3__SubAttributeType(soap, NULL, NULL, "ns3:SubAttributeType");
	case SOAP_TYPE_PointerTons3__SubAttributeListType:
		return soap_in_PointerTons3__SubAttributeListType(soap, NULL, NULL, "ns3:SubAttributeListType");
	case SOAP_TYPE_PointerTons3__LegalActListType:
		return soap_in_PointerTons3__LegalActListType(soap, NULL, NULL, "ns3:LegalActListType");
	case SOAP_TYPE_PointerTons4__DescriptionType:
		return soap_in_PointerTons4__DescriptionType(soap, NULL, NULL, "ns4:DescriptionType");
	case SOAP_TYPE_PointerTons3__ExtraIDType:
		return soap_in_PointerTons3__ExtraIDType(soap, NULL, NULL, "ns3:ExtraIDType");
	case SOAP_TYPE_PointerTons3__ExtraIDListType:
		return soap_in_PointerTons3__ExtraIDListType(soap, NULL, NULL, "ns3:ExtraIDListType");
	case SOAP_TYPE_PointerTons3__MainAttributeType:
		return soap_in_PointerTons3__MainAttributeType(soap, NULL, NULL, "ns3:MainAttributeType");
	case SOAP_TYPE_PointerTons7__SVGListType:
		return soap_in_PointerTons7__SVGListType(soap, NULL, NULL, "ns7:SVGListType");
	case SOAP_TYPE_PointerTons6__QualifyingPropertiesType:
		return soap_in_PointerTons6__QualifyingPropertiesType(soap, NULL, NULL, "ns6:QualifyingPropertiesType");
	case SOAP_TYPE_PointerTons5__X509CertificateType:
		return soap_in_PointerTons5__X509CertificateType(soap, NULL, NULL, "ns5:X509CertificateType");
	case SOAP_TYPE_PointerTons5__X509DataType:
		return soap_in_PointerTons5__X509DataType(soap, NULL, NULL, "ns5:X509DataType");
	case SOAP_TYPE_PointerTons5__TransformType:
		return soap_in_PointerTons5__TransformType(soap, NULL, NULL, "ns5:TransformType");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_in_PointerToxsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_PointerTons5__DigestValueType:
		return soap_in_PointerTons5__DigestValueType(soap, NULL, NULL, "ns5:DigestValueType");
	case SOAP_TYPE_PointerTons5__DigestMethodType:
		return soap_in_PointerTons5__DigestMethodType(soap, NULL, NULL, "ns5:DigestMethodType");
	case SOAP_TYPE_PointerTons5__TransformsType:
		return soap_in_PointerTons5__TransformsType(soap, NULL, NULL, "ns5:TransformsType");
	case SOAP_TYPE_PointerTons5__ReferenceType:
		return soap_in_PointerTons5__ReferenceType(soap, NULL, NULL, "ns5:ReferenceType");
	case SOAP_TYPE_PointerTons5__SignatureMethodType:
		return soap_in_PointerTons5__SignatureMethodType(soap, NULL, NULL, "ns5:SignatureMethodType");
	case SOAP_TYPE_PointerTons5__CanonicalizationMethodType:
		return soap_in_PointerTons5__CanonicalizationMethodType(soap, NULL, NULL, "ns5:CanonicalizationMethodType");
	case SOAP_TYPE_PointerTons5__ObjectType:
		return soap_in_PointerTons5__ObjectType(soap, NULL, NULL, "ns5:ObjectType");
	case SOAP_TYPE_PointerTons5__KeyInfoType:
		return soap_in_PointerTons5__KeyInfoType(soap, NULL, NULL, "ns5:KeyInfoType");
	case SOAP_TYPE_PointerTons5__SignatureValueType:
		return soap_in_PointerTons5__SignatureValueType(soap, NULL, NULL, "ns5:SignatureValueType");
	case SOAP_TYPE_PointerTons5__SignedInfoType:
		return soap_in_PointerTons5__SignedInfoType(soap, NULL, NULL, "ns5:SignedInfoType");
	case SOAP_TYPE_PointerTons3__AttributeType:
		return soap_in_PointerTons3__AttributeType(soap, NULL, NULL, "ns3:AttributeType");
	case SOAP_TYPE_PointerTons5__SignatureType:
		return soap_in_PointerTons5__SignatureType(soap, NULL, NULL, "ns5:SignatureType");
	case SOAP_TYPE_PointerTons2__UnsignedAttributesBasicType:
		return soap_in_PointerTons2__UnsignedAttributesBasicType(soap, NULL, NULL, "ns2:UnsignedAttributesBasicType");
	case SOAP_TYPE_PointerTons2__SignedAttributesType:
		return soap_in_PointerTons2__SignedAttributesType(soap, NULL, NULL, "ns2:SignedAttributesType");
	case SOAP_TYPE_PointerTons2__ResponseResult:
		return soap_in_PointerTons2__ResponseResult(soap, NULL, NULL, "ns2:ResponseResult");
	case SOAP_TYPE_PointerTons2__UnsignedAttributesType:
		return soap_in_PointerTons2__UnsignedAttributesType(soap, NULL, NULL, "ns2:UnsignedAttributesType");
	case SOAP_TYPE_PointerTons2__AttributesType:
		return soap_in_PointerTons2__AttributesType(soap, NULL, NULL, "ns2:AttributesType");
	case SOAP_TYPE_PointerTons4__CompanyNameType:
		return soap_in_PointerTons4__CompanyNameType(soap, NULL, NULL, "ns4:CompanyNameType");
	case SOAP_TYPE_PointerTons4__NIPCType:
		return soap_in_PointerTons4__NIPCType(soap, NULL, NULL, "ns4:NIPCType");
	case SOAP_TYPE_PointerTons3__AttributeSupplierType:
		return soap_in_PointerTons3__AttributeSupplierType(soap, NULL, NULL, "ns3:AttributeSupplierType");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTons2__AttributeSupplierListType:
		return soap_in_PointerTons2__AttributeSupplierListType(soap, NULL, NULL, "ns2:AttributeSupplierListType");
	case SOAP_TYPE_PointerTons3__PersonalDataType:
		return soap_in_PointerTons3__PersonalDataType(soap, NULL, NULL, "ns3:PersonalDataType");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns7:SVGType"))
		{	*type = SOAP_TYPE_ns7__SVGType;
			return soap_in_ns7__SVGType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ByNameType"))
		{	*type = SOAP_TYPE_ns6__ByNameType;
			return soap_in_ns6__ByNameType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:NumberType"))
		{	*type = SOAP_TYPE_ns6__NumberType;
			return soap_in_ns6__NumberType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:IssuerType"))
		{	*type = SOAP_TYPE_ns6__IssuerType;
			return soap_in_ns6__IssuerType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:EncapsulatedTimeStampType"))
		{	*type = SOAP_TYPE_ns6__EncapsulatedTimeStampType;
			return soap_in_ns6__EncapsulatedTimeStampType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ResponseCodeMessage"))
		{	*type = SOAP_TYPE_ns4__ResponseCodeMessage;
			return soap_in_ns4__ResponseCodeMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ResponseCodeType"))
		{	*type = SOAP_TYPE_ns4__ResponseCodeType;
			return soap_in_ns4__ResponseCodeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:DescriptionType"))
		{	*type = SOAP_TYPE_ns4__DescriptionType;
			return soap_in_ns4__DescriptionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SubAttributeValueType"))
		{	*type = SOAP_TYPE_ns4__SubAttributeValueType;
			return soap_in_ns4__SubAttributeValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:LegalActType"))
		{	*type = SOAP_TYPE_ns4__LegalActType;
			return soap_in_ns4__LegalActType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:AttributeIDType"))
		{	*type = SOAP_TYPE_ns4__AttributeIDType;
			return soap_in_ns4__AttributeIDType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ExtraIDValueType"))
		{	*type = SOAP_TYPE_ns4__ExtraIDValueType;
			return soap_in_ns4__ExtraIDValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:CompanyNameType"))
		{	*type = SOAP_TYPE_ns4__CompanyNameType;
			return soap_in_ns4__CompanyNameType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:NIPCType"))
		{	*type = SOAP_TYPE_ns4__NIPCType;
			return soap_in_ns4__NIPCType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:NICType"))
		{	*type = SOAP_TYPE_ns4__NICType;
			return soap_in_ns4__NICType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:DateType"))
		{	*type = SOAP_TYPE_ns4__DateType;
			return soap_in_ns4__DateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ValidityType"))
		{	*type = SOAP_TYPE_ns4__ValidityType;
			return soap_in_ns4__ValidityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:NameType"))
		{	*type = SOAP_TYPE_ns4__NameType;
			return soap_in_ns4__NameType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ProcessIDType"))
		{	*type = SOAP_TYPE_ns4__ProcessIDType;
			return soap_in_ns4__ProcessIDType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:X509SerialNumberType"))
		{	*type = SOAP_TYPE_ns5__X509SerialNumberType;
			return soap_in_ns5__X509SerialNumberType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:X509IssuerNameType"))
		{	*type = SOAP_TYPE_ns5__X509IssuerNameType;
			return soap_in_ns5__X509IssuerNameType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TransactionType"))
		{	*type = SOAP_TYPE_ns1__TransactionType;
			return soap_in_ns1__TransactionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TransactionTypeList"))
		{	*type = SOAP_TYPE_ns1__TransactionTypeList;
			return soap_in_ns1__TransactionTypeList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Status"))
		{	*type = SOAP_TYPE_ns1__Status;
			return soap_in_ns1__Status(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubAttributeType"))
		{	*type = SOAP_TYPE_ns1__SubAttributeType;
			return soap_in_ns1__SubAttributeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubAttributeListType"))
		{	*type = SOAP_TYPE_ns1__SubAttributeListType;
			return soap_in_ns1__SubAttributeListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LegalActListType"))
		{	*type = SOAP_TYPE_ns1__LegalActListType;
			return soap_in_ns1__LegalActListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MainAttributeType"))
		{	*type = SOAP_TYPE_ns1__MainAttributeType;
			return soap_in_ns1__MainAttributeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AttributeSupplierType"))
		{	*type = SOAP_TYPE_ns1__AttributeSupplierType;
			return soap_in_ns1__AttributeSupplierType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AttributeType"))
		{	*type = SOAP_TYPE_ns1__AttributeType;
			return soap_in_ns1__AttributeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AttributeListType"))
		{	*type = SOAP_TYPE_ns1__AttributeListType;
			return soap_in_ns1__AttributeListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PersonalData"))
		{	*type = SOAP_TYPE_ns1__PersonalData;
			return soap_in_ns1__PersonalData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns9:AttributeSupplierResponseType"))
		{	*type = SOAP_TYPE_ns9__AttributeSupplierResponseType;
			return soap_in_ns9__AttributeSupplierResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SVGListType"))
		{	*type = SOAP_TYPE_ns7__SVGListType;
			return soap_in_ns7__SVGListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ArchiveTimeStampType"))
		{	*type = SOAP_TYPE_ns6__ArchiveTimeStampType;
			return soap_in_ns6__ArchiveTimeStampType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:EncapsulatedOCSPValueType"))
		{	*type = SOAP_TYPE_ns6__EncapsulatedOCSPValueType;
			return soap_in_ns6__EncapsulatedOCSPValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:OCSPValuesType"))
		{	*type = SOAP_TYPE_ns6__OCSPValuesType;
			return soap_in_ns6__OCSPValuesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:EncapsulatedCRLValueType"))
		{	*type = SOAP_TYPE_ns6__EncapsulatedCRLValueType;
			return soap_in_ns6__EncapsulatedCRLValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:CRLValuesType"))
		{	*type = SOAP_TYPE_ns6__CRLValuesType;
			return soap_in_ns6__CRLValuesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:RevocationValuesType"))
		{	*type = SOAP_TYPE_ns6__RevocationValuesType;
			return soap_in_ns6__RevocationValuesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:EncapsulatedX509CertificateType"))
		{	*type = SOAP_TYPE_ns6__EncapsulatedX509CertificateType;
			return soap_in_ns6__EncapsulatedX509CertificateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:CertificateValuesType"))
		{	*type = SOAP_TYPE_ns6__CertificateValuesType;
			return soap_in_ns6__CertificateValuesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:SigAndRefsTimeStampType"))
		{	*type = SOAP_TYPE_ns6__SigAndRefsTimeStampType;
			return soap_in_ns6__SigAndRefsTimeStampType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ResponderIDType"))
		{	*type = SOAP_TYPE_ns6__ResponderIDType;
			return soap_in_ns6__ResponderIDType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:OCSPIdentifierType"))
		{	*type = SOAP_TYPE_ns6__OCSPIdentifierType;
			return soap_in_ns6__OCSPIdentifierType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:OCSPRefType"))
		{	*type = SOAP_TYPE_ns6__OCSPRefType;
			return soap_in_ns6__OCSPRefType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:OCSPRefsType"))
		{	*type = SOAP_TYPE_ns6__OCSPRefsType;
			return soap_in_ns6__OCSPRefsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:CRLIdentifierType"))
		{	*type = SOAP_TYPE_ns6__CRLIdentifierType;
			return soap_in_ns6__CRLIdentifierType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:DigestAlgAndValueType"))
		{	*type = SOAP_TYPE_ns6__DigestAlgAndValueType;
			return soap_in_ns6__DigestAlgAndValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:CRLRefType"))
		{	*type = SOAP_TYPE_ns6__CRLRefType;
			return soap_in_ns6__CRLRefType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:CRLRefsType"))
		{	*type = SOAP_TYPE_ns6__CRLRefsType;
			return soap_in_ns6__CRLRefsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:CompleteRevocationRefsType"))
		{	*type = SOAP_TYPE_ns6__CompleteRevocationRefsType;
			return soap_in_ns6__CompleteRevocationRefsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:CertRefsType"))
		{	*type = SOAP_TYPE_ns6__CertRefsType;
			return soap_in_ns6__CertRefsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:CompleteCertificateRefsType"))
		{	*type = SOAP_TYPE_ns6__CompleteCertificateRefsType;
			return soap_in_ns6__CompleteCertificateRefsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:SignatureTimeStampType"))
		{	*type = SOAP_TYPE_ns6__SignatureTimeStampType;
			return soap_in_ns6__SignatureTimeStampType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:CounterSignatureType"))
		{	*type = SOAP_TYPE_ns6__CounterSignatureType;
			return soap_in_ns6__CounterSignatureType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:UnsignedSignaturePropertiesType"))
		{	*type = SOAP_TYPE_ns6__UnsignedSignaturePropertiesType;
			return soap_in_ns6__UnsignedSignaturePropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:UnsignedPropertiesType"))
		{	*type = SOAP_TYPE_ns6__UnsignedPropertiesType;
			return soap_in_ns6__UnsignedPropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ClaimedRoleType"))
		{	*type = SOAP_TYPE_ns6__ClaimedRoleType;
			return soap_in_ns6__ClaimedRoleType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ClaimedRolesListType"))
		{	*type = SOAP_TYPE_ns6__ClaimedRolesListType;
			return soap_in_ns6__ClaimedRolesListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:SignerRoleType"))
		{	*type = SOAP_TYPE_ns6__SignerRoleType;
			return soap_in_ns6__SignerRoleType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:IssuerSerialType"))
		{	*type = SOAP_TYPE_ns6__IssuerSerialType;
			return soap_in_ns6__IssuerSerialType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:CertDigestType"))
		{	*type = SOAP_TYPE_ns6__CertDigestType;
			return soap_in_ns6__CertDigestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:CertType"))
		{	*type = SOAP_TYPE_ns6__CertType;
			return soap_in_ns6__CertType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:SigningCertificateType"))
		{	*type = SOAP_TYPE_ns6__SigningCertificateType;
			return soap_in_ns6__SigningCertificateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:SignedSignaturePropertiesType"))
		{	*type = SOAP_TYPE_ns6__SignedSignaturePropertiesType;
			return soap_in_ns6__SignedSignaturePropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:SignedPropertiesType"))
		{	*type = SOAP_TYPE_ns6__SignedPropertiesType;
			return soap_in_ns6__SignedPropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:QualifyingPropertiesType"))
		{	*type = SOAP_TYPE_ns6__QualifyingPropertiesType;
			return soap_in_ns6__QualifyingPropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ResponseCodeStatusType"))
		{	*type = SOAP_TYPE_ns3__ResponseCodeStatusType;
			return soap_in_ns3__ResponseCodeStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:SubAttributeType"))
		{	*type = SOAP_TYPE_ns3__SubAttributeType;
			return soap_in_ns3__SubAttributeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:SubAttributeListType"))
		{	*type = SOAP_TYPE_ns3__SubAttributeListType;
			return soap_in_ns3__SubAttributeListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:LegalActListType"))
		{	*type = SOAP_TYPE_ns3__LegalActListType;
			return soap_in_ns3__LegalActListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:MainAttributeType"))
		{	*type = SOAP_TYPE_ns3__MainAttributeType;
			return soap_in_ns3__MainAttributeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ExtraIDType"))
		{	*type = SOAP_TYPE_ns3__ExtraIDType;
			return soap_in_ns3__ExtraIDType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ExtraIDListType"))
		{	*type = SOAP_TYPE_ns3__ExtraIDListType;
			return soap_in_ns3__ExtraIDListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:PersonalDataType"))
		{	*type = SOAP_TYPE_ns3__PersonalDataType;
			return soap_in_ns3__PersonalDataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:AttributeSupplierType"))
		{	*type = SOAP_TYPE_ns3__AttributeSupplierType;
			return soap_in_ns3__AttributeSupplierType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:AttributeType"))
		{	*type = SOAP_TYPE_ns3__AttributeType;
			return soap_in_ns3__AttributeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SignatureValueType"))
		{	*type = SOAP_TYPE_ns5__SignatureValueType;
			return soap_in_ns5__SignatureValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:DigestValueType"))
		{	*type = SOAP_TYPE_ns5__DigestValueType;
			return soap_in_ns5__DigestValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:X509CertificateType"))
		{	*type = SOAP_TYPE_ns5__X509CertificateType;
			return soap_in_ns5__X509CertificateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ObjectType"))
		{	*type = SOAP_TYPE_ns5__ObjectType;
			return soap_in_ns5__ObjectType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:X509DataType"))
		{	*type = SOAP_TYPE_ns5__X509DataType;
			return soap_in_ns5__X509DataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:KeyInfoType"))
		{	*type = SOAP_TYPE_ns5__KeyInfoType;
			return soap_in_ns5__KeyInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:DigestMethodType"))
		{	*type = SOAP_TYPE_ns5__DigestMethodType;
			return soap_in_ns5__DigestMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:TransformType"))
		{	*type = SOAP_TYPE_ns5__TransformType;
			return soap_in_ns5__TransformType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:TransformsType"))
		{	*type = SOAP_TYPE_ns5__TransformsType;
			return soap_in_ns5__TransformsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ReferenceType"))
		{	*type = SOAP_TYPE_ns5__ReferenceType;
			return soap_in_ns5__ReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SignatureMethodType"))
		{	*type = SOAP_TYPE_ns5__SignatureMethodType;
			return soap_in_ns5__SignatureMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:CanonicalizationMethodType"))
		{	*type = SOAP_TYPE_ns5__CanonicalizationMethodType;
			return soap_in_ns5__CanonicalizationMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SignedInfoType"))
		{	*type = SOAP_TYPE_ns5__SignedInfoType;
			return soap_in_ns5__SignedInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SignatureType"))
		{	*type = SOAP_TYPE_ns5__SignatureType;
			return soap_in_ns5__SignatureType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ResponseResult"))
		{	*type = SOAP_TYPE_ns2__ResponseResult;
			return soap_in_ns2__ResponseResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:UnsignedAttributesBasicType"))
		{	*type = SOAP_TYPE_ns2__UnsignedAttributesBasicType;
			return soap_in_ns2__UnsignedAttributesBasicType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SignedAttributesType"))
		{	*type = SOAP_TYPE_ns2__SignedAttributesType;
			return soap_in_ns2__SignedAttributesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:UnsignedAttributesType"))
		{	*type = SOAP_TYPE_ns2__UnsignedAttributesType;
			return soap_in_ns2__UnsignedAttributesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AttributesType"))
		{	*type = SOAP_TYPE_ns2__AttributesType;
			return soap_in_ns2__AttributesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:UnsignedAttributeResponseType"))
		{	*type = SOAP_TYPE_ns2__UnsignedAttributeResponseType;
			return soap_in_ns2__UnsignedAttributeResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SingleAttributeResponseType"))
		{	*type = SOAP_TYPE_ns2__SingleAttributeResponseType;
			return soap_in_ns2__SingleAttributeResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AttributeResponseType"))
		{	*type = SOAP_TYPE_ns2__AttributeResponseType;
			return soap_in_ns2__AttributeResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AttributeSupplierListType"))
		{	*type = SOAP_TYPE_ns2__AttributeSupplierListType;
			return soap_in_ns2__AttributeSupplierListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PSAAttributeRequestType"))
		{	*type = SOAP_TYPE_ns2__PSAAttributeRequestType;
			return soap_in_ns2__PSAAttributeRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SingleAttributeRequestType"))
		{	*type = SOAP_TYPE_ns2__SingleAttributeRequestType;
			return soap_in_ns2__SingleAttributeRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AttributeRequestType"))
		{	*type = SOAP_TYPE_ns2__AttributeRequestType;
			return soap_in_ns2__AttributeRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:integer"))
		{	*type = SOAP_TYPE_xsd__integer;
			return soap_in_xsd__integer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:date"))
		{	*type = SOAP_TYPE_xsd__date;
			return soap_in_xsd__date(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI;
			return soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:ID"))
		{	*type = SOAP_TYPE_xsd__ID;
			return soap_in_xsd__ID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ProducedAtType"))
		{	*type = SOAP_TYPE_ns6__ProducedAtType;
			return soap_in_ns6__ProducedAtType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:IssueTimeType"))
		{	*type = SOAP_TYPE_ns6__IssueTimeType;
			return soap_in_ns6__IssueTimeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:SigningTimeType"))
		{	*type = SOAP_TYPE_ns6__SigningTimeType;
			return soap_in_ns6__SigningTimeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_dateTime;
			return soap_in_dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:FaultSubcodeValues"))
		{	*type = SOAP_TYPE_wsa__FaultSubcodeValues;
			return soap_in_wsa__FaultSubcodeValues(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:RelationshipTypeValues"))
		{	*type = SOAP_TYPE_wsa__RelationshipTypeValues;
			return soap_in_wsa__RelationshipTypeValues(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:Relationship"))
		{	*type = SOAP_TYPE_wsa__Relationship;
			return soap_in_wsa__Relationship(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ServiceNameType"))
		{	*type = SOAP_TYPE_wsa__ServiceNameType;
			return soap_in_wsa__ServiceNameType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ReferenceParametersType"))
		{	*type = SOAP_TYPE_wsa__ReferenceParametersType;
			return soap_in_wsa__ReferenceParametersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ReferencePropertiesType"))
		{	*type = SOAP_TYPE_wsa__ReferencePropertiesType;
			return soap_in_wsa__ReferencePropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:EndpointReferenceType"))
		{	*type = SOAP_TYPE_wsa__EndpointReferenceType;
			return soap_in_wsa__EndpointReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "wsa:ReplyAfter"))
		{	*type = SOAP_TYPE__wsa__ReplyAfter;
			return soap_in__wsa__ReplyAfter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:SigningTime"))
		{	*type = SOAP_TYPE__ns6__SigningTime;
			return soap_in__ns6__SigningTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns9:AttributeSupplierResponse"))
		{	*type = SOAP_TYPE__ns9__AttributeSupplierResponse;
			return soap_in__ns9__AttributeSupplierResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SVG"))
		{	*type = SOAP_TYPE__ns7__SVG;
			return soap_in__ns7__SVG(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SVGList"))
		{	*type = SOAP_TYPE__ns7__SVGList;
			return soap_in__ns7__SVGList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ArchiveTimeStamp"))
		{	*type = SOAP_TYPE__ns6__ArchiveTimeStamp;
			return soap_in__ns6__ArchiveTimeStamp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:EncapsulatedOCSPValue"))
		{	*type = SOAP_TYPE__ns6__EncapsulatedOCSPValue;
			return soap_in__ns6__EncapsulatedOCSPValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:OCSPValues"))
		{	*type = SOAP_TYPE__ns6__OCSPValues;
			return soap_in__ns6__OCSPValues(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:EncapsulatedCRLValue"))
		{	*type = SOAP_TYPE__ns6__EncapsulatedCRLValue;
			return soap_in__ns6__EncapsulatedCRLValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:CRLValues"))
		{	*type = SOAP_TYPE__ns6__CRLValues;
			return soap_in__ns6__CRLValues(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:RevocationValues"))
		{	*type = SOAP_TYPE__ns6__RevocationValues;
			return soap_in__ns6__RevocationValues(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:EncapsulatedX509Certificate"))
		{	*type = SOAP_TYPE__ns6__EncapsulatedX509Certificate;
			return soap_in__ns6__EncapsulatedX509Certificate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:CertificateValues"))
		{	*type = SOAP_TYPE__ns6__CertificateValues;
			return soap_in__ns6__CertificateValues(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:SigAndRefsTimeStamp"))
		{	*type = SOAP_TYPE__ns6__SigAndRefsTimeStamp;
			return soap_in__ns6__SigAndRefsTimeStamp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ResponderID"))
		{	*type = SOAP_TYPE__ns6__ResponderID;
			return soap_in__ns6__ResponderID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:OCSPIdentifier"))
		{	*type = SOAP_TYPE__ns6__OCSPIdentifier;
			return soap_in__ns6__OCSPIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:OCSPRef"))
		{	*type = SOAP_TYPE__ns6__OCSPRef;
			return soap_in__ns6__OCSPRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:OCSPRefs"))
		{	*type = SOAP_TYPE__ns6__OCSPRefs;
			return soap_in__ns6__OCSPRefs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:CRLIdentifier"))
		{	*type = SOAP_TYPE__ns6__CRLIdentifier;
			return soap_in__ns6__CRLIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:DigestAlgAndValue"))
		{	*type = SOAP_TYPE__ns6__DigestAlgAndValue;
			return soap_in__ns6__DigestAlgAndValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:CRLRef"))
		{	*type = SOAP_TYPE__ns6__CRLRef;
			return soap_in__ns6__CRLRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:CRLRefs"))
		{	*type = SOAP_TYPE__ns6__CRLRefs;
			return soap_in__ns6__CRLRefs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:CompleteRevocationRefs"))
		{	*type = SOAP_TYPE__ns6__CompleteRevocationRefs;
			return soap_in__ns6__CompleteRevocationRefs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:CertRefs"))
		{	*type = SOAP_TYPE__ns6__CertRefs;
			return soap_in__ns6__CertRefs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:CompleteCertificateRefs"))
		{	*type = SOAP_TYPE__ns6__CompleteCertificateRefs;
			return soap_in__ns6__CompleteCertificateRefs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:EncapsulatedTimeStamp"))
		{	*type = SOAP_TYPE__ns6__EncapsulatedTimeStamp;
			return soap_in__ns6__EncapsulatedTimeStamp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:SignatureTimeStamp"))
		{	*type = SOAP_TYPE__ns6__SignatureTimeStamp;
			return soap_in__ns6__SignatureTimeStamp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:CounterSignature"))
		{	*type = SOAP_TYPE__ns6__CounterSignature;
			return soap_in__ns6__CounterSignature(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:UnsignedSignatureProperties"))
		{	*type = SOAP_TYPE__ns6__UnsignedSignatureProperties;
			return soap_in__ns6__UnsignedSignatureProperties(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:UnsignedProperties"))
		{	*type = SOAP_TYPE__ns6__UnsignedProperties;
			return soap_in__ns6__UnsignedProperties(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ClaimedRole"))
		{	*type = SOAP_TYPE__ns6__ClaimedRole;
			return soap_in__ns6__ClaimedRole(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ClaimedRoles"))
		{	*type = SOAP_TYPE__ns6__ClaimedRoles;
			return soap_in__ns6__ClaimedRoles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:SignerRole"))
		{	*type = SOAP_TYPE__ns6__SignerRole;
			return soap_in__ns6__SignerRole(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:IssuerSerial"))
		{	*type = SOAP_TYPE__ns6__IssuerSerial;
			return soap_in__ns6__IssuerSerial(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:CertDigest"))
		{	*type = SOAP_TYPE__ns6__CertDigest;
			return soap_in__ns6__CertDigest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:Cert"))
		{	*type = SOAP_TYPE__ns6__Cert;
			return soap_in__ns6__Cert(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:SigningCertificate"))
		{	*type = SOAP_TYPE__ns6__SigningCertificate;
			return soap_in__ns6__SigningCertificate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:SignedSignatureProperties"))
		{	*type = SOAP_TYPE__ns6__SignedSignatureProperties;
			return soap_in__ns6__SignedSignatureProperties(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:SignedProperties"))
		{	*type = SOAP_TYPE__ns6__SignedProperties;
			return soap_in__ns6__SignedProperties(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:QualifyingProperties"))
		{	*type = SOAP_TYPE__ns6__QualifyingProperties;
			return soap_in__ns6__QualifyingProperties(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:SignatureAttribute"))
		{	*type = SOAP_TYPE__ns3__SignatureAttribute;
			return soap_in__ns3__SignatureAttribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:Attribute"))
		{	*type = SOAP_TYPE__ns3__Attribute;
			return soap_in__ns3__Attribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:X509SerialNumber"))
		{	*type = SOAP_TYPE__ns5__X509SerialNumber;
			return soap_in__ns5__X509SerialNumber(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:X509IssuerName"))
		{	*type = SOAP_TYPE__ns5__X509IssuerName;
			return soap_in__ns5__X509IssuerName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SignatureValue"))
		{	*type = SOAP_TYPE__ns5__SignatureValue;
			return soap_in__ns5__SignatureValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:DigestValue"))
		{	*type = SOAP_TYPE__ns5__DigestValue;
			return soap_in__ns5__DigestValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:X509Certificate"))
		{	*type = SOAP_TYPE__ns5__X509Certificate;
			return soap_in__ns5__X509Certificate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:Object"))
		{	*type = SOAP_TYPE__ns5__Object;
			return soap_in__ns5__Object(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:X509Data"))
		{	*type = SOAP_TYPE__ns5__X509Data;
			return soap_in__ns5__X509Data(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:KeyInfo"))
		{	*type = SOAP_TYPE__ns5__KeyInfo;
			return soap_in__ns5__KeyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:DigestMethod"))
		{	*type = SOAP_TYPE__ns5__DigestMethod;
			return soap_in__ns5__DigestMethod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:Transform"))
		{	*type = SOAP_TYPE__ns5__Transform;
			return soap_in__ns5__Transform(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:Transforms"))
		{	*type = SOAP_TYPE__ns5__Transforms;
			return soap_in__ns5__Transforms(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:Reference"))
		{	*type = SOAP_TYPE__ns5__Reference;
			return soap_in__ns5__Reference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SignatureMethod"))
		{	*type = SOAP_TYPE__ns5__SignatureMethod;
			return soap_in__ns5__SignatureMethod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:CanonicalizationMethod"))
		{	*type = SOAP_TYPE__ns5__CanonicalizationMethod;
			return soap_in__ns5__CanonicalizationMethod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SignedInfo"))
		{	*type = SOAP_TYPE__ns5__SignedInfo;
			return soap_in__ns5__SignedInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:Signature"))
		{	*type = SOAP_TYPE__ns5__Signature;
			return soap_in__ns5__Signature(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SingleAttributeResponse"))
		{	*type = SOAP_TYPE__ns2__SingleAttributeResponse;
			return soap_in__ns2__SingleAttributeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PSAAttributeRequest"))
		{	*type = SOAP_TYPE__ns2__PSAAttributeRequest;
			return soap_in__ns2__PSAAttributeRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AttributeResponse"))
		{	*type = SOAP_TYPE__ns2__AttributeResponse;
			return soap_in__ns2__AttributeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AttributeRequest"))
		{	*type = SOAP_TYPE__ns2__AttributeRequest;
			return soap_in__ns2__AttributeRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SignatureResponse"))
		{	*type = SOAP_TYPE__ns1__SignatureResponse;
			return soap_in__ns1__SignatureResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SignatureRequest"))
		{	*type = SOAP_TYPE__ns1__SignatureRequest;
			return soap_in__ns1__SignatureRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AuthorizationResponse"))
		{	*type = SOAP_TYPE__ns1__AuthorizationResponse;
			return soap_in__ns1__AuthorizationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AuthorizationRequest"))
		{	*type = SOAP_TYPE__ns1__AuthorizationRequest;
			return soap_in__ns1__AuthorizationRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:FaultTo"))
		{	*type = SOAP_TYPE__wsa__FaultTo;
			return soap_in__wsa__FaultTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ReplyTo"))
		{	*type = SOAP_TYPE__wsa__ReplyTo;
			return soap_in__wsa__ReplyTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:From"))
		{	*type = SOAP_TYPE__wsa__From;
			return soap_in__wsa__From(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:RelatesTo"))
		{	*type = SOAP_TYPE__wsa__RelatesTo;
			return soap_in__wsa__RelatesTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:EndpointReference"))
		{	*type = SOAP_TYPE__wsa__EndpointReference;
			return soap_in__wsa__EndpointReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:Action"))
		{	char **s;
			*type = SOAP_TYPE__wsa__Action;
			s = soap_in__wsa__Action(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa:To"))
		{	char **s;
			*type = SOAP_TYPE__wsa__To;
			s = soap_in__wsa__To(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa:MessageID"))
		{	char **s;
			*type = SOAP_TYPE__wsa__MessageID;
			s = soap_in__wsa__MessageID(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				if (soap_ignore(soap) || soap_element_end_in(soap, NULL))
					return soap->error;
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__wsa__ReplyAfter:
		return soap_out__wsa__ReplyAfter(soap, "wsa:ReplyAfter", id, (const unsigned int *)ptr, "");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE__ns6__SigningTime:
		return soap_out__ns6__SigningTime(soap, "ns6:SigningTime", id, (const time_t *)ptr, "");
	case SOAP_TYPE_ns6__ProducedAtType:
		return soap_out_ns6__ProducedAtType(soap, tag, id, (const time_t *)ptr, "ns6:ProducedAtType");
	case SOAP_TYPE_ns6__IssueTimeType:
		return soap_out_ns6__IssueTimeType(soap, tag, id, (const time_t *)ptr, "ns6:IssueTimeType");
	case SOAP_TYPE_ns6__SigningTimeType:
		return soap_out_ns6__SigningTimeType(soap, tag, id, (const time_t *)ptr, "ns6:SigningTimeType");
	case SOAP_TYPE_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_wsa__FaultSubcodeValues:
		return soap_out_wsa__FaultSubcodeValues(soap, tag, id, (const enum wsa__FaultSubcodeValues *)ptr, "wsa:FaultSubcodeValues");
	case SOAP_TYPE_wsa__RelationshipTypeValues:
		return soap_out_wsa__RelationshipTypeValues(soap, tag, id, (const enum wsa__RelationshipTypeValues *)ptr, "wsa:RelationshipTypeValues");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE__ns9__AttributeSupplierResponse:
		return soap_out__ns9__AttributeSupplierResponse(soap, "ns9:AttributeSupplierResponse", id, (const ns9__AttributeSupplierResponseType *)ptr, "");
	case SOAP_TYPE__ns7__SVG:
		return soap_out__ns7__SVG(soap, "ns7:SVG", id, (const xsd__base64Binary *)ptr, "");
	case SOAP_TYPE__ns7__SVGList:
		return soap_out__ns7__SVGList(soap, "ns7:SVGList", id, (const ns7__SVGListType *)ptr, "");
	case SOAP_TYPE__ns6__ArchiveTimeStamp:
		return soap_out__ns6__ArchiveTimeStamp(soap, "ns6:ArchiveTimeStamp", id, (const ns6__ArchiveTimeStampType *)ptr, "");
	case SOAP_TYPE__ns6__EncapsulatedOCSPValue:
		return soap_out__ns6__EncapsulatedOCSPValue(soap, "ns6:EncapsulatedOCSPValue", id, (const ns6__EncapsulatedOCSPValueType *)ptr, "");
	case SOAP_TYPE__ns6__OCSPValues:
		return soap_out__ns6__OCSPValues(soap, "ns6:OCSPValues", id, (const ns6__OCSPValuesType *)ptr, "");
	case SOAP_TYPE__ns6__EncapsulatedCRLValue:
		return soap_out__ns6__EncapsulatedCRLValue(soap, "ns6:EncapsulatedCRLValue", id, (const ns6__EncapsulatedCRLValueType *)ptr, "");
	case SOAP_TYPE__ns6__CRLValues:
		return soap_out__ns6__CRLValues(soap, "ns6:CRLValues", id, (const ns6__CRLValuesType *)ptr, "");
	case SOAP_TYPE__ns6__RevocationValues:
		return soap_out__ns6__RevocationValues(soap, "ns6:RevocationValues", id, (const ns6__RevocationValuesType *)ptr, "");
	case SOAP_TYPE__ns6__EncapsulatedX509Certificate:
		return soap_out__ns6__EncapsulatedX509Certificate(soap, "ns6:EncapsulatedX509Certificate", id, (const ns6__EncapsulatedX509CertificateType *)ptr, "");
	case SOAP_TYPE__ns6__CertificateValues:
		return soap_out__ns6__CertificateValues(soap, "ns6:CertificateValues", id, (const ns6__CertificateValuesType *)ptr, "");
	case SOAP_TYPE__ns6__SigAndRefsTimeStamp:
		return soap_out__ns6__SigAndRefsTimeStamp(soap, "ns6:SigAndRefsTimeStamp", id, (const ns6__SigAndRefsTimeStampType *)ptr, "");
	case SOAP_TYPE__ns6__ResponderID:
		return soap_out__ns6__ResponderID(soap, "ns6:ResponderID", id, (const ns6__ResponderIDType *)ptr, "");
	case SOAP_TYPE__ns6__OCSPIdentifier:
		return soap_out__ns6__OCSPIdentifier(soap, "ns6:OCSPIdentifier", id, (const ns6__OCSPIdentifierType *)ptr, "");
	case SOAP_TYPE__ns6__OCSPRef:
		return soap_out__ns6__OCSPRef(soap, "ns6:OCSPRef", id, (const ns6__OCSPRefType *)ptr, "");
	case SOAP_TYPE__ns6__OCSPRefs:
		return soap_out__ns6__OCSPRefs(soap, "ns6:OCSPRefs", id, (const ns6__OCSPRefsType *)ptr, "");
	case SOAP_TYPE__ns6__CRLIdentifier:
		return soap_out__ns6__CRLIdentifier(soap, "ns6:CRLIdentifier", id, (const ns6__CRLIdentifierType *)ptr, "");
	case SOAP_TYPE__ns6__DigestAlgAndValue:
		return soap_out__ns6__DigestAlgAndValue(soap, "ns6:DigestAlgAndValue", id, (const ns6__DigestAlgAndValueType *)ptr, "");
	case SOAP_TYPE__ns6__CRLRef:
		return soap_out__ns6__CRLRef(soap, "ns6:CRLRef", id, (const ns6__CRLRefType *)ptr, "");
	case SOAP_TYPE__ns6__CRLRefs:
		return soap_out__ns6__CRLRefs(soap, "ns6:CRLRefs", id, (const ns6__CRLRefsType *)ptr, "");
	case SOAP_TYPE__ns6__CompleteRevocationRefs:
		return soap_out__ns6__CompleteRevocationRefs(soap, "ns6:CompleteRevocationRefs", id, (const ns6__CompleteRevocationRefsType *)ptr, "");
	case SOAP_TYPE__ns6__CertRefs:
		return soap_out__ns6__CertRefs(soap, "ns6:CertRefs", id, (const ns6__CertRefsType *)ptr, "");
	case SOAP_TYPE__ns6__CompleteCertificateRefs:
		return soap_out__ns6__CompleteCertificateRefs(soap, "ns6:CompleteCertificateRefs", id, (const ns6__CompleteCertificateRefsType *)ptr, "");
	case SOAP_TYPE__ns6__EncapsulatedTimeStamp:
		return soap_out__ns6__EncapsulatedTimeStamp(soap, "ns6:EncapsulatedTimeStamp", id, (const xsd__base64Binary *)ptr, "");
	case SOAP_TYPE__ns6__SignatureTimeStamp:
		return soap_out__ns6__SignatureTimeStamp(soap, "ns6:SignatureTimeStamp", id, (const ns6__SignatureTimeStampType *)ptr, "");
	case SOAP_TYPE__ns6__CounterSignature:
		return soap_out__ns6__CounterSignature(soap, "ns6:CounterSignature", id, (const ns6__CounterSignatureType *)ptr, "");
	case SOAP_TYPE__ns6__UnsignedSignatureProperties:
		return soap_out__ns6__UnsignedSignatureProperties(soap, "ns6:UnsignedSignatureProperties", id, (const ns6__UnsignedSignaturePropertiesType *)ptr, "");
	case SOAP_TYPE__ns6__UnsignedProperties:
		return soap_out__ns6__UnsignedProperties(soap, "ns6:UnsignedProperties", id, (const ns6__UnsignedPropertiesType *)ptr, "");
	case SOAP_TYPE__ns6__ClaimedRole:
		return soap_out__ns6__ClaimedRole(soap, "ns6:ClaimedRole", id, (const ns6__ClaimedRoleType *)ptr, "");
	case SOAP_TYPE__ns6__ClaimedRoles:
		return soap_out__ns6__ClaimedRoles(soap, "ns6:ClaimedRoles", id, (const ns6__ClaimedRolesListType *)ptr, "");
	case SOAP_TYPE__ns6__SignerRole:
		return soap_out__ns6__SignerRole(soap, "ns6:SignerRole", id, (const ns6__SignerRoleType *)ptr, "");
	case SOAP_TYPE__ns6__IssuerSerial:
		return soap_out__ns6__IssuerSerial(soap, "ns6:IssuerSerial", id, (const ns6__IssuerSerialType *)ptr, "");
	case SOAP_TYPE__ns6__CertDigest:
		return soap_out__ns6__CertDigest(soap, "ns6:CertDigest", id, (const ns6__CertDigestType *)ptr, "");
	case SOAP_TYPE__ns6__Cert:
		return soap_out__ns6__Cert(soap, "ns6:Cert", id, (const ns6__CertType *)ptr, "");
	case SOAP_TYPE__ns6__SigningCertificate:
		return soap_out__ns6__SigningCertificate(soap, "ns6:SigningCertificate", id, (const ns6__SigningCertificateType *)ptr, "");
	case SOAP_TYPE__ns6__SignedSignatureProperties:
		return soap_out__ns6__SignedSignatureProperties(soap, "ns6:SignedSignatureProperties", id, (const ns6__SignedSignaturePropertiesType *)ptr, "");
	case SOAP_TYPE__ns6__SignedProperties:
		return soap_out__ns6__SignedProperties(soap, "ns6:SignedProperties", id, (const ns6__SignedPropertiesType *)ptr, "");
	case SOAP_TYPE__ns6__QualifyingProperties:
		return soap_out__ns6__QualifyingProperties(soap, "ns6:QualifyingProperties", id, (const ns6__QualifyingPropertiesType *)ptr, "");
	case SOAP_TYPE__ns3__SignatureAttribute:
		return soap_out__ns3__SignatureAttribute(soap, "ns3:SignatureAttribute", id, (const ns5__SignatureType *)ptr, "");
	case SOAP_TYPE__ns3__Attribute:
		return soap_out__ns3__Attribute(soap, "ns3:Attribute", id, (const ns3__AttributeType *)ptr, "");
	case SOAP_TYPE__ns5__X509SerialNumber:
		return soap_out__ns5__X509SerialNumber(soap, "ns5:X509SerialNumber", id, (const std::string *)ptr, "");
	case SOAP_TYPE__ns5__X509IssuerName:
		return soap_out__ns5__X509IssuerName(soap, "ns5:X509IssuerName", id, (const std::string *)ptr, "");
	case SOAP_TYPE__ns5__SignatureValue:
		return soap_out__ns5__SignatureValue(soap, "ns5:SignatureValue", id, (const ns5__SignatureValueType *)ptr, "");
	case SOAP_TYPE__ns5__DigestValue:
		return soap_out__ns5__DigestValue(soap, "ns5:DigestValue", id, (const ns5__DigestValueType *)ptr, "");
	case SOAP_TYPE__ns5__X509Certificate:
		return soap_out__ns5__X509Certificate(soap, "ns5:X509Certificate", id, (const ns5__X509CertificateType *)ptr, "");
	case SOAP_TYPE__ns5__Object:
		return soap_out__ns5__Object(soap, "ns5:Object", id, (const ns5__ObjectType *)ptr, "");
	case SOAP_TYPE__ns5__X509Data:
		return soap_out__ns5__X509Data(soap, "ns5:X509Data", id, (const ns5__X509DataType *)ptr, "");
	case SOAP_TYPE__ns5__KeyInfo:
		return soap_out__ns5__KeyInfo(soap, "ns5:KeyInfo", id, (const ns5__KeyInfoType *)ptr, "");
	case SOAP_TYPE__ns5__DigestMethod:
		return soap_out__ns5__DigestMethod(soap, "ns5:DigestMethod", id, (const ns5__DigestMethodType *)ptr, "");
	case SOAP_TYPE__ns5__Transform:
		return soap_out__ns5__Transform(soap, "ns5:Transform", id, (const ns5__TransformType *)ptr, "");
	case SOAP_TYPE__ns5__Transforms:
		return soap_out__ns5__Transforms(soap, "ns5:Transforms", id, (const ns5__TransformsType *)ptr, "");
	case SOAP_TYPE__ns5__Reference:
		return soap_out__ns5__Reference(soap, "ns5:Reference", id, (const ns5__ReferenceType *)ptr, "");
	case SOAP_TYPE__ns5__SignatureMethod:
		return soap_out__ns5__SignatureMethod(soap, "ns5:SignatureMethod", id, (const ns5__SignatureMethodType *)ptr, "");
	case SOAP_TYPE__ns5__CanonicalizationMethod:
		return soap_out__ns5__CanonicalizationMethod(soap, "ns5:CanonicalizationMethod", id, (const ns5__CanonicalizationMethodType *)ptr, "");
	case SOAP_TYPE__ns5__SignedInfo:
		return soap_out__ns5__SignedInfo(soap, "ns5:SignedInfo", id, (const ns5__SignedInfoType *)ptr, "");
	case SOAP_TYPE__ns5__Signature:
		return soap_out__ns5__Signature(soap, "ns5:Signature", id, (const ns5__SignatureType *)ptr, "");
	case SOAP_TYPE__ns2__SingleAttributeResponse:
		return soap_out__ns2__SingleAttributeResponse(soap, "ns2:SingleAttributeResponse", id, (const ns2__SingleAttributeResponseType *)ptr, "");
	case SOAP_TYPE__ns2__PSAAttributeRequest:
		return soap_out__ns2__PSAAttributeRequest(soap, "ns2:PSAAttributeRequest", id, (const ns2__PSAAttributeRequestType *)ptr, "");
	case SOAP_TYPE__ns2__AttributeResponse:
		return soap_out__ns2__AttributeResponse(soap, "ns2:AttributeResponse", id, (const ns2__AttributeResponseType *)ptr, "");
	case SOAP_TYPE__ns2__AttributeRequest:
		return soap_out__ns2__AttributeRequest(soap, "ns2:AttributeRequest", id, (const ns2__AttributeRequestType *)ptr, "");
	case SOAP_TYPE_ns7__SVGType:
		return soap_out_ns7__SVGType(soap, tag, id, (const xsd__base64Binary *)ptr, "ns7:SVGType");
	case SOAP_TYPE_ns6__ByNameType:
		return soap_out_ns6__ByNameType(soap, tag, id, (const std::string *)ptr, "ns6:ByNameType");
	case SOAP_TYPE_ns6__NumberType:
		return soap_out_ns6__NumberType(soap, tag, id, (const std::string *)ptr, "ns6:NumberType");
	case SOAP_TYPE_ns6__IssuerType:
		return soap_out_ns6__IssuerType(soap, tag, id, (const std::string *)ptr, "ns6:IssuerType");
	case SOAP_TYPE_ns6__EncapsulatedTimeStampType:
		return soap_out_ns6__EncapsulatedTimeStampType(soap, tag, id, (const xsd__base64Binary *)ptr, "ns6:EncapsulatedTimeStampType");
	case SOAP_TYPE_ns4__ResponseCodeMessage:
		return soap_out_ns4__ResponseCodeMessage(soap, tag, id, (const std::string *)ptr, "ns4:ResponseCodeMessage");
	case SOAP_TYPE_ns4__ResponseCodeType:
		return soap_out_ns4__ResponseCodeType(soap, tag, id, (const std::string *)ptr, "ns4:ResponseCodeType");
	case SOAP_TYPE_ns4__DescriptionType:
		return soap_out_ns4__DescriptionType(soap, tag, id, (const std::string *)ptr, "ns4:DescriptionType");
	case SOAP_TYPE_ns4__SubAttributeValueType:
		return soap_out_ns4__SubAttributeValueType(soap, tag, id, (const std::string *)ptr, "ns4:SubAttributeValueType");
	case SOAP_TYPE_ns4__LegalActType:
		return soap_out_ns4__LegalActType(soap, tag, id, (const std::string *)ptr, "ns4:LegalActType");
	case SOAP_TYPE_ns4__AttributeIDType:
		return soap_out_ns4__AttributeIDType(soap, tag, id, (const std::string *)ptr, "ns4:AttributeIDType");
	case SOAP_TYPE_ns4__ExtraIDValueType:
		return soap_out_ns4__ExtraIDValueType(soap, tag, id, (const std::string *)ptr, "ns4:ExtraIDValueType");
	case SOAP_TYPE_ns4__CompanyNameType:
		return soap_out_ns4__CompanyNameType(soap, tag, id, (const std::string *)ptr, "ns4:CompanyNameType");
	case SOAP_TYPE_ns4__NIPCType:
		return soap_out_ns4__NIPCType(soap, tag, id, (const std::string *)ptr, "ns4:NIPCType");
	case SOAP_TYPE_ns4__NICType:
		return soap_out_ns4__NICType(soap, tag, id, (const std::string *)ptr, "ns4:NICType");
	case SOAP_TYPE_ns4__DateType:
		return soap_out_ns4__DateType(soap, tag, id, (const std::string *)ptr, "ns4:DateType");
	case SOAP_TYPE_ns4__ValidityType:
		return soap_out_ns4__ValidityType(soap, tag, id, (const std::string *)ptr, "ns4:ValidityType");
	case SOAP_TYPE_ns4__NameType:
		return soap_out_ns4__NameType(soap, tag, id, (const std::string *)ptr, "ns4:NameType");
	case SOAP_TYPE_ns4__ProcessIDType:
		return soap_out_ns4__ProcessIDType(soap, tag, id, (const std::string *)ptr, "ns4:ProcessIDType");
	case SOAP_TYPE_ns5__X509SerialNumberType:
		return soap_out_ns5__X509SerialNumberType(soap, tag, id, (const std::string *)ptr, "ns5:X509SerialNumberType");
	case SOAP_TYPE_ns5__X509IssuerNameType:
		return soap_out_ns5__X509IssuerNameType(soap, tag, id, (const std::string *)ptr, "ns5:X509IssuerNameType");
	case SOAP_TYPE__ns1__SignatureResponse:
		return ((_ns1__SignatureResponse *)ptr)->soap_out(soap, "ns1:SignatureResponse", id, "");
	case SOAP_TYPE__ns1__SignatureRequest:
		return ((_ns1__SignatureRequest *)ptr)->soap_out(soap, "ns1:SignatureRequest", id, "");
	case SOAP_TYPE__ns1__AuthorizationResponse:
		return ((_ns1__AuthorizationResponse *)ptr)->soap_out(soap, "ns1:AuthorizationResponse", id, "");
	case SOAP_TYPE__ns1__AuthorizationRequest:
		return ((_ns1__AuthorizationRequest *)ptr)->soap_out(soap, "ns1:AuthorizationRequest", id, "");
	case SOAP_TYPE_ns1__TransactionType:
		return ((ns1__TransactionType *)ptr)->soap_out(soap, tag, id, "ns1:TransactionType");
	case SOAP_TYPE_ns1__TransactionTypeList:
		return ((ns1__TransactionTypeList *)ptr)->soap_out(soap, tag, id, "ns1:TransactionTypeList");
	case SOAP_TYPE_ns1__Status:
		return ((ns1__Status *)ptr)->soap_out(soap, tag, id, "ns1:Status");
	case SOAP_TYPE_ns1__SubAttributeType:
		return ((ns1__SubAttributeType *)ptr)->soap_out(soap, tag, id, "ns1:SubAttributeType");
	case SOAP_TYPE_ns1__SubAttributeListType:
		return ((ns1__SubAttributeListType *)ptr)->soap_out(soap, tag, id, "ns1:SubAttributeListType");
	case SOAP_TYPE_ns1__LegalActListType:
		return ((ns1__LegalActListType *)ptr)->soap_out(soap, tag, id, "ns1:LegalActListType");
	case SOAP_TYPE_ns1__MainAttributeType:
		return ((ns1__MainAttributeType *)ptr)->soap_out(soap, tag, id, "ns1:MainAttributeType");
	case SOAP_TYPE_ns1__AttributeSupplierType:
		return ((ns1__AttributeSupplierType *)ptr)->soap_out(soap, tag, id, "ns1:AttributeSupplierType");
	case SOAP_TYPE_ns1__AttributeType:
		return ((ns1__AttributeType *)ptr)->soap_out(soap, tag, id, "ns1:AttributeType");
	case SOAP_TYPE_ns1__AttributeListType:
		return ((ns1__AttributeListType *)ptr)->soap_out(soap, tag, id, "ns1:AttributeListType");
	case SOAP_TYPE_ns1__PersonalData:
		return ((ns1__PersonalData *)ptr)->soap_out(soap, tag, id, "ns1:PersonalData");
	case SOAP_TYPE_ns9__AttributeSupplierResponseType:
		return ((ns9__AttributeSupplierResponseType *)ptr)->soap_out(soap, tag, id, "ns9:AttributeSupplierResponseType");
	case SOAP_TYPE_ns7__SVGListType:
		return ((ns7__SVGListType *)ptr)->soap_out(soap, tag, id, "ns7:SVGListType");
	case SOAP_TYPE_ns6__ArchiveTimeStampType:
		return ((ns6__ArchiveTimeStampType *)ptr)->soap_out(soap, tag, id, "ns6:ArchiveTimeStampType");
	case SOAP_TYPE_ns6__EncapsulatedOCSPValueType:
		return ((ns6__EncapsulatedOCSPValueType *)ptr)->soap_out(soap, tag, id, "ns6:EncapsulatedOCSPValueType");
	case SOAP_TYPE_ns6__OCSPValuesType:
		return ((ns6__OCSPValuesType *)ptr)->soap_out(soap, tag, id, "ns6:OCSPValuesType");
	case SOAP_TYPE_ns6__EncapsulatedCRLValueType:
		return ((ns6__EncapsulatedCRLValueType *)ptr)->soap_out(soap, tag, id, "ns6:EncapsulatedCRLValueType");
	case SOAP_TYPE_ns6__CRLValuesType:
		return ((ns6__CRLValuesType *)ptr)->soap_out(soap, tag, id, "ns6:CRLValuesType");
	case SOAP_TYPE_ns6__RevocationValuesType:
		return ((ns6__RevocationValuesType *)ptr)->soap_out(soap, tag, id, "ns6:RevocationValuesType");
	case SOAP_TYPE_ns6__EncapsulatedX509CertificateType:
		return ((ns6__EncapsulatedX509CertificateType *)ptr)->soap_out(soap, tag, id, "ns6:EncapsulatedX509CertificateType");
	case SOAP_TYPE_ns6__CertificateValuesType:
		return ((ns6__CertificateValuesType *)ptr)->soap_out(soap, tag, id, "ns6:CertificateValuesType");
	case SOAP_TYPE_ns6__SigAndRefsTimeStampType:
		return ((ns6__SigAndRefsTimeStampType *)ptr)->soap_out(soap, tag, id, "ns6:SigAndRefsTimeStampType");
	case SOAP_TYPE_ns6__ResponderIDType:
		return ((ns6__ResponderIDType *)ptr)->soap_out(soap, tag, id, "ns6:ResponderIDType");
	case SOAP_TYPE_ns6__OCSPIdentifierType:
		return ((ns6__OCSPIdentifierType *)ptr)->soap_out(soap, tag, id, "ns6:OCSPIdentifierType");
	case SOAP_TYPE_ns6__OCSPRefType:
		return ((ns6__OCSPRefType *)ptr)->soap_out(soap, tag, id, "ns6:OCSPRefType");
	case SOAP_TYPE_ns6__OCSPRefsType:
		return ((ns6__OCSPRefsType *)ptr)->soap_out(soap, tag, id, "ns6:OCSPRefsType");
	case SOAP_TYPE_ns6__CRLIdentifierType:
		return ((ns6__CRLIdentifierType *)ptr)->soap_out(soap, tag, id, "ns6:CRLIdentifierType");
	case SOAP_TYPE_ns6__DigestAlgAndValueType:
		return ((ns6__DigestAlgAndValueType *)ptr)->soap_out(soap, tag, id, "ns6:DigestAlgAndValueType");
	case SOAP_TYPE_ns6__CRLRefType:
		return ((ns6__CRLRefType *)ptr)->soap_out(soap, tag, id, "ns6:CRLRefType");
	case SOAP_TYPE_ns6__CRLRefsType:
		return ((ns6__CRLRefsType *)ptr)->soap_out(soap, tag, id, "ns6:CRLRefsType");
	case SOAP_TYPE_ns6__CompleteRevocationRefsType:
		return ((ns6__CompleteRevocationRefsType *)ptr)->soap_out(soap, tag, id, "ns6:CompleteRevocationRefsType");
	case SOAP_TYPE_ns6__CertRefsType:
		return ((ns6__CertRefsType *)ptr)->soap_out(soap, tag, id, "ns6:CertRefsType");
	case SOAP_TYPE_ns6__CompleteCertificateRefsType:
		return ((ns6__CompleteCertificateRefsType *)ptr)->soap_out(soap, tag, id, "ns6:CompleteCertificateRefsType");
	case SOAP_TYPE_ns6__SignatureTimeStampType:
		return ((ns6__SignatureTimeStampType *)ptr)->soap_out(soap, tag, id, "ns6:SignatureTimeStampType");
	case SOAP_TYPE_ns6__CounterSignatureType:
		return ((ns6__CounterSignatureType *)ptr)->soap_out(soap, tag, id, "ns6:CounterSignatureType");
	case SOAP_TYPE_ns6__UnsignedSignaturePropertiesType:
		return ((ns6__UnsignedSignaturePropertiesType *)ptr)->soap_out(soap, tag, id, "ns6:UnsignedSignaturePropertiesType");
	case SOAP_TYPE_ns6__UnsignedPropertiesType:
		return ((ns6__UnsignedPropertiesType *)ptr)->soap_out(soap, tag, id, "ns6:UnsignedPropertiesType");
	case SOAP_TYPE_ns6__ClaimedRoleType:
		return ((ns6__ClaimedRoleType *)ptr)->soap_out(soap, tag, id, "ns6:ClaimedRoleType");
	case SOAP_TYPE_ns6__ClaimedRolesListType:
		return ((ns6__ClaimedRolesListType *)ptr)->soap_out(soap, tag, id, "ns6:ClaimedRolesListType");
	case SOAP_TYPE_ns6__SignerRoleType:
		return ((ns6__SignerRoleType *)ptr)->soap_out(soap, tag, id, "ns6:SignerRoleType");
	case SOAP_TYPE_ns6__IssuerSerialType:
		return ((ns6__IssuerSerialType *)ptr)->soap_out(soap, tag, id, "ns6:IssuerSerialType");
	case SOAP_TYPE_ns6__CertDigestType:
		return ((ns6__CertDigestType *)ptr)->soap_out(soap, tag, id, "ns6:CertDigestType");
	case SOAP_TYPE_ns6__CertType:
		return ((ns6__CertType *)ptr)->soap_out(soap, tag, id, "ns6:CertType");
	case SOAP_TYPE_ns6__SigningCertificateType:
		return ((ns6__SigningCertificateType *)ptr)->soap_out(soap, tag, id, "ns6:SigningCertificateType");
	case SOAP_TYPE_ns6__SignedSignaturePropertiesType:
		return ((ns6__SignedSignaturePropertiesType *)ptr)->soap_out(soap, tag, id, "ns6:SignedSignaturePropertiesType");
	case SOAP_TYPE_ns6__SignedPropertiesType:
		return ((ns6__SignedPropertiesType *)ptr)->soap_out(soap, tag, id, "ns6:SignedPropertiesType");
	case SOAP_TYPE_ns6__QualifyingPropertiesType:
		return ((ns6__QualifyingPropertiesType *)ptr)->soap_out(soap, tag, id, "ns6:QualifyingPropertiesType");
	case SOAP_TYPE_ns3__ResponseCodeStatusType:
		return ((ns3__ResponseCodeStatusType *)ptr)->soap_out(soap, tag, id, "ns3:ResponseCodeStatusType");
	case SOAP_TYPE_ns3__SubAttributeType:
		return ((ns3__SubAttributeType *)ptr)->soap_out(soap, tag, id, "ns3:SubAttributeType");
	case SOAP_TYPE_ns3__SubAttributeListType:
		return ((ns3__SubAttributeListType *)ptr)->soap_out(soap, tag, id, "ns3:SubAttributeListType");
	case SOAP_TYPE_ns3__LegalActListType:
		return ((ns3__LegalActListType *)ptr)->soap_out(soap, tag, id, "ns3:LegalActListType");
	case SOAP_TYPE_ns3__MainAttributeType:
		return ((ns3__MainAttributeType *)ptr)->soap_out(soap, tag, id, "ns3:MainAttributeType");
	case SOAP_TYPE_ns3__ExtraIDType:
		return ((ns3__ExtraIDType *)ptr)->soap_out(soap, tag, id, "ns3:ExtraIDType");
	case SOAP_TYPE_ns3__ExtraIDListType:
		return ((ns3__ExtraIDListType *)ptr)->soap_out(soap, tag, id, "ns3:ExtraIDListType");
	case SOAP_TYPE_ns3__PersonalDataType:
		return ((ns3__PersonalDataType *)ptr)->soap_out(soap, tag, id, "ns3:PersonalDataType");
	case SOAP_TYPE_ns3__AttributeSupplierType:
		return ((ns3__AttributeSupplierType *)ptr)->soap_out(soap, tag, id, "ns3:AttributeSupplierType");
	case SOAP_TYPE_ns3__AttributeType:
		return ((ns3__AttributeType *)ptr)->soap_out(soap, tag, id, "ns3:AttributeType");
	case SOAP_TYPE_ns5__SignatureValueType:
		return ((ns5__SignatureValueType *)ptr)->soap_out(soap, tag, id, "ns5:SignatureValueType");
	case SOAP_TYPE_ns5__DigestValueType:
		return ((ns5__DigestValueType *)ptr)->soap_out(soap, tag, id, "ns5:DigestValueType");
	case SOAP_TYPE_ns5__X509CertificateType:
		return ((ns5__X509CertificateType *)ptr)->soap_out(soap, tag, id, "ns5:X509CertificateType");
	case SOAP_TYPE_ns5__ObjectType:
		return ((ns5__ObjectType *)ptr)->soap_out(soap, tag, id, "ns5:ObjectType");
	case SOAP_TYPE_ns5__X509DataType:
		return ((ns5__X509DataType *)ptr)->soap_out(soap, tag, id, "ns5:X509DataType");
	case SOAP_TYPE_ns5__KeyInfoType:
		return ((ns5__KeyInfoType *)ptr)->soap_out(soap, tag, id, "ns5:KeyInfoType");
	case SOAP_TYPE_ns5__DigestMethodType:
		return ((ns5__DigestMethodType *)ptr)->soap_out(soap, tag, id, "ns5:DigestMethodType");
	case SOAP_TYPE_ns5__TransformType:
		return ((ns5__TransformType *)ptr)->soap_out(soap, tag, id, "ns5:TransformType");
	case SOAP_TYPE_ns5__TransformsType:
		return ((ns5__TransformsType *)ptr)->soap_out(soap, tag, id, "ns5:TransformsType");
	case SOAP_TYPE_ns5__ReferenceType:
		return ((ns5__ReferenceType *)ptr)->soap_out(soap, tag, id, "ns5:ReferenceType");
	case SOAP_TYPE_ns5__SignatureMethodType:
		return ((ns5__SignatureMethodType *)ptr)->soap_out(soap, tag, id, "ns5:SignatureMethodType");
	case SOAP_TYPE_ns5__CanonicalizationMethodType:
		return ((ns5__CanonicalizationMethodType *)ptr)->soap_out(soap, tag, id, "ns5:CanonicalizationMethodType");
	case SOAP_TYPE_ns5__SignedInfoType:
		return ((ns5__SignedInfoType *)ptr)->soap_out(soap, tag, id, "ns5:SignedInfoType");
	case SOAP_TYPE_ns5__SignatureType:
		return ((ns5__SignatureType *)ptr)->soap_out(soap, tag, id, "ns5:SignatureType");
	case SOAP_TYPE_ns2__ResponseResult:
		return ((ns2__ResponseResult *)ptr)->soap_out(soap, tag, id, "ns2:ResponseResult");
	case SOAP_TYPE_ns2__UnsignedAttributesBasicType:
		return ((ns2__UnsignedAttributesBasicType *)ptr)->soap_out(soap, tag, id, "ns2:UnsignedAttributesBasicType");
	case SOAP_TYPE_ns2__SignedAttributesType:
		return ((ns2__SignedAttributesType *)ptr)->soap_out(soap, tag, id, "ns2:SignedAttributesType");
	case SOAP_TYPE_ns2__UnsignedAttributesType:
		return ((ns2__UnsignedAttributesType *)ptr)->soap_out(soap, tag, id, "ns2:UnsignedAttributesType");
	case SOAP_TYPE_ns2__AttributesType:
		return ((ns2__AttributesType *)ptr)->soap_out(soap, tag, id, "ns2:AttributesType");
	case SOAP_TYPE_ns2__UnsignedAttributeResponseType:
		return ((ns2__UnsignedAttributeResponseType *)ptr)->soap_out(soap, tag, id, "ns2:UnsignedAttributeResponseType");
	case SOAP_TYPE_ns2__SingleAttributeResponseType:
		return ((ns2__SingleAttributeResponseType *)ptr)->soap_out(soap, tag, id, "ns2:SingleAttributeResponseType");
	case SOAP_TYPE_ns2__AttributeResponseType:
		return ((ns2__AttributeResponseType *)ptr)->soap_out(soap, tag, id, "ns2:AttributeResponseType");
	case SOAP_TYPE_ns2__AttributeSupplierListType:
		return ((ns2__AttributeSupplierListType *)ptr)->soap_out(soap, tag, id, "ns2:AttributeSupplierListType");
	case SOAP_TYPE_ns2__PSAAttributeRequestType:
		return ((ns2__PSAAttributeRequestType *)ptr)->soap_out(soap, tag, id, "ns2:PSAAttributeRequestType");
	case SOAP_TYPE_ns2__SingleAttributeRequestType:
		return ((ns2__SingleAttributeRequestType *)ptr)->soap_out(soap, tag, id, "ns2:SingleAttributeRequestType");
	case SOAP_TYPE_ns2__AttributeRequestType:
		return ((ns2__AttributeRequestType *)ptr)->soap_out(soap, tag, id, "ns2:AttributeRequestType");
	case SOAP_TYPE_xsd__integer:
		return soap_out_xsd__integer(soap, tag, id, (const std::string *)ptr, "xsd:integer");
	case SOAP_TYPE_xsd__date:
		return soap_out_xsd__date(soap, tag, id, (const std::string *)ptr, "xsd:date");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_xsd__anyURI(soap, tag, id, (const std::string *)ptr, "xsd:anyURI");
	case SOAP_TYPE_xsd__ID:
		return soap_out_xsd__ID(soap, tag, id, (const std::string *)ptr, "xsd:ID");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE__wsa__FaultTo:
		return soap_out__wsa__FaultTo(soap, "wsa:FaultTo", id, (const struct wsa__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa__ReplyTo:
		return soap_out__wsa__ReplyTo(soap, "wsa:ReplyTo", id, (const struct wsa__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa__From:
		return soap_out__wsa__From(soap, "wsa:From", id, (const struct wsa__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa__RelatesTo:
		return soap_out__wsa__RelatesTo(soap, "wsa:RelatesTo", id, (const struct wsa__Relationship *)ptr, "");
	case SOAP_TYPE__wsa__EndpointReference:
		return soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", id, (const struct wsa__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE_wsa__Relationship:
		return soap_out_wsa__Relationship(soap, tag, id, (const struct wsa__Relationship *)ptr, "wsa:Relationship");
	case SOAP_TYPE_wsa__ServiceNameType:
		return soap_out_wsa__ServiceNameType(soap, tag, id, (const struct wsa__ServiceNameType *)ptr, "wsa:ServiceNameType");
	case SOAP_TYPE_wsa__ReferenceParametersType:
		return soap_out_wsa__ReferenceParametersType(soap, tag, id, (const struct wsa__ReferenceParametersType *)ptr, "wsa:ReferenceParametersType");
	case SOAP_TYPE_wsa__ReferencePropertiesType:
		return soap_out_wsa__ReferencePropertiesType(soap, tag, id, (const struct wsa__ReferencePropertiesType *)ptr, "wsa:ReferencePropertiesType");
	case SOAP_TYPE_wsa__EndpointReferenceType:
		return soap_out_wsa__EndpointReferenceType(soap, tag, id, (const struct wsa__EndpointReferenceType *)ptr, "wsa:EndpointReferenceType");
	case SOAP_TYPE_PointerTo_ns1__SignatureRequest:
		return soap_out_PointerTo_ns1__SignatureRequest(soap, tag, id, (_ns1__SignatureRequest *const*)ptr, "ns1:SignatureRequest");
	case SOAP_TYPE_PointerTo_ns1__AuthorizationRequest:
		return soap_out_PointerTo_ns1__AuthorizationRequest(soap, tag, id, (_ns1__AuthorizationRequest *const*)ptr, "ns1:AuthorizationRequest");
	case SOAP_TYPE_PointerTons2__AttributeRequestType:
		return soap_out_PointerTons2__AttributeRequestType(soap, tag, id, (ns2__AttributeRequestType *const*)ptr, "ns2:AttributeRequestType");
	case SOAP_TYPE_PointerTo_wsa__FaultTo:
		return soap_out_PointerTo_wsa__FaultTo(soap, tag, id, (struct wsa__EndpointReferenceType *const*)ptr, "wsa:FaultTo");
	case SOAP_TYPE_PointerTo_wsa__ReplyTo:
		return soap_out_PointerTo_wsa__ReplyTo(soap, tag, id, (struct wsa__EndpointReferenceType *const*)ptr, "wsa:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa__From:
		return soap_out_PointerTo_wsa__From(soap, tag, id, (struct wsa__EndpointReferenceType *const*)ptr, "wsa:From");
	case SOAP_TYPE_PointerTo_wsa__RelatesTo:
		return soap_out_PointerTo_wsa__RelatesTo(soap, tag, id, (struct wsa__Relationship *const*)ptr, "wsa:RelatesTo");
	case SOAP_TYPE__wsa__Action:
		return soap_out_string(soap, "wsa:Action", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa__To:
		return soap_out_string(soap, "wsa:To", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa__MessageID:
		return soap_out_string(soap, "wsa:MessageID", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE_PointerTowsa__ServiceNameType:
		return soap_out_PointerTowsa__ServiceNameType(soap, tag, id, (struct wsa__ServiceNameType *const*)ptr, "wsa:ServiceNameType");
	case SOAP_TYPE_PointerTo_QName:
		return soap_out_PointerTo_QName(soap, tag, id, (char **const*)ptr, "xsd:QName");
	case SOAP_TYPE_PointerTowsa__ReferenceParametersType:
		return soap_out_PointerTowsa__ReferenceParametersType(soap, tag, id, (struct wsa__ReferenceParametersType *const*)ptr, "wsa:ReferenceParametersType");
	case SOAP_TYPE_PointerTowsa__ReferencePropertiesType:
		return soap_out_PointerTowsa__ReferencePropertiesType(soap, tag, id, (struct wsa__ReferencePropertiesType *const*)ptr, "wsa:ReferencePropertiesType");
	case SOAP_TYPE_PointerToxsd__ID:
		return soap_out_PointerToxsd__ID(soap, tag, id, (std::string *const*)ptr, "xsd:ID");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_out_PointerToxsd__base64Binary(soap, tag, id, (xsd__base64Binary *const*)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerTons1__TransactionTypeList:
		return soap_out_PointerTons1__TransactionTypeList(soap, tag, id, (ns1__TransactionTypeList *const*)ptr, "ns1:TransactionTypeList");
	case SOAP_TYPE_PointerTons1__Status:
		return soap_out_PointerTons1__Status(soap, tag, id, (ns1__Status *const*)ptr, "ns1:Status");
	case SOAP_TYPE_PointerTons1__AttributeListType:
		return soap_out_PointerTons1__AttributeListType(soap, tag, id, (ns1__AttributeListType *const*)ptr, "ns1:AttributeListType");
	case SOAP_TYPE_PointerTons1__PersonalData:
		return soap_out_PointerTons1__PersonalData(soap, tag, id, (ns1__PersonalData *const*)ptr, "ns1:PersonalData");
	case SOAP_TYPE_PointerTons1__TransactionType:
		return soap_out_PointerTons1__TransactionType(soap, tag, id, (ns1__TransactionType *const*)ptr, "ns1:TransactionType");
	case SOAP_TYPE_PointerTons1__SubAttributeType:
		return soap_out_PointerTons1__SubAttributeType(soap, tag, id, (ns1__SubAttributeType *const*)ptr, "ns1:SubAttributeType");
	case SOAP_TYPE_PointerTons1__SubAttributeListType:
		return soap_out_PointerTons1__SubAttributeListType(soap, tag, id, (ns1__SubAttributeListType *const*)ptr, "ns1:SubAttributeListType");
	case SOAP_TYPE_PointerTons1__LegalActListType:
		return soap_out_PointerTons1__LegalActListType(soap, tag, id, (ns1__LegalActListType *const*)ptr, "ns1:LegalActListType");
	case SOAP_TYPE_PointerTons1__MainAttributeType:
		return soap_out_PointerTons1__MainAttributeType(soap, tag, id, (ns1__MainAttributeType *const*)ptr, "ns1:MainAttributeType");
	case SOAP_TYPE_PointerTons1__AttributeSupplierType:
		return soap_out_PointerTons1__AttributeSupplierType(soap, tag, id, (ns1__AttributeSupplierType *const*)ptr, "ns1:AttributeSupplierType");
	case SOAP_TYPE_PointerTons1__AttributeType:
		return soap_out_PointerTons1__AttributeType(soap, tag, id, (ns1__AttributeType *const*)ptr, "ns1:AttributeType");
	case SOAP_TYPE_PointerTons6__EncapsulatedOCSPValueType:
		return soap_out_PointerTons6__EncapsulatedOCSPValueType(soap, tag, id, (ns6__EncapsulatedOCSPValueType *const*)ptr, "ns6:EncapsulatedOCSPValueType");
	case SOAP_TYPE_PointerTons6__EncapsulatedCRLValueType:
		return soap_out_PointerTons6__EncapsulatedCRLValueType(soap, tag, id, (ns6__EncapsulatedCRLValueType *const*)ptr, "ns6:EncapsulatedCRLValueType");
	case SOAP_TYPE_PointerTons6__OCSPValuesType:
		return soap_out_PointerTons6__OCSPValuesType(soap, tag, id, (ns6__OCSPValuesType *const*)ptr, "ns6:OCSPValuesType");
	case SOAP_TYPE_PointerTons6__CRLValuesType:
		return soap_out_PointerTons6__CRLValuesType(soap, tag, id, (ns6__CRLValuesType *const*)ptr, "ns6:CRLValuesType");
	case SOAP_TYPE_PointerTons6__EncapsulatedX509CertificateType:
		return soap_out_PointerTons6__EncapsulatedX509CertificateType(soap, tag, id, (ns6__EncapsulatedX509CertificateType *const*)ptr, "ns6:EncapsulatedX509CertificateType");
	case SOAP_TYPE_PointerTons6__ResponderIDType:
		return soap_out_PointerTons6__ResponderIDType(soap, tag, id, (ns6__ResponderIDType *const*)ptr, "ns6:ResponderIDType");
	case SOAP_TYPE_PointerTons6__OCSPIdentifierType:
		return soap_out_PointerTons6__OCSPIdentifierType(soap, tag, id, (ns6__OCSPIdentifierType *const*)ptr, "ns6:OCSPIdentifierType");
	case SOAP_TYPE_PointerTons6__OCSPRefType:
		return soap_out_PointerTons6__OCSPRefType(soap, tag, id, (ns6__OCSPRefType *const*)ptr, "ns6:OCSPRefType");
	case SOAP_TYPE_PointerTons6__CRLIdentifierType:
		return soap_out_PointerTons6__CRLIdentifierType(soap, tag, id, (ns6__CRLIdentifierType *const*)ptr, "ns6:CRLIdentifierType");
	case SOAP_TYPE_PointerTons6__DigestAlgAndValueType:
		return soap_out_PointerTons6__DigestAlgAndValueType(soap, tag, id, (ns6__DigestAlgAndValueType *const*)ptr, "ns6:DigestAlgAndValueType");
	case SOAP_TYPE_PointerTons6__CRLRefType:
		return soap_out_PointerTons6__CRLRefType(soap, tag, id, (ns6__CRLRefType *const*)ptr, "ns6:CRLRefType");
	case SOAP_TYPE_PointerTons6__OCSPRefsType:
		return soap_out_PointerTons6__OCSPRefsType(soap, tag, id, (ns6__OCSPRefsType *const*)ptr, "ns6:OCSPRefsType");
	case SOAP_TYPE_PointerTons6__CRLRefsType:
		return soap_out_PointerTons6__CRLRefsType(soap, tag, id, (ns6__CRLRefsType *const*)ptr, "ns6:CRLRefsType");
	case SOAP_TYPE_PointerTons6__CertRefsType:
		return soap_out_PointerTons6__CertRefsType(soap, tag, id, (ns6__CertRefsType *const*)ptr, "ns6:CertRefsType");
	case SOAP_TYPE_PointerTons6__ArchiveTimeStampType:
		return soap_out_PointerTons6__ArchiveTimeStampType(soap, tag, id, (ns6__ArchiveTimeStampType *const*)ptr, "ns6:ArchiveTimeStampType");
	case SOAP_TYPE_PointerTons6__RevocationValuesType:
		return soap_out_PointerTons6__RevocationValuesType(soap, tag, id, (ns6__RevocationValuesType *const*)ptr, "ns6:RevocationValuesType");
	case SOAP_TYPE_PointerTons6__CertificateValuesType:
		return soap_out_PointerTons6__CertificateValuesType(soap, tag, id, (ns6__CertificateValuesType *const*)ptr, "ns6:CertificateValuesType");
	case SOAP_TYPE_PointerTons6__SigAndRefsTimeStampType:
		return soap_out_PointerTons6__SigAndRefsTimeStampType(soap, tag, id, (ns6__SigAndRefsTimeStampType *const*)ptr, "ns6:SigAndRefsTimeStampType");
	case SOAP_TYPE_PointerTons6__CompleteRevocationRefsType:
		return soap_out_PointerTons6__CompleteRevocationRefsType(soap, tag, id, (ns6__CompleteRevocationRefsType *const*)ptr, "ns6:CompleteRevocationRefsType");
	case SOAP_TYPE_PointerTons6__CompleteCertificateRefsType:
		return soap_out_PointerTons6__CompleteCertificateRefsType(soap, tag, id, (ns6__CompleteCertificateRefsType *const*)ptr, "ns6:CompleteCertificateRefsType");
	case SOAP_TYPE_PointerTons6__SignatureTimeStampType:
		return soap_out_PointerTons6__SignatureTimeStampType(soap, tag, id, (ns6__SignatureTimeStampType *const*)ptr, "ns6:SignatureTimeStampType");
	case SOAP_TYPE_PointerTons6__CounterSignatureType:
		return soap_out_PointerTons6__CounterSignatureType(soap, tag, id, (ns6__CounterSignatureType *const*)ptr, "ns6:CounterSignatureType");
	case SOAP_TYPE_PointerTons6__UnsignedSignaturePropertiesType:
		return soap_out_PointerTons6__UnsignedSignaturePropertiesType(soap, tag, id, (ns6__UnsignedSignaturePropertiesType *const*)ptr, "ns6:UnsignedSignaturePropertiesType");
	case SOAP_TYPE_PointerTons6__ClaimedRoleType:
		return soap_out_PointerTons6__ClaimedRoleType(soap, tag, id, (ns6__ClaimedRoleType *const*)ptr, "ns6:ClaimedRoleType");
	case SOAP_TYPE_PointerTons6__ClaimedRolesListType:
		return soap_out_PointerTons6__ClaimedRolesListType(soap, tag, id, (ns6__ClaimedRolesListType *const*)ptr, "ns6:ClaimedRolesListType");
	case SOAP_TYPE_PointerTons6__IssuerSerialType:
		return soap_out_PointerTons6__IssuerSerialType(soap, tag, id, (ns6__IssuerSerialType *const*)ptr, "ns6:IssuerSerialType");
	case SOAP_TYPE_PointerTons6__CertDigestType:
		return soap_out_PointerTons6__CertDigestType(soap, tag, id, (ns6__CertDigestType *const*)ptr, "ns6:CertDigestType");
	case SOAP_TYPE_PointerTons6__CertType:
		return soap_out_PointerTons6__CertType(soap, tag, id, (ns6__CertType *const*)ptr, "ns6:CertType");
	case SOAP_TYPE_PointerTons6__SignerRoleType:
		return soap_out_PointerTons6__SignerRoleType(soap, tag, id, (ns6__SignerRoleType *const*)ptr, "ns6:SignerRoleType");
	case SOAP_TYPE_PointerTons6__SigningCertificateType:
		return soap_out_PointerTons6__SigningCertificateType(soap, tag, id, (ns6__SigningCertificateType *const*)ptr, "ns6:SigningCertificateType");
	case SOAP_TYPE_PointerTons6__SignedSignaturePropertiesType:
		return soap_out_PointerTons6__SignedSignaturePropertiesType(soap, tag, id, (ns6__SignedSignaturePropertiesType *const*)ptr, "ns6:SignedSignaturePropertiesType");
	case SOAP_TYPE_PointerTons6__UnsignedPropertiesType:
		return soap_out_PointerTons6__UnsignedPropertiesType(soap, tag, id, (ns6__UnsignedPropertiesType *const*)ptr, "ns6:UnsignedPropertiesType");
	case SOAP_TYPE_PointerTons6__SignedPropertiesType:
		return soap_out_PointerTons6__SignedPropertiesType(soap, tag, id, (ns6__SignedPropertiesType *const*)ptr, "ns6:SignedPropertiesType");
	case SOAP_TYPE_PointerTons4__ResponseCodeMessage:
		return soap_out_PointerTons4__ResponseCodeMessage(soap, tag, id, (std::string *const*)ptr, "ns4:ResponseCodeMessage");
	case SOAP_TYPE_PointerTons4__SubAttributeValueType:
		return soap_out_PointerTons4__SubAttributeValueType(soap, tag, id, (std::string *const*)ptr, "ns4:SubAttributeValueType");
	case SOAP_TYPE_PointerTons3__SubAttributeType:
		return soap_out_PointerTons3__SubAttributeType(soap, tag, id, (ns3__SubAttributeType *const*)ptr, "ns3:SubAttributeType");
	case SOAP_TYPE_PointerTons3__SubAttributeListType:
		return soap_out_PointerTons3__SubAttributeListType(soap, tag, id, (ns3__SubAttributeListType *const*)ptr, "ns3:SubAttributeListType");
	case SOAP_TYPE_PointerTons3__LegalActListType:
		return soap_out_PointerTons3__LegalActListType(soap, tag, id, (ns3__LegalActListType *const*)ptr, "ns3:LegalActListType");
	case SOAP_TYPE_PointerTons4__DescriptionType:
		return soap_out_PointerTons4__DescriptionType(soap, tag, id, (std::string *const*)ptr, "ns4:DescriptionType");
	case SOAP_TYPE_PointerTons3__ExtraIDType:
		return soap_out_PointerTons3__ExtraIDType(soap, tag, id, (ns3__ExtraIDType *const*)ptr, "ns3:ExtraIDType");
	case SOAP_TYPE_PointerTons3__ExtraIDListType:
		return soap_out_PointerTons3__ExtraIDListType(soap, tag, id, (ns3__ExtraIDListType *const*)ptr, "ns3:ExtraIDListType");
	case SOAP_TYPE_PointerTons3__MainAttributeType:
		return soap_out_PointerTons3__MainAttributeType(soap, tag, id, (ns3__MainAttributeType *const*)ptr, "ns3:MainAttributeType");
	case SOAP_TYPE_PointerTons7__SVGListType:
		return soap_out_PointerTons7__SVGListType(soap, tag, id, (ns7__SVGListType *const*)ptr, "ns7:SVGListType");
	case SOAP_TYPE_PointerTons6__QualifyingPropertiesType:
		return soap_out_PointerTons6__QualifyingPropertiesType(soap, tag, id, (ns6__QualifyingPropertiesType *const*)ptr, "ns6:QualifyingPropertiesType");
	case SOAP_TYPE_PointerTons5__X509CertificateType:
		return soap_out_PointerTons5__X509CertificateType(soap, tag, id, (ns5__X509CertificateType *const*)ptr, "ns5:X509CertificateType");
	case SOAP_TYPE_PointerTons5__X509DataType:
		return soap_out_PointerTons5__X509DataType(soap, tag, id, (ns5__X509DataType *const*)ptr, "ns5:X509DataType");
	case SOAP_TYPE_PointerTons5__TransformType:
		return soap_out_PointerTons5__TransformType(soap, tag, id, (ns5__TransformType *const*)ptr, "ns5:TransformType");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_out_PointerToxsd__anyURI(soap, tag, id, (std::string *const*)ptr, "xsd:anyURI");
	case SOAP_TYPE_PointerTons5__DigestValueType:
		return soap_out_PointerTons5__DigestValueType(soap, tag, id, (ns5__DigestValueType *const*)ptr, "ns5:DigestValueType");
	case SOAP_TYPE_PointerTons5__DigestMethodType:
		return soap_out_PointerTons5__DigestMethodType(soap, tag, id, (ns5__DigestMethodType *const*)ptr, "ns5:DigestMethodType");
	case SOAP_TYPE_PointerTons5__TransformsType:
		return soap_out_PointerTons5__TransformsType(soap, tag, id, (ns5__TransformsType *const*)ptr, "ns5:TransformsType");
	case SOAP_TYPE_PointerTons5__ReferenceType:
		return soap_out_PointerTons5__ReferenceType(soap, tag, id, (ns5__ReferenceType *const*)ptr, "ns5:ReferenceType");
	case SOAP_TYPE_PointerTons5__SignatureMethodType:
		return soap_out_PointerTons5__SignatureMethodType(soap, tag, id, (ns5__SignatureMethodType *const*)ptr, "ns5:SignatureMethodType");
	case SOAP_TYPE_PointerTons5__CanonicalizationMethodType:
		return soap_out_PointerTons5__CanonicalizationMethodType(soap, tag, id, (ns5__CanonicalizationMethodType *const*)ptr, "ns5:CanonicalizationMethodType");
	case SOAP_TYPE_PointerTons5__ObjectType:
		return soap_out_PointerTons5__ObjectType(soap, tag, id, (ns5__ObjectType *const*)ptr, "ns5:ObjectType");
	case SOAP_TYPE_PointerTons5__KeyInfoType:
		return soap_out_PointerTons5__KeyInfoType(soap, tag, id, (ns5__KeyInfoType *const*)ptr, "ns5:KeyInfoType");
	case SOAP_TYPE_PointerTons5__SignatureValueType:
		return soap_out_PointerTons5__SignatureValueType(soap, tag, id, (ns5__SignatureValueType *const*)ptr, "ns5:SignatureValueType");
	case SOAP_TYPE_PointerTons5__SignedInfoType:
		return soap_out_PointerTons5__SignedInfoType(soap, tag, id, (ns5__SignedInfoType *const*)ptr, "ns5:SignedInfoType");
	case SOAP_TYPE_PointerTons3__AttributeType:
		return soap_out_PointerTons3__AttributeType(soap, tag, id, (ns3__AttributeType *const*)ptr, "ns3:AttributeType");
	case SOAP_TYPE_PointerTons5__SignatureType:
		return soap_out_PointerTons5__SignatureType(soap, tag, id, (ns5__SignatureType *const*)ptr, "ns5:SignatureType");
	case SOAP_TYPE_PointerTons2__UnsignedAttributesBasicType:
		return soap_out_PointerTons2__UnsignedAttributesBasicType(soap, tag, id, (ns2__UnsignedAttributesBasicType *const*)ptr, "ns2:UnsignedAttributesBasicType");
	case SOAP_TYPE_PointerTons2__SignedAttributesType:
		return soap_out_PointerTons2__SignedAttributesType(soap, tag, id, (ns2__SignedAttributesType *const*)ptr, "ns2:SignedAttributesType");
	case SOAP_TYPE_PointerTons2__ResponseResult:
		return soap_out_PointerTons2__ResponseResult(soap, tag, id, (ns2__ResponseResult *const*)ptr, "ns2:ResponseResult");
	case SOAP_TYPE_PointerTons2__UnsignedAttributesType:
		return soap_out_PointerTons2__UnsignedAttributesType(soap, tag, id, (ns2__UnsignedAttributesType *const*)ptr, "ns2:UnsignedAttributesType");
	case SOAP_TYPE_PointerTons2__AttributesType:
		return soap_out_PointerTons2__AttributesType(soap, tag, id, (ns2__AttributesType *const*)ptr, "ns2:AttributesType");
	case SOAP_TYPE_PointerTons4__CompanyNameType:
		return soap_out_PointerTons4__CompanyNameType(soap, tag, id, (std::string *const*)ptr, "ns4:CompanyNameType");
	case SOAP_TYPE_PointerTons4__NIPCType:
		return soap_out_PointerTons4__NIPCType(soap, tag, id, (std::string *const*)ptr, "ns4:NIPCType");
	case SOAP_TYPE_PointerTons3__AttributeSupplierType:
		return soap_out_PointerTons3__AttributeSupplierType(soap, tag, id, (ns3__AttributeSupplierType *const*)ptr, "ns3:AttributeSupplierType");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTons2__AttributeSupplierListType:
		return soap_out_PointerTons2__AttributeSupplierListType(soap, tag, id, (ns2__AttributeSupplierListType *const*)ptr, "ns2:AttributeSupplierListType");
	case SOAP_TYPE_PointerTons3__PersonalDataType:
		return soap_out_PointerTons3__PersonalDataType(soap, tag, id, (ns3__PersonalDataType *const*)ptr, "ns3:PersonalDataType");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns9__AttributeSupplierResponse:
		soap_serialize__ns9__AttributeSupplierResponse(soap, (const ns9__AttributeSupplierResponseType *)ptr);
		break;
	case SOAP_TYPE__ns7__SVG:
		soap_serialize__ns7__SVG(soap, (const xsd__base64Binary *)ptr);
		break;
	case SOAP_TYPE__ns7__SVGList:
		soap_serialize__ns7__SVGList(soap, (const ns7__SVGListType *)ptr);
		break;
	case SOAP_TYPE__ns6__ArchiveTimeStamp:
		soap_serialize__ns6__ArchiveTimeStamp(soap, (const ns6__ArchiveTimeStampType *)ptr);
		break;
	case SOAP_TYPE__ns6__EncapsulatedOCSPValue:
		soap_serialize__ns6__EncapsulatedOCSPValue(soap, (const ns6__EncapsulatedOCSPValueType *)ptr);
		break;
	case SOAP_TYPE__ns6__OCSPValues:
		soap_serialize__ns6__OCSPValues(soap, (const ns6__OCSPValuesType *)ptr);
		break;
	case SOAP_TYPE__ns6__EncapsulatedCRLValue:
		soap_serialize__ns6__EncapsulatedCRLValue(soap, (const ns6__EncapsulatedCRLValueType *)ptr);
		break;
	case SOAP_TYPE__ns6__CRLValues:
		soap_serialize__ns6__CRLValues(soap, (const ns6__CRLValuesType *)ptr);
		break;
	case SOAP_TYPE__ns6__RevocationValues:
		soap_serialize__ns6__RevocationValues(soap, (const ns6__RevocationValuesType *)ptr);
		break;
	case SOAP_TYPE__ns6__EncapsulatedX509Certificate:
		soap_serialize__ns6__EncapsulatedX509Certificate(soap, (const ns6__EncapsulatedX509CertificateType *)ptr);
		break;
	case SOAP_TYPE__ns6__CertificateValues:
		soap_serialize__ns6__CertificateValues(soap, (const ns6__CertificateValuesType *)ptr);
		break;
	case SOAP_TYPE__ns6__SigAndRefsTimeStamp:
		soap_serialize__ns6__SigAndRefsTimeStamp(soap, (const ns6__SigAndRefsTimeStampType *)ptr);
		break;
	case SOAP_TYPE__ns6__ResponderID:
		soap_serialize__ns6__ResponderID(soap, (const ns6__ResponderIDType *)ptr);
		break;
	case SOAP_TYPE__ns6__OCSPIdentifier:
		soap_serialize__ns6__OCSPIdentifier(soap, (const ns6__OCSPIdentifierType *)ptr);
		break;
	case SOAP_TYPE__ns6__OCSPRef:
		soap_serialize__ns6__OCSPRef(soap, (const ns6__OCSPRefType *)ptr);
		break;
	case SOAP_TYPE__ns6__OCSPRefs:
		soap_serialize__ns6__OCSPRefs(soap, (const ns6__OCSPRefsType *)ptr);
		break;
	case SOAP_TYPE__ns6__CRLIdentifier:
		soap_serialize__ns6__CRLIdentifier(soap, (const ns6__CRLIdentifierType *)ptr);
		break;
	case SOAP_TYPE__ns6__DigestAlgAndValue:
		soap_serialize__ns6__DigestAlgAndValue(soap, (const ns6__DigestAlgAndValueType *)ptr);
		break;
	case SOAP_TYPE__ns6__CRLRef:
		soap_serialize__ns6__CRLRef(soap, (const ns6__CRLRefType *)ptr);
		break;
	case SOAP_TYPE__ns6__CRLRefs:
		soap_serialize__ns6__CRLRefs(soap, (const ns6__CRLRefsType *)ptr);
		break;
	case SOAP_TYPE__ns6__CompleteRevocationRefs:
		soap_serialize__ns6__CompleteRevocationRefs(soap, (const ns6__CompleteRevocationRefsType *)ptr);
		break;
	case SOAP_TYPE__ns6__CertRefs:
		soap_serialize__ns6__CertRefs(soap, (const ns6__CertRefsType *)ptr);
		break;
	case SOAP_TYPE__ns6__CompleteCertificateRefs:
		soap_serialize__ns6__CompleteCertificateRefs(soap, (const ns6__CompleteCertificateRefsType *)ptr);
		break;
	case SOAP_TYPE__ns6__EncapsulatedTimeStamp:
		soap_serialize__ns6__EncapsulatedTimeStamp(soap, (const xsd__base64Binary *)ptr);
		break;
	case SOAP_TYPE__ns6__SignatureTimeStamp:
		soap_serialize__ns6__SignatureTimeStamp(soap, (const ns6__SignatureTimeStampType *)ptr);
		break;
	case SOAP_TYPE__ns6__CounterSignature:
		soap_serialize__ns6__CounterSignature(soap, (const ns6__CounterSignatureType *)ptr);
		break;
	case SOAP_TYPE__ns6__UnsignedSignatureProperties:
		soap_serialize__ns6__UnsignedSignatureProperties(soap, (const ns6__UnsignedSignaturePropertiesType *)ptr);
		break;
	case SOAP_TYPE__ns6__UnsignedProperties:
		soap_serialize__ns6__UnsignedProperties(soap, (const ns6__UnsignedPropertiesType *)ptr);
		break;
	case SOAP_TYPE__ns6__ClaimedRole:
		soap_serialize__ns6__ClaimedRole(soap, (const ns6__ClaimedRoleType *)ptr);
		break;
	case SOAP_TYPE__ns6__ClaimedRoles:
		soap_serialize__ns6__ClaimedRoles(soap, (const ns6__ClaimedRolesListType *)ptr);
		break;
	case SOAP_TYPE__ns6__SignerRole:
		soap_serialize__ns6__SignerRole(soap, (const ns6__SignerRoleType *)ptr);
		break;
	case SOAP_TYPE__ns6__IssuerSerial:
		soap_serialize__ns6__IssuerSerial(soap, (const ns6__IssuerSerialType *)ptr);
		break;
	case SOAP_TYPE__ns6__CertDigest:
		soap_serialize__ns6__CertDigest(soap, (const ns6__CertDigestType *)ptr);
		break;
	case SOAP_TYPE__ns6__Cert:
		soap_serialize__ns6__Cert(soap, (const ns6__CertType *)ptr);
		break;
	case SOAP_TYPE__ns6__SigningCertificate:
		soap_serialize__ns6__SigningCertificate(soap, (const ns6__SigningCertificateType *)ptr);
		break;
	case SOAP_TYPE__ns6__SignedSignatureProperties:
		soap_serialize__ns6__SignedSignatureProperties(soap, (const ns6__SignedSignaturePropertiesType *)ptr);
		break;
	case SOAP_TYPE__ns6__SignedProperties:
		soap_serialize__ns6__SignedProperties(soap, (const ns6__SignedPropertiesType *)ptr);
		break;
	case SOAP_TYPE__ns6__QualifyingProperties:
		soap_serialize__ns6__QualifyingProperties(soap, (const ns6__QualifyingPropertiesType *)ptr);
		break;
	case SOAP_TYPE__ns3__SignatureAttribute:
		soap_serialize__ns3__SignatureAttribute(soap, (const ns5__SignatureType *)ptr);
		break;
	case SOAP_TYPE__ns3__Attribute:
		soap_serialize__ns3__Attribute(soap, (const ns3__AttributeType *)ptr);
		break;
	case SOAP_TYPE__ns5__X509SerialNumber:
		soap_serialize__ns5__X509SerialNumber(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns5__X509IssuerName:
		soap_serialize__ns5__X509IssuerName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns5__SignatureValue:
		soap_serialize__ns5__SignatureValue(soap, (const ns5__SignatureValueType *)ptr);
		break;
	case SOAP_TYPE__ns5__DigestValue:
		soap_serialize__ns5__DigestValue(soap, (const ns5__DigestValueType *)ptr);
		break;
	case SOAP_TYPE__ns5__X509Certificate:
		soap_serialize__ns5__X509Certificate(soap, (const ns5__X509CertificateType *)ptr);
		break;
	case SOAP_TYPE__ns5__Object:
		soap_serialize__ns5__Object(soap, (const ns5__ObjectType *)ptr);
		break;
	case SOAP_TYPE__ns5__X509Data:
		soap_serialize__ns5__X509Data(soap, (const ns5__X509DataType *)ptr);
		break;
	case SOAP_TYPE__ns5__KeyInfo:
		soap_serialize__ns5__KeyInfo(soap, (const ns5__KeyInfoType *)ptr);
		break;
	case SOAP_TYPE__ns5__DigestMethod:
		soap_serialize__ns5__DigestMethod(soap, (const ns5__DigestMethodType *)ptr);
		break;
	case SOAP_TYPE__ns5__Transform:
		soap_serialize__ns5__Transform(soap, (const ns5__TransformType *)ptr);
		break;
	case SOAP_TYPE__ns5__Transforms:
		soap_serialize__ns5__Transforms(soap, (const ns5__TransformsType *)ptr);
		break;
	case SOAP_TYPE__ns5__Reference:
		soap_serialize__ns5__Reference(soap, (const ns5__ReferenceType *)ptr);
		break;
	case SOAP_TYPE__ns5__SignatureMethod:
		soap_serialize__ns5__SignatureMethod(soap, (const ns5__SignatureMethodType *)ptr);
		break;
	case SOAP_TYPE__ns5__CanonicalizationMethod:
		soap_serialize__ns5__CanonicalizationMethod(soap, (const ns5__CanonicalizationMethodType *)ptr);
		break;
	case SOAP_TYPE__ns5__SignedInfo:
		soap_serialize__ns5__SignedInfo(soap, (const ns5__SignedInfoType *)ptr);
		break;
	case SOAP_TYPE__ns5__Signature:
		soap_serialize__ns5__Signature(soap, (const ns5__SignatureType *)ptr);
		break;
	case SOAP_TYPE__ns2__SingleAttributeResponse:
		soap_serialize__ns2__SingleAttributeResponse(soap, (const ns2__SingleAttributeResponseType *)ptr);
		break;
	case SOAP_TYPE__ns2__PSAAttributeRequest:
		soap_serialize__ns2__PSAAttributeRequest(soap, (const ns2__PSAAttributeRequestType *)ptr);
		break;
	case SOAP_TYPE__ns2__AttributeResponse:
		soap_serialize__ns2__AttributeResponse(soap, (const ns2__AttributeResponseType *)ptr);
		break;
	case SOAP_TYPE__ns2__AttributeRequest:
		soap_serialize__ns2__AttributeRequest(soap, (const ns2__AttributeRequestType *)ptr);
		break;
	case SOAP_TYPE_ns7__SVGType:
		soap_serialize_ns7__SVGType(soap, (const xsd__base64Binary *)ptr);
		break;
	case SOAP_TYPE_ns6__ByNameType:
		soap_serialize_ns6__ByNameType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns6__NumberType:
		soap_serialize_ns6__NumberType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns6__IssuerType:
		soap_serialize_ns6__IssuerType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns6__EncapsulatedTimeStampType:
		soap_serialize_ns6__EncapsulatedTimeStampType(soap, (const xsd__base64Binary *)ptr);
		break;
	case SOAP_TYPE_ns4__ResponseCodeMessage:
		soap_serialize_ns4__ResponseCodeMessage(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns4__ResponseCodeType:
		soap_serialize_ns4__ResponseCodeType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns4__DescriptionType:
		soap_serialize_ns4__DescriptionType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns4__SubAttributeValueType:
		soap_serialize_ns4__SubAttributeValueType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns4__LegalActType:
		soap_serialize_ns4__LegalActType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns4__AttributeIDType:
		soap_serialize_ns4__AttributeIDType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns4__ExtraIDValueType:
		soap_serialize_ns4__ExtraIDValueType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns4__CompanyNameType:
		soap_serialize_ns4__CompanyNameType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns4__NIPCType:
		soap_serialize_ns4__NIPCType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns4__NICType:
		soap_serialize_ns4__NICType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns4__DateType:
		soap_serialize_ns4__DateType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns4__ValidityType:
		soap_serialize_ns4__ValidityType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns4__NameType:
		soap_serialize_ns4__NameType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns4__ProcessIDType:
		soap_serialize_ns4__ProcessIDType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns5__X509SerialNumberType:
		soap_serialize_ns5__X509SerialNumberType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns5__X509IssuerNameType:
		soap_serialize_ns5__X509IssuerNameType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns1__SignatureResponse:
		((_ns1__SignatureResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SignatureRequest:
		((_ns1__SignatureRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AuthorizationResponse:
		((_ns1__AuthorizationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AuthorizationRequest:
		((_ns1__AuthorizationRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TransactionType:
		((ns1__TransactionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TransactionTypeList:
		((ns1__TransactionTypeList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Status:
		((ns1__Status *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubAttributeType:
		((ns1__SubAttributeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubAttributeListType:
		((ns1__SubAttributeListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__LegalActListType:
		((ns1__LegalActListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MainAttributeType:
		((ns1__MainAttributeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AttributeSupplierType:
		((ns1__AttributeSupplierType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AttributeType:
		((ns1__AttributeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AttributeListType:
		((ns1__AttributeListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PersonalData:
		((ns1__PersonalData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns9__AttributeSupplierResponseType:
		((ns9__AttributeSupplierResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__SVGListType:
		((ns7__SVGListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__ArchiveTimeStampType:
		((ns6__ArchiveTimeStampType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__EncapsulatedOCSPValueType:
		((ns6__EncapsulatedOCSPValueType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__OCSPValuesType:
		((ns6__OCSPValuesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__EncapsulatedCRLValueType:
		((ns6__EncapsulatedCRLValueType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__CRLValuesType:
		((ns6__CRLValuesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__RevocationValuesType:
		((ns6__RevocationValuesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__EncapsulatedX509CertificateType:
		((ns6__EncapsulatedX509CertificateType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__CertificateValuesType:
		((ns6__CertificateValuesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__SigAndRefsTimeStampType:
		((ns6__SigAndRefsTimeStampType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__ResponderIDType:
		((ns6__ResponderIDType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__OCSPIdentifierType:
		((ns6__OCSPIdentifierType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__OCSPRefType:
		((ns6__OCSPRefType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__OCSPRefsType:
		((ns6__OCSPRefsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__CRLIdentifierType:
		((ns6__CRLIdentifierType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__DigestAlgAndValueType:
		((ns6__DigestAlgAndValueType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__CRLRefType:
		((ns6__CRLRefType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__CRLRefsType:
		((ns6__CRLRefsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__CompleteRevocationRefsType:
		((ns6__CompleteRevocationRefsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__CertRefsType:
		((ns6__CertRefsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__CompleteCertificateRefsType:
		((ns6__CompleteCertificateRefsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__SignatureTimeStampType:
		((ns6__SignatureTimeStampType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__CounterSignatureType:
		((ns6__CounterSignatureType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__UnsignedSignaturePropertiesType:
		((ns6__UnsignedSignaturePropertiesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__UnsignedPropertiesType:
		((ns6__UnsignedPropertiesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__ClaimedRoleType:
		((ns6__ClaimedRoleType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__ClaimedRolesListType:
		((ns6__ClaimedRolesListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__SignerRoleType:
		((ns6__SignerRoleType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__IssuerSerialType:
		((ns6__IssuerSerialType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__CertDigestType:
		((ns6__CertDigestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__CertType:
		((ns6__CertType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__SigningCertificateType:
		((ns6__SigningCertificateType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__SignedSignaturePropertiesType:
		((ns6__SignedSignaturePropertiesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__SignedPropertiesType:
		((ns6__SignedPropertiesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__QualifyingPropertiesType:
		((ns6__QualifyingPropertiesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ResponseCodeStatusType:
		((ns3__ResponseCodeStatusType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__SubAttributeType:
		((ns3__SubAttributeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__SubAttributeListType:
		((ns3__SubAttributeListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__LegalActListType:
		((ns3__LegalActListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__MainAttributeType:
		((ns3__MainAttributeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ExtraIDType:
		((ns3__ExtraIDType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ExtraIDListType:
		((ns3__ExtraIDListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__PersonalDataType:
		((ns3__PersonalDataType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__AttributeSupplierType:
		((ns3__AttributeSupplierType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__AttributeType:
		((ns3__AttributeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__SignatureValueType:
		((ns5__SignatureValueType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__DigestValueType:
		((ns5__DigestValueType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__X509CertificateType:
		((ns5__X509CertificateType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__ObjectType:
		((ns5__ObjectType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__X509DataType:
		((ns5__X509DataType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__KeyInfoType:
		((ns5__KeyInfoType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__DigestMethodType:
		((ns5__DigestMethodType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__TransformType:
		((ns5__TransformType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__TransformsType:
		((ns5__TransformsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__ReferenceType:
		((ns5__ReferenceType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__SignatureMethodType:
		((ns5__SignatureMethodType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__CanonicalizationMethodType:
		((ns5__CanonicalizationMethodType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__SignedInfoType:
		((ns5__SignedInfoType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__SignatureType:
		((ns5__SignatureType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ResponseResult:
		((ns2__ResponseResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__UnsignedAttributesBasicType:
		((ns2__UnsignedAttributesBasicType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SignedAttributesType:
		((ns2__SignedAttributesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__UnsignedAttributesType:
		((ns2__UnsignedAttributesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AttributesType:
		((ns2__AttributesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__UnsignedAttributeResponseType:
		((ns2__UnsignedAttributeResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SingleAttributeResponseType:
		((ns2__SingleAttributeResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AttributeResponseType:
		((ns2__AttributeResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AttributeSupplierListType:
		((ns2__AttributeSupplierListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PSAAttributeRequestType:
		((ns2__PSAAttributeRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SingleAttributeRequestType:
		((ns2__SingleAttributeRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AttributeRequestType:
		((ns2__AttributeRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__integer:
		soap_serialize_xsd__integer(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__date:
		soap_serialize_xsd__date(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_xsd__anyURI(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__ID:
		soap_serialize_xsd__ID(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns8__AttributeSuppliers:
		soap_serialize___ns8__AttributeSuppliers(soap, (const struct __ns8__AttributeSuppliers *)ptr);
		break;
	case SOAP_TYPE___ns3__Signature:
		soap_serialize___ns3__Signature(soap, (const struct __ns3__Signature *)ptr);
		break;
	case SOAP_TYPE___ns2__Authorization:
		soap_serialize___ns2__Authorization(soap, (const struct __ns2__Authorization *)ptr);
		break;
	case SOAP_TYPE___ns1__Attributes:
		soap_serialize___ns1__Attributes(soap, (const struct __ns1__Attributes *)ptr);
		break;
	case SOAP_TYPE__wsa__FaultTo:
		soap_serialize__wsa__FaultTo(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa__ReplyTo:
		soap_serialize__wsa__ReplyTo(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa__From:
		soap_serialize__wsa__From(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa__RelatesTo:
		soap_serialize__wsa__RelatesTo(soap, (const struct wsa__Relationship *)ptr);
		break;
	case SOAP_TYPE__wsa__EndpointReference:
		soap_serialize__wsa__EndpointReference(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_wsa__Relationship:
		soap_serialize_wsa__Relationship(soap, (const struct wsa__Relationship *)ptr);
		break;
	case SOAP_TYPE_wsa__ServiceNameType:
		soap_serialize_wsa__ServiceNameType(soap, (const struct wsa__ServiceNameType *)ptr);
		break;
	case SOAP_TYPE_wsa__ReferenceParametersType:
		soap_serialize_wsa__ReferenceParametersType(soap, (const struct wsa__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE_wsa__ReferencePropertiesType:
		soap_serialize_wsa__ReferencePropertiesType(soap, (const struct wsa__ReferencePropertiesType *)ptr);
		break;
	case SOAP_TYPE_wsa__EndpointReferenceType:
		soap_serialize_wsa__EndpointReferenceType(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SignatureRequest:
		soap_serialize_PointerTo_ns1__SignatureRequest(soap, (_ns1__SignatureRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AuthorizationRequest:
		soap_serialize_PointerTo_ns1__AuthorizationRequest(soap, (_ns1__AuthorizationRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AttributeRequestType:
		soap_serialize_PointerTons2__AttributeRequestType(soap, (ns2__AttributeRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa__FaultTo:
		soap_serialize_PointerTo_wsa__FaultTo(soap, (struct wsa__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa__ReplyTo:
		soap_serialize_PointerTo_wsa__ReplyTo(soap, (struct wsa__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa__From:
		soap_serialize_PointerTo_wsa__From(soap, (struct wsa__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa__RelatesTo:
		soap_serialize_PointerTo_wsa__RelatesTo(soap, (struct wsa__Relationship *const*)ptr);
		break;
	case SOAP_TYPE__wsa__Action:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa__To:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa__MessageID:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTowsa__ServiceNameType:
		soap_serialize_PointerTowsa__ServiceNameType(soap, (struct wsa__ServiceNameType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_QName:
		soap_serialize_PointerTo_QName(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa__ReferenceParametersType:
		soap_serialize_PointerTowsa__ReferenceParametersType(soap, (struct wsa__ReferenceParametersType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa__ReferencePropertiesType:
		soap_serialize_PointerTowsa__ReferencePropertiesType(soap, (struct wsa__ReferencePropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__ID:
		soap_serialize_PointerToxsd__ID(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__base64Binary:
		soap_serialize_PointerToxsd__base64Binary(soap, (xsd__base64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TransactionTypeList:
		soap_serialize_PointerTons1__TransactionTypeList(soap, (ns1__TransactionTypeList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Status:
		soap_serialize_PointerTons1__Status(soap, (ns1__Status *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AttributeListType:
		soap_serialize_PointerTons1__AttributeListType(soap, (ns1__AttributeListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PersonalData:
		soap_serialize_PointerTons1__PersonalData(soap, (ns1__PersonalData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TransactionType:
		soap_serialize_PointerTons1__TransactionType(soap, (ns1__TransactionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SubAttributeType:
		soap_serialize_PointerTons1__SubAttributeType(soap, (ns1__SubAttributeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SubAttributeListType:
		soap_serialize_PointerTons1__SubAttributeListType(soap, (ns1__SubAttributeListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__LegalActListType:
		soap_serialize_PointerTons1__LegalActListType(soap, (ns1__LegalActListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MainAttributeType:
		soap_serialize_PointerTons1__MainAttributeType(soap, (ns1__MainAttributeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AttributeSupplierType:
		soap_serialize_PointerTons1__AttributeSupplierType(soap, (ns1__AttributeSupplierType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AttributeType:
		soap_serialize_PointerTons1__AttributeType(soap, (ns1__AttributeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__EncapsulatedOCSPValueType:
		soap_serialize_PointerTons6__EncapsulatedOCSPValueType(soap, (ns6__EncapsulatedOCSPValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__EncapsulatedCRLValueType:
		soap_serialize_PointerTons6__EncapsulatedCRLValueType(soap, (ns6__EncapsulatedCRLValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__OCSPValuesType:
		soap_serialize_PointerTons6__OCSPValuesType(soap, (ns6__OCSPValuesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__CRLValuesType:
		soap_serialize_PointerTons6__CRLValuesType(soap, (ns6__CRLValuesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__EncapsulatedX509CertificateType:
		soap_serialize_PointerTons6__EncapsulatedX509CertificateType(soap, (ns6__EncapsulatedX509CertificateType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__ResponderIDType:
		soap_serialize_PointerTons6__ResponderIDType(soap, (ns6__ResponderIDType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__OCSPIdentifierType:
		soap_serialize_PointerTons6__OCSPIdentifierType(soap, (ns6__OCSPIdentifierType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__OCSPRefType:
		soap_serialize_PointerTons6__OCSPRefType(soap, (ns6__OCSPRefType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__CRLIdentifierType:
		soap_serialize_PointerTons6__CRLIdentifierType(soap, (ns6__CRLIdentifierType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__DigestAlgAndValueType:
		soap_serialize_PointerTons6__DigestAlgAndValueType(soap, (ns6__DigestAlgAndValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__CRLRefType:
		soap_serialize_PointerTons6__CRLRefType(soap, (ns6__CRLRefType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__OCSPRefsType:
		soap_serialize_PointerTons6__OCSPRefsType(soap, (ns6__OCSPRefsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__CRLRefsType:
		soap_serialize_PointerTons6__CRLRefsType(soap, (ns6__CRLRefsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__CertRefsType:
		soap_serialize_PointerTons6__CertRefsType(soap, (ns6__CertRefsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__ArchiveTimeStampType:
		soap_serialize_PointerTons6__ArchiveTimeStampType(soap, (ns6__ArchiveTimeStampType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__RevocationValuesType:
		soap_serialize_PointerTons6__RevocationValuesType(soap, (ns6__RevocationValuesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__CertificateValuesType:
		soap_serialize_PointerTons6__CertificateValuesType(soap, (ns6__CertificateValuesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__SigAndRefsTimeStampType:
		soap_serialize_PointerTons6__SigAndRefsTimeStampType(soap, (ns6__SigAndRefsTimeStampType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__CompleteRevocationRefsType:
		soap_serialize_PointerTons6__CompleteRevocationRefsType(soap, (ns6__CompleteRevocationRefsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__CompleteCertificateRefsType:
		soap_serialize_PointerTons6__CompleteCertificateRefsType(soap, (ns6__CompleteCertificateRefsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__SignatureTimeStampType:
		soap_serialize_PointerTons6__SignatureTimeStampType(soap, (ns6__SignatureTimeStampType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__CounterSignatureType:
		soap_serialize_PointerTons6__CounterSignatureType(soap, (ns6__CounterSignatureType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__UnsignedSignaturePropertiesType:
		soap_serialize_PointerTons6__UnsignedSignaturePropertiesType(soap, (ns6__UnsignedSignaturePropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__ClaimedRoleType:
		soap_serialize_PointerTons6__ClaimedRoleType(soap, (ns6__ClaimedRoleType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__ClaimedRolesListType:
		soap_serialize_PointerTons6__ClaimedRolesListType(soap, (ns6__ClaimedRolesListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__IssuerSerialType:
		soap_serialize_PointerTons6__IssuerSerialType(soap, (ns6__IssuerSerialType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__CertDigestType:
		soap_serialize_PointerTons6__CertDigestType(soap, (ns6__CertDigestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__CertType:
		soap_serialize_PointerTons6__CertType(soap, (ns6__CertType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__SignerRoleType:
		soap_serialize_PointerTons6__SignerRoleType(soap, (ns6__SignerRoleType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__SigningCertificateType:
		soap_serialize_PointerTons6__SigningCertificateType(soap, (ns6__SigningCertificateType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__SignedSignaturePropertiesType:
		soap_serialize_PointerTons6__SignedSignaturePropertiesType(soap, (ns6__SignedSignaturePropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__UnsignedPropertiesType:
		soap_serialize_PointerTons6__UnsignedPropertiesType(soap, (ns6__UnsignedPropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__SignedPropertiesType:
		soap_serialize_PointerTons6__SignedPropertiesType(soap, (ns6__SignedPropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ResponseCodeMessage:
		soap_serialize_PointerTons4__ResponseCodeMessage(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__SubAttributeValueType:
		soap_serialize_PointerTons4__SubAttributeValueType(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__SubAttributeType:
		soap_serialize_PointerTons3__SubAttributeType(soap, (ns3__SubAttributeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__SubAttributeListType:
		soap_serialize_PointerTons3__SubAttributeListType(soap, (ns3__SubAttributeListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__LegalActListType:
		soap_serialize_PointerTons3__LegalActListType(soap, (ns3__LegalActListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__DescriptionType:
		soap_serialize_PointerTons4__DescriptionType(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ExtraIDType:
		soap_serialize_PointerTons3__ExtraIDType(soap, (ns3__ExtraIDType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ExtraIDListType:
		soap_serialize_PointerTons3__ExtraIDListType(soap, (ns3__ExtraIDListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__MainAttributeType:
		soap_serialize_PointerTons3__MainAttributeType(soap, (ns3__MainAttributeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__SVGListType:
		soap_serialize_PointerTons7__SVGListType(soap, (ns7__SVGListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__QualifyingPropertiesType:
		soap_serialize_PointerTons6__QualifyingPropertiesType(soap, (ns6__QualifyingPropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__X509CertificateType:
		soap_serialize_PointerTons5__X509CertificateType(soap, (ns5__X509CertificateType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__X509DataType:
		soap_serialize_PointerTons5__X509DataType(soap, (ns5__X509DataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__TransformType:
		soap_serialize_PointerTons5__TransformType(soap, (ns5__TransformType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyURI:
		soap_serialize_PointerToxsd__anyURI(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__DigestValueType:
		soap_serialize_PointerTons5__DigestValueType(soap, (ns5__DigestValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__DigestMethodType:
		soap_serialize_PointerTons5__DigestMethodType(soap, (ns5__DigestMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__TransformsType:
		soap_serialize_PointerTons5__TransformsType(soap, (ns5__TransformsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__ReferenceType:
		soap_serialize_PointerTons5__ReferenceType(soap, (ns5__ReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__SignatureMethodType:
		soap_serialize_PointerTons5__SignatureMethodType(soap, (ns5__SignatureMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__CanonicalizationMethodType:
		soap_serialize_PointerTons5__CanonicalizationMethodType(soap, (ns5__CanonicalizationMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__ObjectType:
		soap_serialize_PointerTons5__ObjectType(soap, (ns5__ObjectType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__KeyInfoType:
		soap_serialize_PointerTons5__KeyInfoType(soap, (ns5__KeyInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__SignatureValueType:
		soap_serialize_PointerTons5__SignatureValueType(soap, (ns5__SignatureValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__SignedInfoType:
		soap_serialize_PointerTons5__SignedInfoType(soap, (ns5__SignedInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__AttributeType:
		soap_serialize_PointerTons3__AttributeType(soap, (ns3__AttributeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__SignatureType:
		soap_serialize_PointerTons5__SignatureType(soap, (ns5__SignatureType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__UnsignedAttributesBasicType:
		soap_serialize_PointerTons2__UnsignedAttributesBasicType(soap, (ns2__UnsignedAttributesBasicType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SignedAttributesType:
		soap_serialize_PointerTons2__SignedAttributesType(soap, (ns2__SignedAttributesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ResponseResult:
		soap_serialize_PointerTons2__ResponseResult(soap, (ns2__ResponseResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__UnsignedAttributesType:
		soap_serialize_PointerTons2__UnsignedAttributesType(soap, (ns2__UnsignedAttributesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AttributesType:
		soap_serialize_PointerTons2__AttributesType(soap, (ns2__AttributesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__CompanyNameType:
		soap_serialize_PointerTons4__CompanyNameType(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__NIPCType:
		soap_serialize_PointerTons4__NIPCType(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__AttributeSupplierType:
		soap_serialize_PointerTons3__AttributeSupplierType(soap, (ns3__AttributeSupplierType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AttributeSupplierListType:
		soap_serialize_PointerTons2__AttributeSupplierListType(soap, (ns2__AttributeSupplierListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__PersonalDataType:
		soap_serialize_PointerTons3__PersonalDataType(soap, (ns3__PersonalDataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 SCAP_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)SCAP_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)SCAP_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AttributeRequestType:
		return (void*)SCAP_instantiate_ns2__AttributeRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SingleAttributeRequestType:
		return (void*)SCAP_instantiate_ns2__SingleAttributeRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PSAAttributeRequestType:
		return (void*)SCAP_instantiate_ns2__PSAAttributeRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AttributeSupplierListType:
		return (void*)SCAP_instantiate_ns2__AttributeSupplierListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AttributeResponseType:
		return (void*)SCAP_instantiate_ns2__AttributeResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SingleAttributeResponseType:
		return (void*)SCAP_instantiate_ns2__SingleAttributeResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__UnsignedAttributeResponseType:
		return (void*)SCAP_instantiate_ns2__UnsignedAttributeResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AttributesType:
		return (void*)SCAP_instantiate_ns2__AttributesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__UnsignedAttributesType:
		return (void*)SCAP_instantiate_ns2__UnsignedAttributesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SignedAttributesType:
		return (void*)SCAP_instantiate_ns2__SignedAttributesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__UnsignedAttributesBasicType:
		return (void*)SCAP_instantiate_ns2__UnsignedAttributesBasicType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ResponseResult:
		return (void*)SCAP_instantiate_ns2__ResponseResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__SignatureType:
		return (void*)SCAP_instantiate_ns5__SignatureType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__SignedInfoType:
		return (void*)SCAP_instantiate_ns5__SignedInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__CanonicalizationMethodType:
		return (void*)SCAP_instantiate_ns5__CanonicalizationMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__SignatureMethodType:
		return (void*)SCAP_instantiate_ns5__SignatureMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ReferenceType:
		return (void*)SCAP_instantiate_ns5__ReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__TransformsType:
		return (void*)SCAP_instantiate_ns5__TransformsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__TransformType:
		return (void*)SCAP_instantiate_ns5__TransformType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__DigestMethodType:
		return (void*)SCAP_instantiate_ns5__DigestMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__KeyInfoType:
		return (void*)SCAP_instantiate_ns5__KeyInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__X509DataType:
		return (void*)SCAP_instantiate_ns5__X509DataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ObjectType:
		return (void*)SCAP_instantiate_ns5__ObjectType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__AttributeType:
		return (void*)SCAP_instantiate_ns3__AttributeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__AttributeSupplierType:
		return (void*)SCAP_instantiate_ns3__AttributeSupplierType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__PersonalDataType:
		return (void*)SCAP_instantiate_ns3__PersonalDataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ExtraIDListType:
		return (void*)SCAP_instantiate_ns3__ExtraIDListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ExtraIDType:
		return (void*)SCAP_instantiate_ns3__ExtraIDType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__MainAttributeType:
		return (void*)SCAP_instantiate_ns3__MainAttributeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__LegalActListType:
		return (void*)SCAP_instantiate_ns3__LegalActListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__SubAttributeListType:
		return (void*)SCAP_instantiate_ns3__SubAttributeListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__SubAttributeType:
		return (void*)SCAP_instantiate_ns3__SubAttributeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ResponseCodeStatusType:
		return (void*)SCAP_instantiate_ns3__ResponseCodeStatusType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__QualifyingPropertiesType:
		return (void*)SCAP_instantiate_ns6__QualifyingPropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__SignedPropertiesType:
		return (void*)SCAP_instantiate_ns6__SignedPropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__SignedSignaturePropertiesType:
		return (void*)SCAP_instantiate_ns6__SignedSignaturePropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__SigningCertificateType:
		return (void*)SCAP_instantiate_ns6__SigningCertificateType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__CertType:
		return (void*)SCAP_instantiate_ns6__CertType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__CertDigestType:
		return (void*)SCAP_instantiate_ns6__CertDigestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__IssuerSerialType:
		return (void*)SCAP_instantiate_ns6__IssuerSerialType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__SignerRoleType:
		return (void*)SCAP_instantiate_ns6__SignerRoleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ClaimedRolesListType:
		return (void*)SCAP_instantiate_ns6__ClaimedRolesListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ClaimedRoleType:
		return (void*)SCAP_instantiate_ns6__ClaimedRoleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__UnsignedPropertiesType:
		return (void*)SCAP_instantiate_ns6__UnsignedPropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__UnsignedSignaturePropertiesType:
		return (void*)SCAP_instantiate_ns6__UnsignedSignaturePropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__CounterSignatureType:
		return (void*)SCAP_instantiate_ns6__CounterSignatureType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__SignatureTimeStampType:
		return (void*)SCAP_instantiate_ns6__SignatureTimeStampType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__CompleteCertificateRefsType:
		return (void*)SCAP_instantiate_ns6__CompleteCertificateRefsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__CertRefsType:
		return (void*)SCAP_instantiate_ns6__CertRefsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__CompleteRevocationRefsType:
		return (void*)SCAP_instantiate_ns6__CompleteRevocationRefsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__CRLRefsType:
		return (void*)SCAP_instantiate_ns6__CRLRefsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__CRLRefType:
		return (void*)SCAP_instantiate_ns6__CRLRefType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__DigestAlgAndValueType:
		return (void*)SCAP_instantiate_ns6__DigestAlgAndValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__CRLIdentifierType:
		return (void*)SCAP_instantiate_ns6__CRLIdentifierType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__OCSPRefsType:
		return (void*)SCAP_instantiate_ns6__OCSPRefsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__OCSPRefType:
		return (void*)SCAP_instantiate_ns6__OCSPRefType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__OCSPIdentifierType:
		return (void*)SCAP_instantiate_ns6__OCSPIdentifierType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ResponderIDType:
		return (void*)SCAP_instantiate_ns6__ResponderIDType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__SigAndRefsTimeStampType:
		return (void*)SCAP_instantiate_ns6__SigAndRefsTimeStampType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__CertificateValuesType:
		return (void*)SCAP_instantiate_ns6__CertificateValuesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__RevocationValuesType:
		return (void*)SCAP_instantiate_ns6__RevocationValuesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__CRLValuesType:
		return (void*)SCAP_instantiate_ns6__CRLValuesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__OCSPValuesType:
		return (void*)SCAP_instantiate_ns6__OCSPValuesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ArchiveTimeStampType:
		return (void*)SCAP_instantiate_ns6__ArchiveTimeStampType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__SVGListType:
		return (void*)SCAP_instantiate_ns7__SVGListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns9__AttributeSupplierResponseType:
		return (void*)SCAP_instantiate_ns9__AttributeSupplierResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PersonalData:
		return (void*)SCAP_instantiate_ns1__PersonalData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AttributeListType:
		return (void*)SCAP_instantiate_ns1__AttributeListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AttributeType:
		return (void*)SCAP_instantiate_ns1__AttributeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AttributeSupplierType:
		return (void*)SCAP_instantiate_ns1__AttributeSupplierType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MainAttributeType:
		return (void*)SCAP_instantiate_ns1__MainAttributeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__LegalActListType:
		return (void*)SCAP_instantiate_ns1__LegalActListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubAttributeListType:
		return (void*)SCAP_instantiate_ns1__SubAttributeListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubAttributeType:
		return (void*)SCAP_instantiate_ns1__SubAttributeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Status:
		return (void*)SCAP_instantiate_ns1__Status(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TransactionTypeList:
		return (void*)SCAP_instantiate_ns1__TransactionTypeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TransactionType:
		return (void*)SCAP_instantiate_ns1__TransactionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AuthorizationRequest:
		return (void*)SCAP_instantiate__ns1__AuthorizationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AuthorizationResponse:
		return (void*)SCAP_instantiate__ns1__AuthorizationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SignatureRequest:
		return (void*)SCAP_instantiate__ns1__SignatureRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SignatureResponse:
		return (void*)SCAP_instantiate__ns1__SignatureResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__X509CertificateType:
		return (void*)SCAP_instantiate_ns5__X509CertificateType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__DigestValueType:
		return (void*)SCAP_instantiate_ns5__DigestValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__SignatureValueType:
		return (void*)SCAP_instantiate_ns5__SignatureValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__EncapsulatedX509CertificateType:
		return (void*)SCAP_instantiate_ns6__EncapsulatedX509CertificateType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__EncapsulatedCRLValueType:
		return (void*)SCAP_instantiate_ns6__EncapsulatedCRLValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__EncapsulatedOCSPValueType:
		return (void*)SCAP_instantiate_ns6__EncapsulatedOCSPValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa__EndpointReferenceType:
		return (void*)SCAP_instantiate_wsa__EndpointReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa__ReferencePropertiesType:
		return (void*)SCAP_instantiate_wsa__ReferencePropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa__ReferenceParametersType:
		return (void*)SCAP_instantiate_wsa__ReferenceParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa__ServiceNameType:
		return (void*)SCAP_instantiate_wsa__ServiceNameType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa__Relationship:
		return (void*)SCAP_instantiate_wsa__Relationship(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)SCAP_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)SCAP_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)SCAP_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)SCAP_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)SCAP_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___ns1__Attributes:
		return (void*)SCAP_instantiate___ns1__Attributes(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__Authorization:
		return (void*)SCAP_instantiate___ns2__Authorization(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__Signature:
		return (void*)SCAP_instantiate___ns3__Signature(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns8__AttributeSuppliers:
		return (void*)SCAP_instantiate___ns8__AttributeSuppliers(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__ID:
		return (void*)SCAP_instantiate_xsd__ID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI:
		return (void*)SCAP_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__date:
		return (void*)SCAP_instantiate_xsd__date(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__integer:
		return (void*)SCAP_instantiate_xsd__integer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__X509IssuerNameType:
		return (void*)SCAP_instantiate_ns5__X509IssuerNameType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__X509SerialNumberType:
		return (void*)SCAP_instantiate_ns5__X509SerialNumberType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ProcessIDType:
		return (void*)SCAP_instantiate_ns4__ProcessIDType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__NameType:
		return (void*)SCAP_instantiate_ns4__NameType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ValidityType:
		return (void*)SCAP_instantiate_ns4__ValidityType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__DateType:
		return (void*)SCAP_instantiate_ns4__DateType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__NICType:
		return (void*)SCAP_instantiate_ns4__NICType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__NIPCType:
		return (void*)SCAP_instantiate_ns4__NIPCType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__CompanyNameType:
		return (void*)SCAP_instantiate_ns4__CompanyNameType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ExtraIDValueType:
		return (void*)SCAP_instantiate_ns4__ExtraIDValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__AttributeIDType:
		return (void*)SCAP_instantiate_ns4__AttributeIDType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__LegalActType:
		return (void*)SCAP_instantiate_ns4__LegalActType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__SubAttributeValueType:
		return (void*)SCAP_instantiate_ns4__SubAttributeValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__DescriptionType:
		return (void*)SCAP_instantiate_ns4__DescriptionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ResponseCodeType:
		return (void*)SCAP_instantiate_ns4__ResponseCodeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ResponseCodeMessage:
		return (void*)SCAP_instantiate_ns4__ResponseCodeMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__EncapsulatedTimeStampType:
		return (void*)SCAP_instantiate_ns6__EncapsulatedTimeStampType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__IssuerType:
		return (void*)SCAP_instantiate_ns6__IssuerType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__NumberType:
		return (void*)SCAP_instantiate_ns6__NumberType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ByNameType:
		return (void*)SCAP_instantiate_ns6__ByNameType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__SVGType:
		return (void*)SCAP_instantiate_ns7__SVGType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__AttributeRequest:
		return (void*)SCAP_instantiate__ns2__AttributeRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__AttributeResponse:
		return (void*)SCAP_instantiate__ns2__AttributeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__PSAAttributeRequest:
		return (void*)SCAP_instantiate__ns2__PSAAttributeRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__SingleAttributeResponse:
		return (void*)SCAP_instantiate__ns2__SingleAttributeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__Signature:
		return (void*)SCAP_instantiate__ns5__Signature(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__SignedInfo:
		return (void*)SCAP_instantiate__ns5__SignedInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__CanonicalizationMethod:
		return (void*)SCAP_instantiate__ns5__CanonicalizationMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__SignatureMethod:
		return (void*)SCAP_instantiate__ns5__SignatureMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__Reference:
		return (void*)SCAP_instantiate__ns5__Reference(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__Transforms:
		return (void*)SCAP_instantiate__ns5__Transforms(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__Transform:
		return (void*)SCAP_instantiate__ns5__Transform(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__DigestMethod:
		return (void*)SCAP_instantiate__ns5__DigestMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__KeyInfo:
		return (void*)SCAP_instantiate__ns5__KeyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__X509Data:
		return (void*)SCAP_instantiate__ns5__X509Data(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__Object:
		return (void*)SCAP_instantiate__ns5__Object(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__X509Certificate:
		return (void*)SCAP_instantiate__ns5__X509Certificate(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__DigestValue:
		return (void*)SCAP_instantiate__ns5__DigestValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__SignatureValue:
		return (void*)SCAP_instantiate__ns5__SignatureValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__X509IssuerName:
		return (void*)SCAP_instantiate__ns5__X509IssuerName(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__X509SerialNumber:
		return (void*)SCAP_instantiate__ns5__X509SerialNumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__Attribute:
		return (void*)SCAP_instantiate__ns3__Attribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__SignatureAttribute:
		return (void*)SCAP_instantiate__ns3__SignatureAttribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__QualifyingProperties:
		return (void*)SCAP_instantiate__ns6__QualifyingProperties(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__SignedProperties:
		return (void*)SCAP_instantiate__ns6__SignedProperties(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__SignedSignatureProperties:
		return (void*)SCAP_instantiate__ns6__SignedSignatureProperties(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__SigningCertificate:
		return (void*)SCAP_instantiate__ns6__SigningCertificate(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__Cert:
		return (void*)SCAP_instantiate__ns6__Cert(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__CertDigest:
		return (void*)SCAP_instantiate__ns6__CertDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__IssuerSerial:
		return (void*)SCAP_instantiate__ns6__IssuerSerial(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__SignerRole:
		return (void*)SCAP_instantiate__ns6__SignerRole(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__ClaimedRoles:
		return (void*)SCAP_instantiate__ns6__ClaimedRoles(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__ClaimedRole:
		return (void*)SCAP_instantiate__ns6__ClaimedRole(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__UnsignedProperties:
		return (void*)SCAP_instantiate__ns6__UnsignedProperties(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__UnsignedSignatureProperties:
		return (void*)SCAP_instantiate__ns6__UnsignedSignatureProperties(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__CounterSignature:
		return (void*)SCAP_instantiate__ns6__CounterSignature(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__SignatureTimeStamp:
		return (void*)SCAP_instantiate__ns6__SignatureTimeStamp(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__EncapsulatedTimeStamp:
		return (void*)SCAP_instantiate__ns6__EncapsulatedTimeStamp(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__CompleteCertificateRefs:
		return (void*)SCAP_instantiate__ns6__CompleteCertificateRefs(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__CertRefs:
		return (void*)SCAP_instantiate__ns6__CertRefs(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__CompleteRevocationRefs:
		return (void*)SCAP_instantiate__ns6__CompleteRevocationRefs(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__CRLRefs:
		return (void*)SCAP_instantiate__ns6__CRLRefs(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__CRLRef:
		return (void*)SCAP_instantiate__ns6__CRLRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__DigestAlgAndValue:
		return (void*)SCAP_instantiate__ns6__DigestAlgAndValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__CRLIdentifier:
		return (void*)SCAP_instantiate__ns6__CRLIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__OCSPRefs:
		return (void*)SCAP_instantiate__ns6__OCSPRefs(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__OCSPRef:
		return (void*)SCAP_instantiate__ns6__OCSPRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__OCSPIdentifier:
		return (void*)SCAP_instantiate__ns6__OCSPIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__ResponderID:
		return (void*)SCAP_instantiate__ns6__ResponderID(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__SigAndRefsTimeStamp:
		return (void*)SCAP_instantiate__ns6__SigAndRefsTimeStamp(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__CertificateValues:
		return (void*)SCAP_instantiate__ns6__CertificateValues(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__EncapsulatedX509Certificate:
		return (void*)SCAP_instantiate__ns6__EncapsulatedX509Certificate(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__RevocationValues:
		return (void*)SCAP_instantiate__ns6__RevocationValues(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__CRLValues:
		return (void*)SCAP_instantiate__ns6__CRLValues(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__EncapsulatedCRLValue:
		return (void*)SCAP_instantiate__ns6__EncapsulatedCRLValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__OCSPValues:
		return (void*)SCAP_instantiate__ns6__OCSPValues(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__EncapsulatedOCSPValue:
		return (void*)SCAP_instantiate__ns6__EncapsulatedOCSPValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__ArchiveTimeStamp:
		return (void*)SCAP_instantiate__ns6__ArchiveTimeStamp(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__SVGList:
		return (void*)SCAP_instantiate__ns7__SVGList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__SVG:
		return (void*)SCAP_instantiate__ns7__SVG(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns9__AttributeSupplierResponse:
		return (void*)SCAP_instantiate__ns9__AttributeSupplierResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa__EndpointReference:
		return (void*)SCAP_instantiate__wsa__EndpointReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa__RelatesTo:
		return (void*)SCAP_instantiate__wsa__RelatesTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa__From:
		return (void*)SCAP_instantiate__wsa__From(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa__ReplyTo:
		return (void*)SCAP_instantiate__wsa__ReplyTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa__FaultTo:
		return (void*)SCAP_instantiate__wsa__FaultTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__TransactionType:
		return (void*)SCAP_instantiate_std__vectorTemplateOfPointerTons1__TransactionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubAttributeType:
		return (void*)SCAP_instantiate_std__vectorTemplateOfPointerTons1__SubAttributeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)SCAP_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__AttributeType:
		return (void*)SCAP_instantiate_std__vectorTemplateOfPointerTons1__AttributeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns7__SVGType:
		return (void*)SCAP_instantiate_std__vectorTemplateOfns7__SVGType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__EncapsulatedOCSPValueType:
		return (void*)SCAP_instantiate_std__vectorTemplateOfPointerTons6__EncapsulatedOCSPValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__EncapsulatedCRLValueType:
		return (void*)SCAP_instantiate_std__vectorTemplateOfPointerTons6__EncapsulatedCRLValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__EncapsulatedX509CertificateType:
		return (void*)SCAP_instantiate_std__vectorTemplateOfPointerTons6__EncapsulatedX509CertificateType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__OCSPRefType:
		return (void*)SCAP_instantiate_std__vectorTemplateOfPointerTons6__OCSPRefType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__CRLRefType:
		return (void*)SCAP_instantiate_std__vectorTemplateOfPointerTons6__CRLRefType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__CertType:
		return (void*)SCAP_instantiate_std__vectorTemplateOfPointerTons6__CertType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__ClaimedRoleType:
		return (void*)SCAP_instantiate_std__vectorTemplateOfPointerTons6__ClaimedRoleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__SubAttributeType:
		return (void*)SCAP_instantiate_std__vectorTemplateOfPointerTons3__SubAttributeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns4__LegalActType:
		return (void*)SCAP_instantiate_std__vectorTemplateOfns4__LegalActType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__ExtraIDType:
		return (void*)SCAP_instantiate_std__vectorTemplateOfPointerTons3__ExtraIDType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__X509CertificateType:
		return (void*)SCAP_instantiate_std__vectorTemplateOfPointerTons5__X509CertificateType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__TransformType:
		return (void*)SCAP_instantiate_std__vectorTemplateOfPointerTons5__TransformType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ReferenceType:
		return (void*)SCAP_instantiate_std__vectorTemplateOfPointerTons5__ReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ObjectType:
		return (void*)SCAP_instantiate_std__vectorTemplateOfPointerTons5__ObjectType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__AttributeType:
		return (void*)SCAP_instantiate_std__vectorTemplateOfPointerTons3__AttributeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__SignatureType:
		return (void*)SCAP_instantiate_std__vectorTemplateOfPointerTons5__SignatureType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__AttributesType:
		return (void*)SCAP_instantiate_std__vectorTemplateOfPointerTons2__AttributesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__AttributeSupplierType:
		return (void*)SCAP_instantiate_std__vectorTemplateOfPointerTons3__AttributeSupplierType(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 SCAP_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xsd__base64Binary*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xsd__base64Binary*>(p->ptr));
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__AttributeRequestType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__AttributeRequestType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__AttributeRequestType*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__SingleAttributeRequestType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__SingleAttributeRequestType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__SingleAttributeRequestType*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PSAAttributeRequestType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PSAAttributeRequestType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PSAAttributeRequestType*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__AttributeSupplierListType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__AttributeSupplierListType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__AttributeSupplierListType*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__AttributeResponseType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__AttributeResponseType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__AttributeResponseType*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__SingleAttributeResponseType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__SingleAttributeResponseType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__SingleAttributeResponseType*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__UnsignedAttributeResponseType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__UnsignedAttributeResponseType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__UnsignedAttributeResponseType*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__AttributesType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__AttributesType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__AttributesType*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__UnsignedAttributesType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__UnsignedAttributesType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__UnsignedAttributesType*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__SignedAttributesType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__SignedAttributesType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__SignedAttributesType*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__UnsignedAttributesBasicType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__UnsignedAttributesBasicType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__UnsignedAttributesBasicType*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ResponseResult:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ResponseResult*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ResponseResult*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__SignatureType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__SignatureType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__SignatureType*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__SignedInfoType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__SignedInfoType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__SignedInfoType*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__CanonicalizationMethodType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__CanonicalizationMethodType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__CanonicalizationMethodType*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__SignatureMethodType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__SignatureMethodType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__SignatureMethodType*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__ReferenceType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__ReferenceType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__ReferenceType*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__TransformsType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__TransformsType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__TransformsType*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__TransformType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__TransformType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__TransformType*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__DigestMethodType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__DigestMethodType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__DigestMethodType*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__KeyInfoType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__KeyInfoType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__KeyInfoType*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__X509DataType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__X509DataType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__X509DataType*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__ObjectType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__ObjectType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__ObjectType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__AttributeType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__AttributeType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__AttributeType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__AttributeSupplierType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__AttributeSupplierType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__AttributeSupplierType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__PersonalDataType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__PersonalDataType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__PersonalDataType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__ExtraIDListType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__ExtraIDListType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__ExtraIDListType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__ExtraIDType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__ExtraIDType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__ExtraIDType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__MainAttributeType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__MainAttributeType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__MainAttributeType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__LegalActListType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__LegalActListType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__LegalActListType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__SubAttributeListType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__SubAttributeListType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__SubAttributeListType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__SubAttributeType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__SubAttributeType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__SubAttributeType*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__ResponseCodeStatusType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__ResponseCodeStatusType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__ResponseCodeStatusType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__QualifyingPropertiesType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__QualifyingPropertiesType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__QualifyingPropertiesType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__SignedPropertiesType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__SignedPropertiesType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__SignedPropertiesType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__SignedSignaturePropertiesType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__SignedSignaturePropertiesType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__SignedSignaturePropertiesType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__SigningCertificateType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__SigningCertificateType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__SigningCertificateType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__CertType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__CertType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__CertType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__CertDigestType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__CertDigestType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__CertDigestType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__IssuerSerialType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__IssuerSerialType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__IssuerSerialType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__SignerRoleType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__SignerRoleType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__SignerRoleType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__ClaimedRolesListType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__ClaimedRolesListType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__ClaimedRolesListType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__ClaimedRoleType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__ClaimedRoleType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__ClaimedRoleType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__UnsignedPropertiesType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__UnsignedPropertiesType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__UnsignedPropertiesType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__UnsignedSignaturePropertiesType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__UnsignedSignaturePropertiesType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__UnsignedSignaturePropertiesType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__CounterSignatureType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__CounterSignatureType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__CounterSignatureType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__SignatureTimeStampType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__SignatureTimeStampType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__SignatureTimeStampType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__CompleteCertificateRefsType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__CompleteCertificateRefsType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__CompleteCertificateRefsType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__CertRefsType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__CertRefsType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__CertRefsType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__CompleteRevocationRefsType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__CompleteRevocationRefsType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__CompleteRevocationRefsType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__CRLRefsType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__CRLRefsType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__CRLRefsType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__CRLRefType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__CRLRefType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__CRLRefType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__DigestAlgAndValueType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__DigestAlgAndValueType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__DigestAlgAndValueType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__CRLIdentifierType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__CRLIdentifierType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__CRLIdentifierType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__OCSPRefsType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__OCSPRefsType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__OCSPRefsType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__OCSPRefType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__OCSPRefType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__OCSPRefType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__OCSPIdentifierType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__OCSPIdentifierType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__OCSPIdentifierType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__ResponderIDType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__ResponderIDType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__ResponderIDType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__SigAndRefsTimeStampType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__SigAndRefsTimeStampType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__SigAndRefsTimeStampType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__CertificateValuesType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__CertificateValuesType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__CertificateValuesType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__RevocationValuesType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__RevocationValuesType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__RevocationValuesType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__CRLValuesType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__CRLValuesType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__CRLValuesType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__OCSPValuesType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__OCSPValuesType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__OCSPValuesType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__ArchiveTimeStampType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__ArchiveTimeStampType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__ArchiveTimeStampType*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__SVGListType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__SVGListType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__SVGListType*>(p->ptr));
		break;
	case SOAP_TYPE_ns9__AttributeSupplierResponseType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns9__AttributeSupplierResponseType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns9__AttributeSupplierResponseType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__PersonalData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__PersonalData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__PersonalData*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__AttributeListType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__AttributeListType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__AttributeListType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__AttributeType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__AttributeType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__AttributeType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__AttributeSupplierType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__AttributeSupplierType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__AttributeSupplierType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__MainAttributeType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__MainAttributeType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__MainAttributeType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__LegalActListType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__LegalActListType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__LegalActListType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__SubAttributeListType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__SubAttributeListType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__SubAttributeListType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__SubAttributeType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__SubAttributeType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__SubAttributeType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__Status:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__Status*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__Status*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__TransactionTypeList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__TransactionTypeList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__TransactionTypeList*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__TransactionType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__TransactionType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__TransactionType*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__AuthorizationRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__AuthorizationRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__AuthorizationRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__AuthorizationResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__AuthorizationResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__AuthorizationResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SignatureRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SignatureRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SignatureRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SignatureResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SignatureResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SignatureResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__X509CertificateType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__X509CertificateType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__X509CertificateType*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__DigestValueType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__DigestValueType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__DigestValueType*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__SignatureValueType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__SignatureValueType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__SignatureValueType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__EncapsulatedX509CertificateType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__EncapsulatedX509CertificateType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__EncapsulatedX509CertificateType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__EncapsulatedCRLValueType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__EncapsulatedCRLValueType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__EncapsulatedCRLValueType*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__EncapsulatedOCSPValueType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__EncapsulatedOCSPValueType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__EncapsulatedOCSPValueType*>(p->ptr));
		break;
	case SOAP_TYPE_wsa__EndpointReferenceType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct wsa__EndpointReferenceType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct wsa__EndpointReferenceType*>(p->ptr));
		break;
	case SOAP_TYPE_wsa__ReferencePropertiesType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct wsa__ReferencePropertiesType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct wsa__ReferencePropertiesType*>(p->ptr));
		break;
	case SOAP_TYPE_wsa__ReferenceParametersType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct wsa__ReferenceParametersType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct wsa__ReferenceParametersType*>(p->ptr));
		break;
	case SOAP_TYPE_wsa__ServiceNameType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct wsa__ServiceNameType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct wsa__ServiceNameType*>(p->ptr));
		break;
	case SOAP_TYPE_wsa__Relationship:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct wsa__Relationship*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct wsa__Relationship*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		break;
#endif
	case SOAP_TYPE___ns1__Attributes:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Attributes*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Attributes*>(p->ptr));
		break;
	case SOAP_TYPE___ns2__Authorization:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns2__Authorization*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns2__Authorization*>(p->ptr));
		break;
	case SOAP_TYPE___ns3__Signature:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns3__Signature*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns3__Signature*>(p->ptr));
		break;
	case SOAP_TYPE___ns8__AttributeSuppliers:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns8__AttributeSuppliers*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns8__AttributeSuppliers*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__ID:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__date:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__integer:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__X509IssuerNameType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__X509SerialNumberType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns4__ProcessIDType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns4__NameType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns4__ValidityType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns4__DateType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns4__NICType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns4__NIPCType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns4__CompanyNameType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns4__ExtraIDValueType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns4__AttributeIDType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns4__LegalActType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns4__SubAttributeValueType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns4__DescriptionType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns4__ResponseCodeType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns4__ResponseCodeMessage:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__EncapsulatedTimeStampType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xsd__base64Binary*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xsd__base64Binary*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__IssuerType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__NumberType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns6__ByNameType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__SVGType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xsd__base64Binary*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xsd__base64Binary*>(p->ptr));
		break;
	case SOAP_TYPE__ns2__AttributeRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__AttributeRequestType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__AttributeRequestType*>(p->ptr));
		break;
	case SOAP_TYPE__ns2__AttributeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__AttributeResponseType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__AttributeResponseType*>(p->ptr));
		break;
	case SOAP_TYPE__ns2__PSAAttributeRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PSAAttributeRequestType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PSAAttributeRequestType*>(p->ptr));
		break;
	case SOAP_TYPE__ns2__SingleAttributeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__SingleAttributeResponseType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__SingleAttributeResponseType*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__Signature:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__SignatureType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__SignatureType*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__SignedInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__SignedInfoType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__SignedInfoType*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__CanonicalizationMethod:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__CanonicalizationMethodType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__CanonicalizationMethodType*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__SignatureMethod:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__SignatureMethodType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__SignatureMethodType*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__Reference:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__ReferenceType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__ReferenceType*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__Transforms:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__TransformsType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__TransformsType*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__Transform:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__TransformType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__TransformType*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__DigestMethod:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__DigestMethodType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__DigestMethodType*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__KeyInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__KeyInfoType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__KeyInfoType*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__X509Data:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__X509DataType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__X509DataType*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__Object:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__ObjectType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__ObjectType*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__X509Certificate:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__X509CertificateType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__X509CertificateType*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__DigestValue:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__DigestValueType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__DigestValueType*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__SignatureValue:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__SignatureValueType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__SignatureValueType*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__X509IssuerName:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE__ns5__X509SerialNumber:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__Attribute:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__AttributeType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__AttributeType*>(p->ptr));
		break;
	case SOAP_TYPE__ns3__SignatureAttribute:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__SignatureType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__SignatureType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__QualifyingProperties:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__QualifyingPropertiesType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__QualifyingPropertiesType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__SignedProperties:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__SignedPropertiesType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__SignedPropertiesType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__SignedSignatureProperties:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__SignedSignaturePropertiesType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__SignedSignaturePropertiesType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__SigningCertificate:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__SigningCertificateType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__SigningCertificateType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__Cert:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__CertType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__CertType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__CertDigest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__CertDigestType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__CertDigestType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__IssuerSerial:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__IssuerSerialType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__IssuerSerialType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__SignerRole:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__SignerRoleType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__SignerRoleType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__ClaimedRoles:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__ClaimedRolesListType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__ClaimedRolesListType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__ClaimedRole:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__ClaimedRoleType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__ClaimedRoleType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__UnsignedProperties:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__UnsignedPropertiesType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__UnsignedPropertiesType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__UnsignedSignatureProperties:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__UnsignedSignaturePropertiesType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__UnsignedSignaturePropertiesType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__CounterSignature:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__CounterSignatureType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__CounterSignatureType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__SignatureTimeStamp:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__SignatureTimeStampType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__SignatureTimeStampType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__EncapsulatedTimeStamp:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xsd__base64Binary*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xsd__base64Binary*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__CompleteCertificateRefs:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__CompleteCertificateRefsType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__CompleteCertificateRefsType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__CertRefs:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__CertRefsType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__CertRefsType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__CompleteRevocationRefs:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__CompleteRevocationRefsType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__CompleteRevocationRefsType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__CRLRefs:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__CRLRefsType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__CRLRefsType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__CRLRef:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__CRLRefType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__CRLRefType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__DigestAlgAndValue:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__DigestAlgAndValueType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__DigestAlgAndValueType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__CRLIdentifier:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__CRLIdentifierType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__CRLIdentifierType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__OCSPRefs:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__OCSPRefsType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__OCSPRefsType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__OCSPRef:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__OCSPRefType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__OCSPRefType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__OCSPIdentifier:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__OCSPIdentifierType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__OCSPIdentifierType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__ResponderID:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__ResponderIDType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__ResponderIDType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__SigAndRefsTimeStamp:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__SigAndRefsTimeStampType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__SigAndRefsTimeStampType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__CertificateValues:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__CertificateValuesType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__CertificateValuesType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__EncapsulatedX509Certificate:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__EncapsulatedX509CertificateType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__EncapsulatedX509CertificateType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__RevocationValues:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__RevocationValuesType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__RevocationValuesType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__CRLValues:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__CRLValuesType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__CRLValuesType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__EncapsulatedCRLValue:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__EncapsulatedCRLValueType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__EncapsulatedCRLValueType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__OCSPValues:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__OCSPValuesType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__OCSPValuesType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__EncapsulatedOCSPValue:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__EncapsulatedOCSPValueType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__EncapsulatedOCSPValueType*>(p->ptr));
		break;
	case SOAP_TYPE__ns6__ArchiveTimeStamp:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns6__ArchiveTimeStampType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns6__ArchiveTimeStampType*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__SVGList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__SVGListType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__SVGListType*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__SVG:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xsd__base64Binary*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xsd__base64Binary*>(p->ptr));
		break;
	case SOAP_TYPE__ns9__AttributeSupplierResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns9__AttributeSupplierResponseType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns9__AttributeSupplierResponseType*>(p->ptr));
		break;
	case SOAP_TYPE__wsa__EndpointReference:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct wsa__EndpointReferenceType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct wsa__EndpointReferenceType*>(p->ptr));
		break;
	case SOAP_TYPE__wsa__RelatesTo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct wsa__Relationship*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct wsa__Relationship*>(p->ptr));
		break;
	case SOAP_TYPE__wsa__From:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct wsa__EndpointReferenceType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct wsa__EndpointReferenceType*>(p->ptr));
		break;
	case SOAP_TYPE__wsa__ReplyTo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct wsa__EndpointReferenceType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct wsa__EndpointReferenceType*>(p->ptr));
		break;
	case SOAP_TYPE__wsa__FaultTo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct wsa__EndpointReferenceType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct wsa__EndpointReferenceType*>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__TransactionType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__TransactionType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__TransactionType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubAttributeType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__SubAttributeType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__SubAttributeType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<std::string> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<std::string> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__AttributeType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__AttributeType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__AttributeType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfns7__SVGType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<xsd__base64Binary> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<xsd__base64Binary> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__EncapsulatedOCSPValueType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns6__EncapsulatedOCSPValueType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns6__EncapsulatedOCSPValueType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__EncapsulatedCRLValueType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns6__EncapsulatedCRLValueType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns6__EncapsulatedCRLValueType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__EncapsulatedX509CertificateType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns6__EncapsulatedX509CertificateType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns6__EncapsulatedX509CertificateType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__OCSPRefType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns6__OCSPRefType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns6__OCSPRefType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__CRLRefType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns6__CRLRefType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns6__CRLRefType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__CertType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns6__CertType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns6__CertType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__ClaimedRoleType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns6__ClaimedRoleType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns6__ClaimedRoleType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__SubAttributeType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns3__SubAttributeType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns3__SubAttributeType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfns4__LegalActType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<std::string> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<std::string> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__ExtraIDType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns3__ExtraIDType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns3__ExtraIDType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__X509CertificateType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns5__X509CertificateType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns5__X509CertificateType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__TransformType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns5__TransformType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns5__TransformType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ReferenceType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns5__ReferenceType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns5__ReferenceType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ObjectType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns5__ObjectType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns5__ObjectType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__AttributeType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns3__AttributeType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns3__AttributeType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__SignatureType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns5__SignatureType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns5__SignatureType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__AttributesType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns2__AttributesType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns2__AttributesType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__AttributeSupplierType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns3__AttributeSupplierType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns3__AttributeSupplierType *> *>(p->ptr));
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 SCAP_fbase(int t, int b)
{
	do
	{	switch (t)
		{
		default: return 0;
		}
	}
	while (t != b);
	return 1;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 SCAP_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__TransactionType:
		if (t == SOAP_TYPE_ns1__TransactionType || SCAP_fbase(t, SOAP_TYPE_ns1__TransactionType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__TransactionType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__TransactionType *> *)p)[index] = *(ns1__TransactionType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubAttributeType:
		if (t == SOAP_TYPE_ns1__SubAttributeType || SCAP_fbase(t, SOAP_TYPE_ns1__SubAttributeType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__SubAttributeType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__SubAttributeType *> *)p)[index] = *(ns1__SubAttributeType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (t == SOAP_TYPE_std__string)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__AttributeType:
		if (t == SOAP_TYPE_ns1__AttributeType || SCAP_fbase(t, SOAP_TYPE_ns1__AttributeType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__AttributeType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__AttributeType *> *)p)[index] = *(ns1__AttributeType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns7__SVGType:
		if (t == SOAP_TYPE_ns7__SVGType)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<xsd__base64Binary>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<xsd__base64Binary> *)p)[index] = *(xsd__base64Binary *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__EncapsulatedOCSPValueType:
		if (t == SOAP_TYPE_ns6__EncapsulatedOCSPValueType || SCAP_fbase(t, SOAP_TYPE_ns6__EncapsulatedOCSPValueType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns6__EncapsulatedOCSPValueType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns6__EncapsulatedOCSPValueType *> *)p)[index] = *(ns6__EncapsulatedOCSPValueType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__EncapsulatedCRLValueType:
		if (t == SOAP_TYPE_ns6__EncapsulatedCRLValueType || SCAP_fbase(t, SOAP_TYPE_ns6__EncapsulatedCRLValueType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns6__EncapsulatedCRLValueType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns6__EncapsulatedCRLValueType *> *)p)[index] = *(ns6__EncapsulatedCRLValueType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__EncapsulatedX509CertificateType:
		if (t == SOAP_TYPE_ns6__EncapsulatedX509CertificateType || SCAP_fbase(t, SOAP_TYPE_ns6__EncapsulatedX509CertificateType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns6__EncapsulatedX509CertificateType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns6__EncapsulatedX509CertificateType *> *)p)[index] = *(ns6__EncapsulatedX509CertificateType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__OCSPRefType:
		if (t == SOAP_TYPE_ns6__OCSPRefType || SCAP_fbase(t, SOAP_TYPE_ns6__OCSPRefType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns6__OCSPRefType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns6__OCSPRefType *> *)p)[index] = *(ns6__OCSPRefType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__CRLRefType:
		if (t == SOAP_TYPE_ns6__CRLRefType || SCAP_fbase(t, SOAP_TYPE_ns6__CRLRefType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns6__CRLRefType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns6__CRLRefType *> *)p)[index] = *(ns6__CRLRefType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__CertType:
		if (t == SOAP_TYPE_ns6__CertType || SCAP_fbase(t, SOAP_TYPE_ns6__CertType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns6__CertType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns6__CertType *> *)p)[index] = *(ns6__CertType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__ClaimedRoleType:
		if (t == SOAP_TYPE_ns6__ClaimedRoleType || SCAP_fbase(t, SOAP_TYPE_ns6__ClaimedRoleType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns6__ClaimedRoleType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns6__ClaimedRoleType *> *)p)[index] = *(ns6__ClaimedRoleType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__SubAttributeType:
		if (t == SOAP_TYPE_ns3__SubAttributeType || SCAP_fbase(t, SOAP_TYPE_ns3__SubAttributeType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__SubAttributeType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__SubAttributeType *> *)p)[index] = *(ns3__SubAttributeType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns4__LegalActType:
		if (t == SOAP_TYPE_ns4__LegalActType)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__ExtraIDType:
		if (t == SOAP_TYPE_ns3__ExtraIDType || SCAP_fbase(t, SOAP_TYPE_ns3__ExtraIDType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__ExtraIDType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__ExtraIDType *> *)p)[index] = *(ns3__ExtraIDType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__X509CertificateType:
		if (t == SOAP_TYPE_ns5__X509CertificateType || SCAP_fbase(t, SOAP_TYPE_ns5__X509CertificateType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns5__X509CertificateType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns5__X509CertificateType *> *)p)[index] = *(ns5__X509CertificateType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__TransformType:
		if (t == SOAP_TYPE_ns5__TransformType || SCAP_fbase(t, SOAP_TYPE_ns5__TransformType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns5__TransformType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns5__TransformType *> *)p)[index] = *(ns5__TransformType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ReferenceType:
		if (t == SOAP_TYPE_ns5__ReferenceType || SCAP_fbase(t, SOAP_TYPE_ns5__ReferenceType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns5__ReferenceType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns5__ReferenceType *> *)p)[index] = *(ns5__ReferenceType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ObjectType:
		if (t == SOAP_TYPE_ns5__ObjectType || SCAP_fbase(t, SOAP_TYPE_ns5__ObjectType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns5__ObjectType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns5__ObjectType *> *)p)[index] = *(ns5__ObjectType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__AttributeType:
		if (t == SOAP_TYPE_ns3__AttributeType || SCAP_fbase(t, SOAP_TYPE_ns3__AttributeType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__AttributeType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__AttributeType *> *)p)[index] = *(ns3__AttributeType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__SignatureType:
		if (t == SOAP_TYPE_ns5__SignatureType || SCAP_fbase(t, SOAP_TYPE_ns5__SignatureType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns5__SignatureType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns5__SignatureType *> *)p)[index] = *(ns5__SignatureType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__AttributesType:
		if (t == SOAP_TYPE_ns2__AttributesType || SCAP_fbase(t, SOAP_TYPE_ns2__AttributesType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns2__AttributesType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns2__AttributesType *> *)p)[index] = *(ns2__AttributesType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__AttributeSupplierType:
		if (t == SOAP_TYPE_ns3__AttributeSupplierType || SCAP_fbase(t, SOAP_TYPE_ns3__AttributeSupplierType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__AttributeSupplierType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__AttributeSupplierType *> *)p)[index] = *(ns3__AttributeSupplierType **)q;
		}
		break;
	case SOAP_TYPE_xsd__base64Binary:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__base64Binary type=%d location=%p object=%p\n", t, p, q));
		*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns2__AttributeRequestType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__AttributeRequestType type=%d location=%p object=%p\n", t, p, q));
		*(ns2__AttributeRequestType*)p = *(ns2__AttributeRequestType*)q;
		break;
	case SOAP_TYPE_ns2__SingleAttributeRequestType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__SingleAttributeRequestType type=%d location=%p object=%p\n", t, p, q));
		*(ns2__SingleAttributeRequestType*)p = *(ns2__SingleAttributeRequestType*)q;
		break;
	case SOAP_TYPE_ns2__PSAAttributeRequestType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PSAAttributeRequestType type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PSAAttributeRequestType*)p = *(ns2__PSAAttributeRequestType*)q;
		break;
	case SOAP_TYPE_ns2__AttributeSupplierListType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__AttributeSupplierListType type=%d location=%p object=%p\n", t, p, q));
		*(ns2__AttributeSupplierListType*)p = *(ns2__AttributeSupplierListType*)q;
		break;
	case SOAP_TYPE_ns2__AttributeResponseType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__AttributeResponseType type=%d location=%p object=%p\n", t, p, q));
		*(ns2__AttributeResponseType*)p = *(ns2__AttributeResponseType*)q;
		break;
	case SOAP_TYPE_ns2__SingleAttributeResponseType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__SingleAttributeResponseType type=%d location=%p object=%p\n", t, p, q));
		*(ns2__SingleAttributeResponseType*)p = *(ns2__SingleAttributeResponseType*)q;
		break;
	case SOAP_TYPE_ns2__UnsignedAttributeResponseType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__UnsignedAttributeResponseType type=%d location=%p object=%p\n", t, p, q));
		*(ns2__UnsignedAttributeResponseType*)p = *(ns2__UnsignedAttributeResponseType*)q;
		break;
	case SOAP_TYPE_ns2__AttributesType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__AttributesType type=%d location=%p object=%p\n", t, p, q));
		*(ns2__AttributesType*)p = *(ns2__AttributesType*)q;
		break;
	case SOAP_TYPE_ns2__UnsignedAttributesType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__UnsignedAttributesType type=%d location=%p object=%p\n", t, p, q));
		*(ns2__UnsignedAttributesType*)p = *(ns2__UnsignedAttributesType*)q;
		break;
	case SOAP_TYPE_ns2__SignedAttributesType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__SignedAttributesType type=%d location=%p object=%p\n", t, p, q));
		*(ns2__SignedAttributesType*)p = *(ns2__SignedAttributesType*)q;
		break;
	case SOAP_TYPE_ns2__UnsignedAttributesBasicType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__UnsignedAttributesBasicType type=%d location=%p object=%p\n", t, p, q));
		*(ns2__UnsignedAttributesBasicType*)p = *(ns2__UnsignedAttributesBasicType*)q;
		break;
	case SOAP_TYPE_ns2__ResponseResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ResponseResult type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ResponseResult*)p = *(ns2__ResponseResult*)q;
		break;
	case SOAP_TYPE_ns5__SignatureType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__SignatureType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__SignatureType*)p = *(ns5__SignatureType*)q;
		break;
	case SOAP_TYPE_ns5__SignedInfoType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__SignedInfoType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__SignedInfoType*)p = *(ns5__SignedInfoType*)q;
		break;
	case SOAP_TYPE_ns5__CanonicalizationMethodType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__CanonicalizationMethodType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__CanonicalizationMethodType*)p = *(ns5__CanonicalizationMethodType*)q;
		break;
	case SOAP_TYPE_ns5__SignatureMethodType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__SignatureMethodType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__SignatureMethodType*)p = *(ns5__SignatureMethodType*)q;
		break;
	case SOAP_TYPE_ns5__ReferenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__ReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__ReferenceType*)p = *(ns5__ReferenceType*)q;
		break;
	case SOAP_TYPE_ns5__TransformsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__TransformsType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__TransformsType*)p = *(ns5__TransformsType*)q;
		break;
	case SOAP_TYPE_ns5__TransformType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__TransformType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__TransformType*)p = *(ns5__TransformType*)q;
		break;
	case SOAP_TYPE_ns5__DigestMethodType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__DigestMethodType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__DigestMethodType*)p = *(ns5__DigestMethodType*)q;
		break;
	case SOAP_TYPE_ns5__KeyInfoType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__KeyInfoType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__KeyInfoType*)p = *(ns5__KeyInfoType*)q;
		break;
	case SOAP_TYPE_ns5__X509DataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__X509DataType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__X509DataType*)p = *(ns5__X509DataType*)q;
		break;
	case SOAP_TYPE__ns5__union_ObjectType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns5__union_ObjectType type=%d location=%p object=%p\n", t, p, q));
		*(union _ns5__union_ObjectType*)p = *(union _ns5__union_ObjectType*)q;
		break;
	case SOAP_TYPE_ns5__ObjectType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__ObjectType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__ObjectType*)p = *(ns5__ObjectType*)q;
		break;
	case SOAP_TYPE_ns3__AttributeType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__AttributeType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__AttributeType*)p = *(ns3__AttributeType*)q;
		break;
	case SOAP_TYPE_ns3__AttributeSupplierType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__AttributeSupplierType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__AttributeSupplierType*)p = *(ns3__AttributeSupplierType*)q;
		break;
	case SOAP_TYPE_ns3__PersonalDataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__PersonalDataType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__PersonalDataType*)p = *(ns3__PersonalDataType*)q;
		break;
	case SOAP_TYPE_ns3__ExtraIDListType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ExtraIDListType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ExtraIDListType*)p = *(ns3__ExtraIDListType*)q;
		break;
	case SOAP_TYPE_ns3__ExtraIDType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ExtraIDType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ExtraIDType*)p = *(ns3__ExtraIDType*)q;
		break;
	case SOAP_TYPE_ns3__MainAttributeType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__MainAttributeType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__MainAttributeType*)p = *(ns3__MainAttributeType*)q;
		break;
	case SOAP_TYPE_ns3__LegalActListType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__LegalActListType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__LegalActListType*)p = *(ns3__LegalActListType*)q;
		break;
	case SOAP_TYPE_ns3__SubAttributeListType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__SubAttributeListType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__SubAttributeListType*)p = *(ns3__SubAttributeListType*)q;
		break;
	case SOAP_TYPE_ns3__SubAttributeType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__SubAttributeType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__SubAttributeType*)p = *(ns3__SubAttributeType*)q;
		break;
	case SOAP_TYPE_ns3__ResponseCodeStatusType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ResponseCodeStatusType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ResponseCodeStatusType*)p = *(ns3__ResponseCodeStatusType*)q;
		break;
	case SOAP_TYPE_ns6__QualifyingPropertiesType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__QualifyingPropertiesType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__QualifyingPropertiesType*)p = *(ns6__QualifyingPropertiesType*)q;
		break;
	case SOAP_TYPE_ns6__SignedPropertiesType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__SignedPropertiesType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__SignedPropertiesType*)p = *(ns6__SignedPropertiesType*)q;
		break;
	case SOAP_TYPE_ns6__SignedSignaturePropertiesType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__SignedSignaturePropertiesType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__SignedSignaturePropertiesType*)p = *(ns6__SignedSignaturePropertiesType*)q;
		break;
	case SOAP_TYPE_ns6__SigningCertificateType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__SigningCertificateType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__SigningCertificateType*)p = *(ns6__SigningCertificateType*)q;
		break;
	case SOAP_TYPE_ns6__CertType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__CertType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__CertType*)p = *(ns6__CertType*)q;
		break;
	case SOAP_TYPE_ns6__CertDigestType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__CertDigestType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__CertDigestType*)p = *(ns6__CertDigestType*)q;
		break;
	case SOAP_TYPE_ns6__IssuerSerialType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__IssuerSerialType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__IssuerSerialType*)p = *(ns6__IssuerSerialType*)q;
		break;
	case SOAP_TYPE_ns6__SignerRoleType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__SignerRoleType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__SignerRoleType*)p = *(ns6__SignerRoleType*)q;
		break;
	case SOAP_TYPE_ns6__ClaimedRolesListType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__ClaimedRolesListType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__ClaimedRolesListType*)p = *(ns6__ClaimedRolesListType*)q;
		break;
	case SOAP_TYPE_ns6__ClaimedRoleType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__ClaimedRoleType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__ClaimedRoleType*)p = *(ns6__ClaimedRoleType*)q;
		break;
	case SOAP_TYPE_ns6__UnsignedPropertiesType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__UnsignedPropertiesType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__UnsignedPropertiesType*)p = *(ns6__UnsignedPropertiesType*)q;
		break;
	case SOAP_TYPE_ns6__UnsignedSignaturePropertiesType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__UnsignedSignaturePropertiesType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__UnsignedSignaturePropertiesType*)p = *(ns6__UnsignedSignaturePropertiesType*)q;
		break;
	case SOAP_TYPE_ns6__CounterSignatureType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__CounterSignatureType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__CounterSignatureType*)p = *(ns6__CounterSignatureType*)q;
		break;
	case SOAP_TYPE_ns6__SignatureTimeStampType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__SignatureTimeStampType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__SignatureTimeStampType*)p = *(ns6__SignatureTimeStampType*)q;
		break;
	case SOAP_TYPE_ns6__CompleteCertificateRefsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__CompleteCertificateRefsType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__CompleteCertificateRefsType*)p = *(ns6__CompleteCertificateRefsType*)q;
		break;
	case SOAP_TYPE_ns6__CertRefsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__CertRefsType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__CertRefsType*)p = *(ns6__CertRefsType*)q;
		break;
	case SOAP_TYPE_ns6__CompleteRevocationRefsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__CompleteRevocationRefsType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__CompleteRevocationRefsType*)p = *(ns6__CompleteRevocationRefsType*)q;
		break;
	case SOAP_TYPE_ns6__CRLRefsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__CRLRefsType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__CRLRefsType*)p = *(ns6__CRLRefsType*)q;
		break;
	case SOAP_TYPE_ns6__CRLRefType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__CRLRefType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__CRLRefType*)p = *(ns6__CRLRefType*)q;
		break;
	case SOAP_TYPE_ns6__DigestAlgAndValueType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__DigestAlgAndValueType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__DigestAlgAndValueType*)p = *(ns6__DigestAlgAndValueType*)q;
		break;
	case SOAP_TYPE_ns6__CRLIdentifierType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__CRLIdentifierType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__CRLIdentifierType*)p = *(ns6__CRLIdentifierType*)q;
		break;
	case SOAP_TYPE_ns6__OCSPRefsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__OCSPRefsType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__OCSPRefsType*)p = *(ns6__OCSPRefsType*)q;
		break;
	case SOAP_TYPE_ns6__OCSPRefType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__OCSPRefType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__OCSPRefType*)p = *(ns6__OCSPRefType*)q;
		break;
	case SOAP_TYPE_ns6__OCSPIdentifierType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__OCSPIdentifierType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__OCSPIdentifierType*)p = *(ns6__OCSPIdentifierType*)q;
		break;
	case SOAP_TYPE_ns6__ResponderIDType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__ResponderIDType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__ResponderIDType*)p = *(ns6__ResponderIDType*)q;
		break;
	case SOAP_TYPE_ns6__SigAndRefsTimeStampType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__SigAndRefsTimeStampType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__SigAndRefsTimeStampType*)p = *(ns6__SigAndRefsTimeStampType*)q;
		break;
	case SOAP_TYPE_ns6__CertificateValuesType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__CertificateValuesType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__CertificateValuesType*)p = *(ns6__CertificateValuesType*)q;
		break;
	case SOAP_TYPE_ns6__RevocationValuesType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__RevocationValuesType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__RevocationValuesType*)p = *(ns6__RevocationValuesType*)q;
		break;
	case SOAP_TYPE_ns6__CRLValuesType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__CRLValuesType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__CRLValuesType*)p = *(ns6__CRLValuesType*)q;
		break;
	case SOAP_TYPE_ns6__OCSPValuesType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__OCSPValuesType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__OCSPValuesType*)p = *(ns6__OCSPValuesType*)q;
		break;
	case SOAP_TYPE_ns6__ArchiveTimeStampType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__ArchiveTimeStampType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__ArchiveTimeStampType*)p = *(ns6__ArchiveTimeStampType*)q;
		break;
	case SOAP_TYPE_ns7__SVGListType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__SVGListType type=%d location=%p object=%p\n", t, p, q));
		*(ns7__SVGListType*)p = *(ns7__SVGListType*)q;
		break;
	case SOAP_TYPE_ns9__AttributeSupplierResponseType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns9__AttributeSupplierResponseType type=%d location=%p object=%p\n", t, p, q));
		*(ns9__AttributeSupplierResponseType*)p = *(ns9__AttributeSupplierResponseType*)q;
		break;
	case SOAP_TYPE_ns1__PersonalData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__PersonalData type=%d location=%p object=%p\n", t, p, q));
		*(ns1__PersonalData*)p = *(ns1__PersonalData*)q;
		break;
	case SOAP_TYPE_ns1__AttributeListType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__AttributeListType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__AttributeListType*)p = *(ns1__AttributeListType*)q;
		break;
	case SOAP_TYPE_ns1__AttributeType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__AttributeType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__AttributeType*)p = *(ns1__AttributeType*)q;
		break;
	case SOAP_TYPE_ns1__AttributeSupplierType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__AttributeSupplierType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__AttributeSupplierType*)p = *(ns1__AttributeSupplierType*)q;
		break;
	case SOAP_TYPE_ns1__MainAttributeType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__MainAttributeType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__MainAttributeType*)p = *(ns1__MainAttributeType*)q;
		break;
	case SOAP_TYPE_ns1__LegalActListType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__LegalActListType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__LegalActListType*)p = *(ns1__LegalActListType*)q;
		break;
	case SOAP_TYPE_ns1__SubAttributeListType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubAttributeListType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubAttributeListType*)p = *(ns1__SubAttributeListType*)q;
		break;
	case SOAP_TYPE_ns1__SubAttributeType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubAttributeType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubAttributeType*)p = *(ns1__SubAttributeType*)q;
		break;
	case SOAP_TYPE_ns1__Status:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Status type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Status*)p = *(ns1__Status*)q;
		break;
	case SOAP_TYPE_ns1__TransactionTypeList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__TransactionTypeList type=%d location=%p object=%p\n", t, p, q));
		*(ns1__TransactionTypeList*)p = *(ns1__TransactionTypeList*)q;
		break;
	case SOAP_TYPE_ns1__TransactionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__TransactionType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__TransactionType*)p = *(ns1__TransactionType*)q;
		break;
	case SOAP_TYPE__ns1__AuthorizationRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__AuthorizationRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__AuthorizationRequest*)p = *(_ns1__AuthorizationRequest*)q;
		break;
	case SOAP_TYPE__ns1__AuthorizationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__AuthorizationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__AuthorizationResponse*)p = *(_ns1__AuthorizationResponse*)q;
		break;
	case SOAP_TYPE__ns1__SignatureRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SignatureRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SignatureRequest*)p = *(_ns1__SignatureRequest*)q;
		break;
	case SOAP_TYPE__ns1__SignatureResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SignatureResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SignatureResponse*)p = *(_ns1__SignatureResponse*)q;
		break;
	case SOAP_TYPE_ns5__X509CertificateType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__X509CertificateType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__X509CertificateType*)p = *(ns5__X509CertificateType*)q;
		break;
	case SOAP_TYPE_ns5__DigestValueType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__DigestValueType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__DigestValueType*)p = *(ns5__DigestValueType*)q;
		break;
	case SOAP_TYPE_ns5__SignatureValueType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__SignatureValueType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__SignatureValueType*)p = *(ns5__SignatureValueType*)q;
		break;
	case SOAP_TYPE_ns6__EncapsulatedX509CertificateType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__EncapsulatedX509CertificateType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__EncapsulatedX509CertificateType*)p = *(ns6__EncapsulatedX509CertificateType*)q;
		break;
	case SOAP_TYPE_ns6__EncapsulatedCRLValueType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__EncapsulatedCRLValueType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__EncapsulatedCRLValueType*)p = *(ns6__EncapsulatedCRLValueType*)q;
		break;
	case SOAP_TYPE_ns6__EncapsulatedOCSPValueType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__EncapsulatedOCSPValueType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__EncapsulatedOCSPValueType*)p = *(ns6__EncapsulatedOCSPValueType*)q;
		break;
	case SOAP_TYPE_wsa__EndpointReferenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa__EndpointReferenceType*)p = *(struct wsa__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE_wsa__ReferencePropertiesType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa__ReferencePropertiesType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa__ReferencePropertiesType*)p = *(struct wsa__ReferencePropertiesType*)q;
		break;
	case SOAP_TYPE_wsa__ReferenceParametersType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa__ReferenceParametersType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa__ReferenceParametersType*)p = *(struct wsa__ReferenceParametersType*)q;
		break;
	case SOAP_TYPE_wsa__ServiceNameType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa__ServiceNameType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa__ServiceNameType*)p = *(struct wsa__ServiceNameType*)q;
		break;
	case SOAP_TYPE_wsa__Relationship:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa__Relationship type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa__Relationship*)p = *(struct wsa__Relationship*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	case SOAP_TYPE___ns1__Attributes:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Attributes type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Attributes*)p = *(struct __ns1__Attributes*)q;
		break;
	case SOAP_TYPE___ns2__Authorization:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns2__Authorization type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns2__Authorization*)p = *(struct __ns2__Authorization*)q;
		break;
	case SOAP_TYPE___ns3__Signature:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__Signature type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__Signature*)p = *(struct __ns3__Signature*)q;
		break;
	case SOAP_TYPE___ns8__AttributeSuppliers:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns8__AttributeSuppliers type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns8__AttributeSuppliers*)p = *(struct __ns8__AttributeSuppliers*)q;
		break;
	case SOAP_TYPE_xsd__ID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__anyURI:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__date:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__integer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns5__X509IssuerNameType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns5__X509SerialNumberType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns4__ProcessIDType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns4__NameType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns4__ValidityType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns4__DateType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns4__NICType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns4__NIPCType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns4__CompanyNameType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns4__ExtraIDValueType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns4__AttributeIDType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns4__LegalActType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns4__SubAttributeValueType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns4__DescriptionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns4__ResponseCodeType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns4__ResponseCodeMessage:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns6__EncapsulatedTimeStampType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__base64Binary type=%d location=%p object=%p\n", t, p, q));
		*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
		break;
	case SOAP_TYPE_ns6__IssuerType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns6__NumberType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns6__ByNameType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns7__SVGType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__base64Binary type=%d location=%p object=%p\n", t, p, q));
		*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
		break;
	case SOAP_TYPE__ns2__AttributeRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__AttributeRequestType type=%d location=%p object=%p\n", t, p, q));
		*(ns2__AttributeRequestType*)p = *(ns2__AttributeRequestType*)q;
		break;
	case SOAP_TYPE__ns2__AttributeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__AttributeResponseType type=%d location=%p object=%p\n", t, p, q));
		*(ns2__AttributeResponseType*)p = *(ns2__AttributeResponseType*)q;
		break;
	case SOAP_TYPE__ns2__PSAAttributeRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PSAAttributeRequestType type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PSAAttributeRequestType*)p = *(ns2__PSAAttributeRequestType*)q;
		break;
	case SOAP_TYPE__ns2__SingleAttributeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__SingleAttributeResponseType type=%d location=%p object=%p\n", t, p, q));
		*(ns2__SingleAttributeResponseType*)p = *(ns2__SingleAttributeResponseType*)q;
		break;
	case SOAP_TYPE__ns5__Signature:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__SignatureType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__SignatureType*)p = *(ns5__SignatureType*)q;
		break;
	case SOAP_TYPE__ns5__SignedInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__SignedInfoType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__SignedInfoType*)p = *(ns5__SignedInfoType*)q;
		break;
	case SOAP_TYPE__ns5__CanonicalizationMethod:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__CanonicalizationMethodType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__CanonicalizationMethodType*)p = *(ns5__CanonicalizationMethodType*)q;
		break;
	case SOAP_TYPE__ns5__SignatureMethod:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__SignatureMethodType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__SignatureMethodType*)p = *(ns5__SignatureMethodType*)q;
		break;
	case SOAP_TYPE__ns5__Reference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__ReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__ReferenceType*)p = *(ns5__ReferenceType*)q;
		break;
	case SOAP_TYPE__ns5__Transforms:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__TransformsType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__TransformsType*)p = *(ns5__TransformsType*)q;
		break;
	case SOAP_TYPE__ns5__Transform:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__TransformType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__TransformType*)p = *(ns5__TransformType*)q;
		break;
	case SOAP_TYPE__ns5__DigestMethod:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__DigestMethodType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__DigestMethodType*)p = *(ns5__DigestMethodType*)q;
		break;
	case SOAP_TYPE__ns5__KeyInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__KeyInfoType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__KeyInfoType*)p = *(ns5__KeyInfoType*)q;
		break;
	case SOAP_TYPE__ns5__X509Data:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__X509DataType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__X509DataType*)p = *(ns5__X509DataType*)q;
		break;
	case SOAP_TYPE__ns5__Object:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__ObjectType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__ObjectType*)p = *(ns5__ObjectType*)q;
		break;
	case SOAP_TYPE__ns5__X509Certificate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__X509CertificateType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__X509CertificateType*)p = *(ns5__X509CertificateType*)q;
		break;
	case SOAP_TYPE__ns5__DigestValue:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__DigestValueType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__DigestValueType*)p = *(ns5__DigestValueType*)q;
		break;
	case SOAP_TYPE__ns5__SignatureValue:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__SignatureValueType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__SignatureValueType*)p = *(ns5__SignatureValueType*)q;
		break;
	case SOAP_TYPE__ns5__X509IssuerName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE__ns5__X509SerialNumber:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE__ns3__Attribute:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__AttributeType type=%d location=%p object=%p\n", t, p, q));
		*(ns3__AttributeType*)p = *(ns3__AttributeType*)q;
		break;
	case SOAP_TYPE__ns3__SignatureAttribute:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__SignatureType type=%d location=%p object=%p\n", t, p, q));
		*(ns5__SignatureType*)p = *(ns5__SignatureType*)q;
		break;
	case SOAP_TYPE__ns6__QualifyingProperties:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__QualifyingPropertiesType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__QualifyingPropertiesType*)p = *(ns6__QualifyingPropertiesType*)q;
		break;
	case SOAP_TYPE__ns6__SignedProperties:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__SignedPropertiesType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__SignedPropertiesType*)p = *(ns6__SignedPropertiesType*)q;
		break;
	case SOAP_TYPE__ns6__SignedSignatureProperties:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__SignedSignaturePropertiesType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__SignedSignaturePropertiesType*)p = *(ns6__SignedSignaturePropertiesType*)q;
		break;
	case SOAP_TYPE__ns6__SigningCertificate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__SigningCertificateType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__SigningCertificateType*)p = *(ns6__SigningCertificateType*)q;
		break;
	case SOAP_TYPE__ns6__Cert:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__CertType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__CertType*)p = *(ns6__CertType*)q;
		break;
	case SOAP_TYPE__ns6__CertDigest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__CertDigestType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__CertDigestType*)p = *(ns6__CertDigestType*)q;
		break;
	case SOAP_TYPE__ns6__IssuerSerial:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__IssuerSerialType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__IssuerSerialType*)p = *(ns6__IssuerSerialType*)q;
		break;
	case SOAP_TYPE__ns6__SignerRole:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__SignerRoleType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__SignerRoleType*)p = *(ns6__SignerRoleType*)q;
		break;
	case SOAP_TYPE__ns6__ClaimedRoles:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__ClaimedRolesListType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__ClaimedRolesListType*)p = *(ns6__ClaimedRolesListType*)q;
		break;
	case SOAP_TYPE__ns6__ClaimedRole:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__ClaimedRoleType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__ClaimedRoleType*)p = *(ns6__ClaimedRoleType*)q;
		break;
	case SOAP_TYPE__ns6__UnsignedProperties:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__UnsignedPropertiesType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__UnsignedPropertiesType*)p = *(ns6__UnsignedPropertiesType*)q;
		break;
	case SOAP_TYPE__ns6__UnsignedSignatureProperties:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__UnsignedSignaturePropertiesType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__UnsignedSignaturePropertiesType*)p = *(ns6__UnsignedSignaturePropertiesType*)q;
		break;
	case SOAP_TYPE__ns6__CounterSignature:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__CounterSignatureType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__CounterSignatureType*)p = *(ns6__CounterSignatureType*)q;
		break;
	case SOAP_TYPE__ns6__SignatureTimeStamp:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__SignatureTimeStampType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__SignatureTimeStampType*)p = *(ns6__SignatureTimeStampType*)q;
		break;
	case SOAP_TYPE__ns6__EncapsulatedTimeStamp:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__base64Binary type=%d location=%p object=%p\n", t, p, q));
		*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
		break;
	case SOAP_TYPE__ns6__CompleteCertificateRefs:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__CompleteCertificateRefsType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__CompleteCertificateRefsType*)p = *(ns6__CompleteCertificateRefsType*)q;
		break;
	case SOAP_TYPE__ns6__CertRefs:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__CertRefsType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__CertRefsType*)p = *(ns6__CertRefsType*)q;
		break;
	case SOAP_TYPE__ns6__CompleteRevocationRefs:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__CompleteRevocationRefsType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__CompleteRevocationRefsType*)p = *(ns6__CompleteRevocationRefsType*)q;
		break;
	case SOAP_TYPE__ns6__CRLRefs:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__CRLRefsType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__CRLRefsType*)p = *(ns6__CRLRefsType*)q;
		break;
	case SOAP_TYPE__ns6__CRLRef:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__CRLRefType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__CRLRefType*)p = *(ns6__CRLRefType*)q;
		break;
	case SOAP_TYPE__ns6__DigestAlgAndValue:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__DigestAlgAndValueType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__DigestAlgAndValueType*)p = *(ns6__DigestAlgAndValueType*)q;
		break;
	case SOAP_TYPE__ns6__CRLIdentifier:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__CRLIdentifierType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__CRLIdentifierType*)p = *(ns6__CRLIdentifierType*)q;
		break;
	case SOAP_TYPE__ns6__OCSPRefs:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__OCSPRefsType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__OCSPRefsType*)p = *(ns6__OCSPRefsType*)q;
		break;
	case SOAP_TYPE__ns6__OCSPRef:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__OCSPRefType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__OCSPRefType*)p = *(ns6__OCSPRefType*)q;
		break;
	case SOAP_TYPE__ns6__OCSPIdentifier:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__OCSPIdentifierType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__OCSPIdentifierType*)p = *(ns6__OCSPIdentifierType*)q;
		break;
	case SOAP_TYPE__ns6__ResponderID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__ResponderIDType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__ResponderIDType*)p = *(ns6__ResponderIDType*)q;
		break;
	case SOAP_TYPE__ns6__SigAndRefsTimeStamp:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__SigAndRefsTimeStampType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__SigAndRefsTimeStampType*)p = *(ns6__SigAndRefsTimeStampType*)q;
		break;
	case SOAP_TYPE__ns6__CertificateValues:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__CertificateValuesType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__CertificateValuesType*)p = *(ns6__CertificateValuesType*)q;
		break;
	case SOAP_TYPE__ns6__EncapsulatedX509Certificate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__EncapsulatedX509CertificateType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__EncapsulatedX509CertificateType*)p = *(ns6__EncapsulatedX509CertificateType*)q;
		break;
	case SOAP_TYPE__ns6__RevocationValues:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__RevocationValuesType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__RevocationValuesType*)p = *(ns6__RevocationValuesType*)q;
		break;
	case SOAP_TYPE__ns6__CRLValues:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__CRLValuesType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__CRLValuesType*)p = *(ns6__CRLValuesType*)q;
		break;
	case SOAP_TYPE__ns6__EncapsulatedCRLValue:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__EncapsulatedCRLValueType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__EncapsulatedCRLValueType*)p = *(ns6__EncapsulatedCRLValueType*)q;
		break;
	case SOAP_TYPE__ns6__OCSPValues:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__OCSPValuesType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__OCSPValuesType*)p = *(ns6__OCSPValuesType*)q;
		break;
	case SOAP_TYPE__ns6__EncapsulatedOCSPValue:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__EncapsulatedOCSPValueType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__EncapsulatedOCSPValueType*)p = *(ns6__EncapsulatedOCSPValueType*)q;
		break;
	case SOAP_TYPE__ns6__ArchiveTimeStamp:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns6__ArchiveTimeStampType type=%d location=%p object=%p\n", t, p, q));
		*(ns6__ArchiveTimeStampType*)p = *(ns6__ArchiveTimeStampType*)q;
		break;
	case SOAP_TYPE__ns7__SVGList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__SVGListType type=%d location=%p object=%p\n", t, p, q));
		*(ns7__SVGListType*)p = *(ns7__SVGListType*)q;
		break;
	case SOAP_TYPE__ns7__SVG:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__base64Binary type=%d location=%p object=%p\n", t, p, q));
		*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
		break;
	case SOAP_TYPE__ns9__AttributeSupplierResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns9__AttributeSupplierResponseType type=%d location=%p object=%p\n", t, p, q));
		*(ns9__AttributeSupplierResponseType*)p = *(ns9__AttributeSupplierResponseType*)q;
		break;
	case SOAP_TYPE__wsa__EndpointReference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa__EndpointReferenceType*)p = *(struct wsa__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa__RelatesTo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa__Relationship type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa__Relationship*)p = *(struct wsa__Relationship*)q;
		break;
	case SOAP_TYPE__wsa__From:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa__EndpointReferenceType*)p = *(struct wsa__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa__ReplyTo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa__EndpointReferenceType*)p = *(struct wsa__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa__FaultTo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa__EndpointReferenceType*)p = *(struct wsa__EndpointReferenceType*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type = %d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	a = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return a;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_new_unsignedByte(struct soap *soap, int n)
{
	unsigned char *a = static_cast<unsigned char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned char)));
	for (unsigned char *p = a; p && n--; ++p)
		soap_default_unsignedByte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	if (soap_out_unsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	a = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return a;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_new_unsignedInt(struct soap *soap, int n)
{
	unsigned int *a = static_cast<unsigned int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned int)));
	for (unsigned int *p = a; p && n--; ++p)
		soap_default_unsignedInt(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out_unsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ProducedAtType(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_ns6__ProducedAtType);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_ns6__ProducedAtType(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_ns6__ProducedAtType);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__ProducedAtType(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_ns6__ProducedAtType(soap, tag ? tag : "ns6:ProducedAtType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_ns6__ProducedAtType(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ProducedAtType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__IssueTimeType(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_ns6__IssueTimeType);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_ns6__IssueTimeType(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_ns6__IssueTimeType);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__IssueTimeType(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_ns6__IssueTimeType(soap, tag ? tag : "ns6:IssueTimeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_ns6__IssueTimeType(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__IssueTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__SigningTimeType(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_ns6__SigningTimeType);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_ns6__SigningTimeType(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_ns6__SigningTimeType);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__SigningTimeType(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_ns6__SigningTimeType(soap, tag ? tag : "ns6:SigningTimeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_ns6__SigningTimeType(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__SigningTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n)
{
	time_t *a = static_cast<time_t *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(time_t)));
	for (time_t *p = a; p && n--; ++p)
		soap_default_dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa__FaultSubcodeValues[] =
{	{ (LONG64)wsa__InvalidMessageInformationHeader, "wsa:InvalidMessageInformationHeader" },
	{ (LONG64)wsa__MessageInformationHeaderRequired, "wsa:MessageInformationHeaderRequired" },
	{ (LONG64)wsa__DestinationUnreachable, "wsa:DestinationUnreachable" },
	{ (LONG64)wsa__ActionNotSupported, "wsa:ActionNotSupported" },
	{ (LONG64)wsa__EndpointUnavailable, "wsa:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa__FaultSubcodeValues2s(struct soap *soap, enum wsa__FaultSubcodeValues n)
{	const char *s = soap_code_str(soap_codes_wsa__FaultSubcodeValues, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__FaultSubcodeValues(struct soap *soap, const char *tag, int id, const enum wsa__FaultSubcodeValues *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__FaultSubcodeValues), type) || soap_send(soap, soap_wsa__FaultSubcodeValues2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa__FaultSubcodeValues(struct soap *soap, const char *s, enum wsa__FaultSubcodeValues *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsa__FaultSubcodeValues, t);
	if (map)
		*a = (enum wsa__FaultSubcodeValues)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa__FaultSubcodeValues)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa__FaultSubcodeValues * SOAP_FMAC4 soap_in_wsa__FaultSubcodeValues(struct soap *soap, const char *tag, enum wsa__FaultSubcodeValues *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa__FaultSubcodeValues *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__FaultSubcodeValues, sizeof(enum wsa__FaultSubcodeValues), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa__FaultSubcodeValues(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa__FaultSubcodeValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__FaultSubcodeValues, SOAP_TYPE_wsa__FaultSubcodeValues, sizeof(enum wsa__FaultSubcodeValues), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa__FaultSubcodeValues * SOAP_FMAC4 soap_new_wsa__FaultSubcodeValues(struct soap *soap, int n)
{
	enum wsa__FaultSubcodeValues *a = static_cast<enum wsa__FaultSubcodeValues *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum wsa__FaultSubcodeValues)));
	for (enum wsa__FaultSubcodeValues *p = a; p && n--; ++p)
		soap_default_wsa__FaultSubcodeValues(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__FaultSubcodeValues(struct soap *soap, const enum wsa__FaultSubcodeValues *a, const char *tag, const char *type)
{
	if (soap_out_wsa__FaultSubcodeValues(soap, tag ? tag : "wsa:FaultSubcodeValues", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa__FaultSubcodeValues * SOAP_FMAC4 soap_get_wsa__FaultSubcodeValues(struct soap *soap, enum wsa__FaultSubcodeValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__FaultSubcodeValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa__RelationshipTypeValues[] =
{	{ (LONG64)wsa__Reply, "wsa:Reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa__RelationshipTypeValues2s(struct soap *soap, enum wsa__RelationshipTypeValues n)
{	const char *s = soap_code_str(soap_codes_wsa__RelationshipTypeValues, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__RelationshipTypeValues(struct soap *soap, const char *tag, int id, const enum wsa__RelationshipTypeValues *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__RelationshipTypeValues), type) || soap_send(soap, soap_wsa__RelationshipTypeValues2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa__RelationshipTypeValues(struct soap *soap, const char *s, enum wsa__RelationshipTypeValues *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsa__RelationshipTypeValues, t);
	if (map)
		*a = (enum wsa__RelationshipTypeValues)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa__RelationshipTypeValues)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa__RelationshipTypeValues * SOAP_FMAC4 soap_in_wsa__RelationshipTypeValues(struct soap *soap, const char *tag, enum wsa__RelationshipTypeValues *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa__RelationshipTypeValues *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__RelationshipTypeValues, sizeof(enum wsa__RelationshipTypeValues), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa__RelationshipTypeValues(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa__RelationshipTypeValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__RelationshipTypeValues, SOAP_TYPE_wsa__RelationshipTypeValues, sizeof(enum wsa__RelationshipTypeValues), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa__RelationshipTypeValues * SOAP_FMAC4 soap_new_wsa__RelationshipTypeValues(struct soap *soap, int n)
{
	enum wsa__RelationshipTypeValues *a = static_cast<enum wsa__RelationshipTypeValues *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum wsa__RelationshipTypeValues)));
	for (enum wsa__RelationshipTypeValues *p = a; p && n--; ++p)
		soap_default_wsa__RelationshipTypeValues(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__RelationshipTypeValues(struct soap *soap, const enum wsa__RelationshipTypeValues *a, const char *tag, const char *type)
{
	if (soap_out_wsa__RelationshipTypeValues(soap, tag ? tag : "wsa:RelationshipTypeValues", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa__RelationshipTypeValues * SOAP_FMAC4 soap_get_wsa__RelationshipTypeValues(struct soap *soap, enum wsa__RelationshipTypeValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__RelationshipTypeValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2bool(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_new_bool(struct soap *soap, int n)
{
	bool *a = static_cast<bool *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(bool)));
	for (bool *p = a; p && n--; ++p)
		soap_default_bool(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns7__SVG2s(struct soap *soap, xsd__base64Binary a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__SVG(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE__ns7__SVG);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE__ns7__SVG, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns7__SVG(struct soap *soap, const char *s, xsd__base64Binary *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in__ns7__SVG(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__SVG, sizeof(xsd__base64Binary), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__SVG, SOAP_TYPE__ns7__SVG, sizeof(xsd__base64Binary), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns6__EncapsulatedTimeStamp2s(struct soap *soap, xsd__base64Binary a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__EncapsulatedTimeStamp(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE__ns6__EncapsulatedTimeStamp);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE__ns6__EncapsulatedTimeStamp, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns6__EncapsulatedTimeStamp(struct soap *soap, const char *s, xsd__base64Binary *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in__ns6__EncapsulatedTimeStamp(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__EncapsulatedTimeStamp, sizeof(xsd__base64Binary), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__EncapsulatedTimeStamp, SOAP_TYPE__ns6__EncapsulatedTimeStamp, sizeof(xsd__base64Binary), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_ns7__SVGType(struct soap *soap, xsd__base64Binary *a)
{
	a->soap = soap;
	a->__ptr = NULL;
	a->__size = 0;
	a->id = NULL;
	a->type = NULL;
	a->options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns7__SVGType(struct soap *soap, const xsd__base64Binary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptr)
		(void)soap_attachment_reference(soap, a, a->__ptr, a->__size, SOAP_TYPE_ns7__SVGType, a->id, a->type);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns7__SVGType2s(struct soap *soap, xsd__base64Binary a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SVGType(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE_ns7__SVGType);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_ns7__SVGType, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns7__SVGType(struct soap *soap, const char *s, xsd__base64Binary *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_ns7__SVGType(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SVGType, sizeof(xsd__base64Binary), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SVGType, SOAP_TYPE_ns7__SVGType, sizeof(xsd__base64Binary), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__SVGType(struct soap *soap, const xsd__base64Binary *a, const char *tag, const char *type)
{
	if (soap_out_ns7__SVGType(soap, tag ? tag : "ns7:SVGType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_ns7__SVGType(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SVGType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__ByNameType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ByNameType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns6__ByNameType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns6__ByNameType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns6__ByNameType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns6__ByNameType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase), 0, SOAP_TYPE_ns6__ByNameType, SOAP_TYPE_ns6__ByNameType, sizeof(std::string), 0, SCAP_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__ByNameType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns6__ByNameType(soap, tag ? tag : "ns6:ByNameType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns6__ByNameType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ByNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__IssuerType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__IssuerType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns6__IssuerType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns6__IssuerType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns6__IssuerType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns6__IssuerType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase), 0, SOAP_TYPE_ns6__IssuerType, SOAP_TYPE_ns6__IssuerType, sizeof(std::string), 0, SCAP_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__IssuerType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns6__IssuerType(soap, tag ? tag : "ns6:IssuerType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns6__IssuerType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__IssuerType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_ns6__EncapsulatedTimeStampType(struct soap *soap, xsd__base64Binary *a)
{
	a->soap = soap;
	a->__ptr = NULL;
	a->__size = 0;
	a->id = NULL;
	a->type = NULL;
	a->options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__EncapsulatedTimeStampType(struct soap *soap, const xsd__base64Binary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptr)
		(void)soap_attachment_reference(soap, a, a->__ptr, a->__size, SOAP_TYPE_ns6__EncapsulatedTimeStampType, a->id, a->type);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__EncapsulatedTimeStampType2s(struct soap *soap, xsd__base64Binary a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__EncapsulatedTimeStampType(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE_ns6__EncapsulatedTimeStampType);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_ns6__EncapsulatedTimeStampType, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__EncapsulatedTimeStampType(struct soap *soap, const char *s, xsd__base64Binary *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_ns6__EncapsulatedTimeStampType(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__EncapsulatedTimeStampType, sizeof(xsd__base64Binary), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__EncapsulatedTimeStampType, SOAP_TYPE_ns6__EncapsulatedTimeStampType, sizeof(xsd__base64Binary), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__EncapsulatedTimeStampType(struct soap *soap, const xsd__base64Binary *a, const char *tag, const char *type)
{
	if (soap_out_ns6__EncapsulatedTimeStampType(soap, tag ? tag : "ns6:EncapsulatedTimeStampType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_ns6__EncapsulatedTimeStampType(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__EncapsulatedTimeStampType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__ResponseCodeMessage(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ResponseCodeMessage(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns4__ResponseCodeMessage), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns4__ResponseCodeMessage(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__ResponseCodeMessage, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, 1024, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__ResponseCodeMessage, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase), 0, SOAP_TYPE_ns4__ResponseCodeMessage, SOAP_TYPE_ns4__ResponseCodeMessage, sizeof(std::string), 0, SCAP_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ResponseCodeMessage(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns4__ResponseCodeMessage(soap, tag ? tag : "ns4:ResponseCodeMessage", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns4__ResponseCodeMessage(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ResponseCodeMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__ResponseCodeType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ResponseCodeType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns4__ResponseCodeType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns4__ResponseCodeType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__ResponseCodeType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, 5, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__ResponseCodeType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase), 0, SOAP_TYPE_ns4__ResponseCodeType, SOAP_TYPE_ns4__ResponseCodeType, sizeof(std::string), 0, SCAP_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ResponseCodeType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns4__ResponseCodeType(soap, tag ? tag : "ns4:ResponseCodeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns4__ResponseCodeType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ResponseCodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__DescriptionType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__DescriptionType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns4__DescriptionType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns4__DescriptionType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__DescriptionType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, 255, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__DescriptionType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase), 0, SOAP_TYPE_ns4__DescriptionType, SOAP_TYPE_ns4__DescriptionType, sizeof(std::string), 0, SCAP_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__DescriptionType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns4__DescriptionType(soap, tag ? tag : "ns4:DescriptionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns4__DescriptionType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__DescriptionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SubAttributeValueType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SubAttributeValueType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns4__SubAttributeValueType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns4__SubAttributeValueType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__SubAttributeValueType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, 255, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__SubAttributeValueType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase), 0, SOAP_TYPE_ns4__SubAttributeValueType, SOAP_TYPE_ns4__SubAttributeValueType, sizeof(std::string), 0, SCAP_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SubAttributeValueType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns4__SubAttributeValueType(soap, tag ? tag : "ns4:SubAttributeValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns4__SubAttributeValueType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SubAttributeValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__LegalActType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__LegalActType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns4__LegalActType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns4__LegalActType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__LegalActType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, 2048, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__LegalActType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase), 0, SOAP_TYPE_ns4__LegalActType, SOAP_TYPE_ns4__LegalActType, sizeof(std::string), 0, SCAP_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__LegalActType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns4__LegalActType(soap, tag ? tag : "ns4:LegalActType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns4__LegalActType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__LegalActType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__AttributeIDType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__AttributeIDType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns4__AttributeIDType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns4__AttributeIDType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__AttributeIDType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, 255, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__AttributeIDType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase), 0, SOAP_TYPE_ns4__AttributeIDType, SOAP_TYPE_ns4__AttributeIDType, sizeof(std::string), 0, SCAP_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__AttributeIDType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns4__AttributeIDType(soap, tag ? tag : "ns4:AttributeIDType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns4__AttributeIDType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__AttributeIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__ExtraIDValueType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ExtraIDValueType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns4__ExtraIDValueType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns4__ExtraIDValueType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__ExtraIDValueType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, 255, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__ExtraIDValueType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase), 0, SOAP_TYPE_ns4__ExtraIDValueType, SOAP_TYPE_ns4__ExtraIDValueType, sizeof(std::string), 0, SCAP_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ExtraIDValueType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns4__ExtraIDValueType(soap, tag ? tag : "ns4:ExtraIDValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns4__ExtraIDValueType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ExtraIDValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__CompanyNameType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__CompanyNameType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns4__CompanyNameType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns4__CompanyNameType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__CompanyNameType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, 255, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__CompanyNameType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase), 0, SOAP_TYPE_ns4__CompanyNameType, SOAP_TYPE_ns4__CompanyNameType, sizeof(std::string), 0, SCAP_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__CompanyNameType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns4__CompanyNameType(soap, tag ? tag : "ns4:CompanyNameType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns4__CompanyNameType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__CompanyNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__NIPCType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__NIPCType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns4__NIPCType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns4__NIPCType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__NIPCType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, 255, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__NIPCType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase), 0, SOAP_TYPE_ns4__NIPCType, SOAP_TYPE_ns4__NIPCType, sizeof(std::string), 0, SCAP_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__NIPCType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns4__NIPCType(soap, tag ? tag : "ns4:NIPCType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns4__NIPCType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__NIPCType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__NICType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__NICType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns4__NICType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns4__NICType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__NICType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, 255, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__NICType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase), 0, SOAP_TYPE_ns4__NICType, SOAP_TYPE_ns4__NICType, sizeof(std::string), 0, SCAP_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__NICType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns4__NICType(soap, tag ? tag : "ns4:NICType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns4__NICType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__NICType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__NameType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__NameType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns4__NameType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns4__NameType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__NameType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, 255, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__NameType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase), 0, SOAP_TYPE_ns4__NameType, SOAP_TYPE_ns4__NameType, sizeof(std::string), 0, SCAP_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__NameType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns4__NameType(soap, tag ? tag : "ns4:NameType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns4__NameType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__NameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__ProcessIDType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ProcessIDType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns4__ProcessIDType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns4__ProcessIDType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__ProcessIDType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, 40, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns4__ProcessIDType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase), 0, SOAP_TYPE_ns4__ProcessIDType, SOAP_TYPE_ns4__ProcessIDType, sizeof(std::string), 0, SCAP_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ProcessIDType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns4__ProcessIDType(soap, tag ? tag : "ns4:ProcessIDType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns4__ProcessIDType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ProcessIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__X509IssuerNameType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__X509IssuerNameType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns5__X509IssuerNameType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns5__X509IssuerNameType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns5__X509IssuerNameType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns5__X509IssuerNameType, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase), 0, SOAP_TYPE_ns5__X509IssuerNameType, SOAP_TYPE_ns5__X509IssuerNameType, sizeof(std::string), 0, SCAP_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__X509IssuerNameType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns5__X509IssuerNameType(soap, tag ? tag : "ns5:X509IssuerNameType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns5__X509IssuerNameType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__X509IssuerNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SignatureResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SignatureResponse::Status = NULL;
	this->_ns1__SignatureResponse::ProcessId = NULL;
	this->_ns1__SignatureResponse::DocumentSignature = NULL;
	/* transient soap skipped */
}

void _ns1__SignatureResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Status(soap, &this->_ns1__SignatureResponse::Status);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SignatureResponse::ProcessId);
	soap_serialize_PointerToxsd__base64Binary(soap, &this->_ns1__SignatureResponse::DocumentSignature);
#endif
}

int _ns1__SignatureResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SignatureResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SignatureResponse(struct soap *soap, const char *tag, int id, const _ns1__SignatureResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SignatureResponse), type))
		return soap->error;
	if (a->Status)
		soap_element_result(soap, "ns1:Status");
	if (!a->_ns1__SignatureResponse::Status)
	{	if (soap_element_empty(soap, "ns1:Status"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__Status(soap, "ns1:Status", -1, &a->_ns1__SignatureResponse::Status, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ProcessId", -1, &a->_ns1__SignatureResponse::ProcessId, ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "ns1:DocumentSignature", -1, &a->_ns1__SignatureResponse::DocumentSignature, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SignatureResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SignatureResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SignatureResponse * SOAP_FMAC4 soap_in__ns1__SignatureResponse(struct soap *soap, const char *tag, _ns1__SignatureResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SignatureResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SignatureResponse, sizeof(_ns1__SignatureResponse), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SignatureResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SignatureResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Status1 = 1;
	size_t soap_flag_ProcessId1 = 1;
	size_t soap_flag_DocumentSignature1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Status(soap, "ns1:Status", &a->_ns1__SignatureResponse::Status, "ns1:Status"))
				{	soap_flag_Status1--;
					continue;
				}
			}
			if (soap_flag_ProcessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ProcessId", &a->_ns1__SignatureResponse::ProcessId, "xsd:string"))
				{	soap_flag_ProcessId1--;
					continue;
				}
			}
			if (soap_flag_DocumentSignature1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__base64Binary(soap, "ns1:DocumentSignature", &a->_ns1__SignatureResponse::DocumentSignature, "xsd:base64Binary"))
				{	soap_flag_DocumentSignature1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:Status");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__SignatureResponse::Status))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__SignatureResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SignatureResponse, SOAP_TYPE__ns1__SignatureResponse, sizeof(_ns1__SignatureResponse), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SignatureResponse * SOAP_FMAC2 SCAP_instantiate__ns1__SignatureResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate__ns1__SignatureResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SignatureResponse *p;
	size_t k = sizeof(_ns1__SignatureResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SignatureResponse);
		if (p)
			((_ns1__SignatureResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SignatureResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SignatureResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SignatureResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SignatureResponse, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SignatureResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SignatureResponse(soap, tag ? tag : "ns1:SignatureResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SignatureResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SignatureResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SignatureResponse * SOAP_FMAC4 soap_get__ns1__SignatureResponse(struct soap *soap, _ns1__SignatureResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SignatureResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SignatureRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__SignatureRequest::AppId);
	soap_default_std__string(soap, &this->_ns1__SignatureRequest::ProcessId);
	this->_ns1__SignatureRequest::TOTP = NULL;
	this->_ns1__SignatureRequest::Hash.xsd__base64Binary::soap_default(soap);
	this->_ns1__SignatureRequest::Transaction = NULL;
	/* transient soap skipped */
}

void _ns1__SignatureRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__SignatureRequest::AppId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__SignatureRequest::AppId);
	soap_embedded(soap, &this->_ns1__SignatureRequest::ProcessId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__SignatureRequest::ProcessId);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SignatureRequest::TOTP);
	soap_embedded(soap, &this->_ns1__SignatureRequest::Hash, SOAP_TYPE_xsd__base64Binary);
	this->_ns1__SignatureRequest::Hash.soap_serialize(soap);
	soap_serialize_PointerTons1__TransactionType(soap, &this->_ns1__SignatureRequest::Transaction);
#endif
}

int _ns1__SignatureRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SignatureRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SignatureRequest(struct soap *soap, const char *tag, int id, const _ns1__SignatureRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SignatureRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:AppId", -1, &a->_ns1__SignatureRequest::AppId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:ProcessId", -1, &a->_ns1__SignatureRequest::ProcessId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TOTP", -1, &a->_ns1__SignatureRequest::TOTP, ""))
		return soap->error;
	if ((a->_ns1__SignatureRequest::Hash).soap_out(soap, "ns1:Hash", -1, ""))
		return soap->error;
	if (!a->_ns1__SignatureRequest::Transaction)
	{	if (soap_element_empty(soap, "ns1:Transaction"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__TransactionType(soap, "ns1:Transaction", -1, &a->_ns1__SignatureRequest::Transaction, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SignatureRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SignatureRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SignatureRequest * SOAP_FMAC4 soap_in__ns1__SignatureRequest(struct soap *soap, const char *tag, _ns1__SignatureRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SignatureRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SignatureRequest, sizeof(_ns1__SignatureRequest), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SignatureRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SignatureRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AppId1 = 1;
	size_t soap_flag_ProcessId1 = 1;
	size_t soap_flag_TOTP1 = 1;
	size_t soap_flag_Hash1 = 1;
	size_t soap_flag_Transaction1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AppId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:AppId", &a->_ns1__SignatureRequest::AppId, "xsd:string"))
				{	soap_flag_AppId1--;
					continue;
				}
			}
			if (soap_flag_ProcessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:ProcessId", &a->_ns1__SignatureRequest::ProcessId, "xsd:string"))
				{	soap_flag_ProcessId1--;
					continue;
				}
			}
			if (soap_flag_TOTP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TOTP", &a->_ns1__SignatureRequest::TOTP, "xsd:string"))
				{	soap_flag_TOTP1--;
					continue;
				}
			}
			if (soap_flag_Hash1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->_ns1__SignatureRequest::Hash).soap_in(soap, "ns1:Hash", "xsd:base64Binary"))
				{	soap_flag_Hash1--;
					continue;
				}
			}
			if (soap_flag_Transaction1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__TransactionType(soap, "ns1:Transaction", &a->_ns1__SignatureRequest::Transaction, "ns1:TransactionType"))
				{	soap_flag_Transaction1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AppId1 > 0 || soap_flag_ProcessId1 > 0 || soap_flag_Hash1 > 0 || !a->_ns1__SignatureRequest::Transaction))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__SignatureRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SignatureRequest, SOAP_TYPE__ns1__SignatureRequest, sizeof(_ns1__SignatureRequest), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SignatureRequest * SOAP_FMAC2 SCAP_instantiate__ns1__SignatureRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate__ns1__SignatureRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SignatureRequest *p;
	size_t k = sizeof(_ns1__SignatureRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SignatureRequest);
		if (p)
			((_ns1__SignatureRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SignatureRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SignatureRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SignatureRequest location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SignatureRequest, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SignatureRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SignatureRequest(soap, tag ? tag : "ns1:SignatureRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SignatureRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SignatureRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SignatureRequest * SOAP_FMAC4 soap_get__ns1__SignatureRequest(struct soap *soap, _ns1__SignatureRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SignatureRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__AuthorizationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__AuthorizationResponse::Status = NULL;
	this->_ns1__AuthorizationResponse::ProcessId = NULL;
	this->_ns1__AuthorizationResponse::TransactionList = NULL;
	/* transient soap skipped */
}

void _ns1__AuthorizationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Status(soap, &this->_ns1__AuthorizationResponse::Status);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__AuthorizationResponse::ProcessId);
	soap_serialize_PointerTons1__TransactionTypeList(soap, &this->_ns1__AuthorizationResponse::TransactionList);
#endif
}

int _ns1__AuthorizationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AuthorizationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AuthorizationResponse(struct soap *soap, const char *tag, int id, const _ns1__AuthorizationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AuthorizationResponse), type))
		return soap->error;
	if (a->Status)
		soap_element_result(soap, "ns1:Status");
	if (!a->_ns1__AuthorizationResponse::Status)
	{	if (soap_element_empty(soap, "ns1:Status"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__Status(soap, "ns1:Status", -1, &a->_ns1__AuthorizationResponse::Status, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ProcessId", -1, &a->_ns1__AuthorizationResponse::ProcessId, ""))
		return soap->error;
	if (soap_out_PointerTons1__TransactionTypeList(soap, "ns1:TransactionList", -1, &a->_ns1__AuthorizationResponse::TransactionList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__AuthorizationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AuthorizationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AuthorizationResponse * SOAP_FMAC4 soap_in__ns1__AuthorizationResponse(struct soap *soap, const char *tag, _ns1__AuthorizationResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AuthorizationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AuthorizationResponse, sizeof(_ns1__AuthorizationResponse), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__AuthorizationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__AuthorizationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Status1 = 1;
	size_t soap_flag_ProcessId1 = 1;
	size_t soap_flag_TransactionList1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Status(soap, "ns1:Status", &a->_ns1__AuthorizationResponse::Status, "ns1:Status"))
				{	soap_flag_Status1--;
					continue;
				}
			}
			if (soap_flag_ProcessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ProcessId", &a->_ns1__AuthorizationResponse::ProcessId, "xsd:string"))
				{	soap_flag_ProcessId1--;
					continue;
				}
			}
			if (soap_flag_TransactionList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__TransactionTypeList(soap, "ns1:TransactionList", &a->_ns1__AuthorizationResponse::TransactionList, "ns1:TransactionTypeList"))
				{	soap_flag_TransactionList1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:Status");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__AuthorizationResponse::Status))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__AuthorizationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AuthorizationResponse, SOAP_TYPE__ns1__AuthorizationResponse, sizeof(_ns1__AuthorizationResponse), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__AuthorizationResponse * SOAP_FMAC2 SCAP_instantiate__ns1__AuthorizationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate__ns1__AuthorizationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__AuthorizationResponse *p;
	size_t k = sizeof(_ns1__AuthorizationResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__AuthorizationResponse);
		if (p)
			((_ns1__AuthorizationResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__AuthorizationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__AuthorizationResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__AuthorizationResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__AuthorizationResponse, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__AuthorizationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__AuthorizationResponse(soap, tag ? tag : "ns1:AuthorizationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AuthorizationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AuthorizationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AuthorizationResponse * SOAP_FMAC4 soap_get__ns1__AuthorizationResponse(struct soap *soap, _ns1__AuthorizationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AuthorizationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__AuthorizationRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__AuthorizationRequest::AppId);
	soap_default_std__string(soap, &this->_ns1__AuthorizationRequest::TOTP);
	this->_ns1__AuthorizationRequest::DocumentSignature.xsd__base64Binary::soap_default(soap);
	this->_ns1__AuthorizationRequest::DocumentHash.xsd__base64Binary::soap_default(soap);
	soap_default_std__string(soap, &this->_ns1__AuthorizationRequest::SignatureCertificate);
	this->_ns1__AuthorizationRequest::PersonalData = NULL;
	this->_ns1__AuthorizationRequest::AttributeList = NULL;
	/* transient soap skipped */
}

void _ns1__AuthorizationRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__AuthorizationRequest::AppId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__AuthorizationRequest::AppId);
	soap_embedded(soap, &this->_ns1__AuthorizationRequest::TOTP, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__AuthorizationRequest::TOTP);
	soap_embedded(soap, &this->_ns1__AuthorizationRequest::DocumentSignature, SOAP_TYPE_xsd__base64Binary);
	this->_ns1__AuthorizationRequest::DocumentSignature.soap_serialize(soap);
	soap_embedded(soap, &this->_ns1__AuthorizationRequest::DocumentHash, SOAP_TYPE_xsd__base64Binary);
	this->_ns1__AuthorizationRequest::DocumentHash.soap_serialize(soap);
	soap_embedded(soap, &this->_ns1__AuthorizationRequest::SignatureCertificate, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__AuthorizationRequest::SignatureCertificate);
	soap_serialize_PointerTons1__PersonalData(soap, &this->_ns1__AuthorizationRequest::PersonalData);
	soap_serialize_PointerTons1__AttributeListType(soap, &this->_ns1__AuthorizationRequest::AttributeList);
#endif
}

int _ns1__AuthorizationRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AuthorizationRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AuthorizationRequest(struct soap *soap, const char *tag, int id, const _ns1__AuthorizationRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AuthorizationRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:AppId", -1, &a->_ns1__AuthorizationRequest::AppId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:TOTP", -1, &a->_ns1__AuthorizationRequest::TOTP, ""))
		return soap->error;
	if ((a->_ns1__AuthorizationRequest::DocumentSignature).soap_out(soap, "ns1:DocumentSignature", -1, ""))
		return soap->error;
	if ((a->_ns1__AuthorizationRequest::DocumentHash).soap_out(soap, "ns1:DocumentHash", -1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:SignatureCertificate", -1, &a->_ns1__AuthorizationRequest::SignatureCertificate, ""))
		return soap->error;
	if (!a->_ns1__AuthorizationRequest::PersonalData)
	{	if (soap_element_empty(soap, "ns1:PersonalData"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__PersonalData(soap, "ns1:PersonalData", -1, &a->_ns1__AuthorizationRequest::PersonalData, ""))
		return soap->error;
	if (!a->_ns1__AuthorizationRequest::AttributeList)
	{	if (soap_element_empty(soap, "ns1:AttributeList"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__AttributeListType(soap, "ns1:AttributeList", -1, &a->_ns1__AuthorizationRequest::AttributeList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__AuthorizationRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AuthorizationRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AuthorizationRequest * SOAP_FMAC4 soap_in__ns1__AuthorizationRequest(struct soap *soap, const char *tag, _ns1__AuthorizationRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AuthorizationRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AuthorizationRequest, sizeof(_ns1__AuthorizationRequest), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__AuthorizationRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__AuthorizationRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AppId1 = 1;
	size_t soap_flag_TOTP1 = 1;
	size_t soap_flag_DocumentSignature1 = 1;
	size_t soap_flag_DocumentHash1 = 1;
	size_t soap_flag_SignatureCertificate1 = 1;
	size_t soap_flag_PersonalData1 = 1;
	size_t soap_flag_AttributeList1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AppId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:AppId", &a->_ns1__AuthorizationRequest::AppId, "xsd:string"))
				{	soap_flag_AppId1--;
					continue;
				}
			}
			if (soap_flag_TOTP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:TOTP", &a->_ns1__AuthorizationRequest::TOTP, "xsd:string"))
				{	soap_flag_TOTP1--;
					continue;
				}
			}
			if (soap_flag_DocumentSignature1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->_ns1__AuthorizationRequest::DocumentSignature).soap_in(soap, "ns1:DocumentSignature", "xsd:base64Binary"))
				{	soap_flag_DocumentSignature1--;
					continue;
				}
			}
			if (soap_flag_DocumentHash1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->_ns1__AuthorizationRequest::DocumentHash).soap_in(soap, "ns1:DocumentHash", "xsd:base64Binary"))
				{	soap_flag_DocumentHash1--;
					continue;
				}
			}
			if (soap_flag_SignatureCertificate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:SignatureCertificate", &a->_ns1__AuthorizationRequest::SignatureCertificate, "xsd:string"))
				{	soap_flag_SignatureCertificate1--;
					continue;
				}
			}
			if (soap_flag_PersonalData1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PersonalData(soap, "ns1:PersonalData", &a->_ns1__AuthorizationRequest::PersonalData, "ns1:PersonalData"))
				{	soap_flag_PersonalData1--;
					continue;
				}
			}
			if (soap_flag_AttributeList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__AttributeListType(soap, "ns1:AttributeList", &a->_ns1__AuthorizationRequest::AttributeList, "ns1:AttributeListType"))
				{	soap_flag_AttributeList1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AppId1 > 0 || soap_flag_TOTP1 > 0 || soap_flag_DocumentSignature1 > 0 || soap_flag_DocumentHash1 > 0 || soap_flag_SignatureCertificate1 > 0 || !a->_ns1__AuthorizationRequest::PersonalData || !a->_ns1__AuthorizationRequest::AttributeList))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__AuthorizationRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AuthorizationRequest, SOAP_TYPE__ns1__AuthorizationRequest, sizeof(_ns1__AuthorizationRequest), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__AuthorizationRequest * SOAP_FMAC2 SCAP_instantiate__ns1__AuthorizationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate__ns1__AuthorizationRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__AuthorizationRequest *p;
	size_t k = sizeof(_ns1__AuthorizationRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__AuthorizationRequest);
		if (p)
			((_ns1__AuthorizationRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__AuthorizationRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__AuthorizationRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__AuthorizationRequest location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__AuthorizationRequest, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__AuthorizationRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__AuthorizationRequest(soap, tag ? tag : "ns1:AuthorizationRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AuthorizationRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AuthorizationRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AuthorizationRequest * SOAP_FMAC4 soap_get__ns1__AuthorizationRequest(struct soap *soap, _ns1__AuthorizationRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AuthorizationRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__TransactionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__TransactionType::TransactionId);
	this->ns1__TransactionType::AttributeSupplier = NULL;
	this->ns1__TransactionType::MainAttribute = NULL;
	soap_default_std__string(soap, &this->ns1__TransactionType::AttributeSupplierCertificateChain);
	/* transient soap skipped */
}

void ns1__TransactionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__TransactionType::TransactionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__TransactionType::TransactionId);
	soap_serialize_PointerTons1__AttributeSupplierType(soap, &this->ns1__TransactionType::AttributeSupplier);
	soap_serialize_PointerTons1__MainAttributeType(soap, &this->ns1__TransactionType::MainAttribute);
	soap_embedded(soap, &this->ns1__TransactionType::AttributeSupplierCertificateChain, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__TransactionType::AttributeSupplierCertificateChain);
#endif
}

int ns1__TransactionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TransactionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TransactionType(struct soap *soap, const char *tag, int id, const ns1__TransactionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TransactionType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:TransactionId", -1, &a->ns1__TransactionType::TransactionId, ""))
		return soap->error;
	if (!a->ns1__TransactionType::AttributeSupplier)
	{	if (soap_element_empty(soap, "ns1:AttributeSupplier"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__AttributeSupplierType(soap, "ns1:AttributeSupplier", -1, &a->ns1__TransactionType::AttributeSupplier, ""))
		return soap->error;
	if (!a->ns1__TransactionType::MainAttribute)
	{	if (soap_element_empty(soap, "ns1:MainAttribute"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__MainAttributeType(soap, "ns1:MainAttribute", -1, &a->ns1__TransactionType::MainAttribute, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:AttributeSupplierCertificateChain", -1, &a->ns1__TransactionType::AttributeSupplierCertificateChain, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__TransactionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__TransactionType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TransactionType * SOAP_FMAC4 soap_in_ns1__TransactionType(struct soap *soap, const char *tag, ns1__TransactionType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TransactionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TransactionType, sizeof(ns1__TransactionType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__TransactionType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__TransactionType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TransactionId1 = 1;
	size_t soap_flag_AttributeSupplier1 = 1;
	size_t soap_flag_MainAttribute1 = 1;
	size_t soap_flag_AttributeSupplierCertificateChain1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TransactionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:TransactionId", &a->ns1__TransactionType::TransactionId, "xsd:string"))
				{	soap_flag_TransactionId1--;
					continue;
				}
			}
			if (soap_flag_AttributeSupplier1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__AttributeSupplierType(soap, "ns1:AttributeSupplier", &a->ns1__TransactionType::AttributeSupplier, "ns1:AttributeSupplierType"))
				{	soap_flag_AttributeSupplier1--;
					continue;
				}
			}
			if (soap_flag_MainAttribute1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__MainAttributeType(soap, "ns1:MainAttribute", &a->ns1__TransactionType::MainAttribute, "ns1:MainAttributeType"))
				{	soap_flag_MainAttribute1--;
					continue;
				}
			}
			if (soap_flag_AttributeSupplierCertificateChain1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:AttributeSupplierCertificateChain", &a->ns1__TransactionType::AttributeSupplierCertificateChain, "xsd:string"))
				{	soap_flag_AttributeSupplierCertificateChain1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TransactionId1 > 0 || !a->ns1__TransactionType::AttributeSupplier || !a->ns1__TransactionType::MainAttribute || soap_flag_AttributeSupplierCertificateChain1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__TransactionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TransactionType, SOAP_TYPE_ns1__TransactionType, sizeof(ns1__TransactionType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__TransactionType * SOAP_FMAC2 SCAP_instantiate_ns1__TransactionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns1__TransactionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__TransactionType *p;
	size_t k = sizeof(ns1__TransactionType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__TransactionType);
		if (p)
			((ns1__TransactionType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__TransactionType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__TransactionType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__TransactionType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__TransactionType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__TransactionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__TransactionType(soap, tag ? tag : "ns1:TransactionType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TransactionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TransactionType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TransactionType * SOAP_FMAC4 soap_get_ns1__TransactionType(struct soap *soap, ns1__TransactionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TransactionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__TransactionTypeList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__TransactionType(soap, &this->ns1__TransactionTypeList::Transaction);
	/* transient soap skipped */
}

void ns1__TransactionTypeList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__TransactionType(soap, &this->ns1__TransactionTypeList::Transaction);
#endif
}

int ns1__TransactionTypeList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TransactionTypeList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TransactionTypeList(struct soap *soap, const char *tag, int id, const ns1__TransactionTypeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TransactionTypeList), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__TransactionType(soap, "ns1:Transaction", -1, &a->ns1__TransactionTypeList::Transaction, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__TransactionTypeList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__TransactionTypeList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TransactionTypeList * SOAP_FMAC4 soap_in_ns1__TransactionTypeList(struct soap *soap, const char *tag, ns1__TransactionTypeList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TransactionTypeList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TransactionTypeList, sizeof(ns1__TransactionTypeList), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__TransactionTypeList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__TransactionTypeList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__TransactionType(soap, "ns1:Transaction", &a->ns1__TransactionTypeList::Transaction, "ns1:TransactionType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns1__TransactionTypeList::Transaction.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__TransactionTypeList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TransactionTypeList, SOAP_TYPE_ns1__TransactionTypeList, sizeof(ns1__TransactionTypeList), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__TransactionTypeList * SOAP_FMAC2 SCAP_instantiate_ns1__TransactionTypeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns1__TransactionTypeList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__TransactionTypeList *p;
	size_t k = sizeof(ns1__TransactionTypeList);
	if (n < 0)
	{	p = SOAP_NEW(ns1__TransactionTypeList);
		if (p)
			((ns1__TransactionTypeList*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__TransactionTypeList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__TransactionTypeList*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__TransactionTypeList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__TransactionTypeList, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__TransactionTypeList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__TransactionTypeList(soap, tag ? tag : "ns1:TransactionTypeList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TransactionTypeList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TransactionTypeList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TransactionTypeList * SOAP_FMAC4 soap_get_ns1__TransactionTypeList(struct soap *soap, ns1__TransactionTypeList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TransactionTypeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Status::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__Status::Code);
	soap_default_std__string(soap, &this->ns1__Status::Message);
	this->ns1__Status::Field = NULL;
	this->ns1__Status::FieldValue = NULL;
	/* transient soap skipped */
}

void ns1__Status::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__Status::Code, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Status::Code);
	soap_embedded(soap, &this->ns1__Status::Message, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Status::Message);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Status::Field);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Status::FieldValue);
#endif
}

int ns1__Status::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Status(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Status(struct soap *soap, const char *tag, int id, const ns1__Status *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Status), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Code", -1, &a->ns1__Status::Code, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Message", -1, &a->ns1__Status::Message, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Field", -1, &a->ns1__Status::Field, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:FieldValue", -1, &a->ns1__Status::FieldValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Status::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Status(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Status * SOAP_FMAC4 soap_in_ns1__Status(struct soap *soap, const char *tag, ns1__Status *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Status *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Status, sizeof(ns1__Status), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Status)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Status *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Code1 = 1;
	size_t soap_flag_Message1 = 1;
	size_t soap_flag_Field1 = 1;
	size_t soap_flag_FieldValue1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:Code", &a->ns1__Status::Code, "xsd:string"))
				{	soap_flag_Code1--;
					continue;
				}
			}
			if (soap_flag_Message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:Message", &a->ns1__Status::Message, "xsd:string"))
				{	soap_flag_Message1--;
					continue;
				}
			}
			if (soap_flag_Field1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Field", &a->ns1__Status::Field, "xsd:string"))
				{	soap_flag_Field1--;
					continue;
				}
			}
			if (soap_flag_FieldValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:FieldValue", &a->ns1__Status::FieldValue, "xsd:string"))
				{	soap_flag_FieldValue1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Code1 > 0 || soap_flag_Message1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Status, SOAP_TYPE_ns1__Status, sizeof(ns1__Status), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Status * SOAP_FMAC2 SCAP_instantiate_ns1__Status(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns1__Status(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Status *p;
	size_t k = sizeof(ns1__Status);
	if (n < 0)
	{	p = SOAP_NEW(ns1__Status);
		if (p)
			((ns1__Status*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__Status, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__Status*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Status location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__Status, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__Status::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Status(soap, tag ? tag : "ns1:Status", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Status::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Status(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Status * SOAP_FMAC4 soap_get_ns1__Status(struct soap *soap, ns1__Status *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubAttributeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__SubAttributeType::AttributeID);
	this->ns1__SubAttributeType::Description = NULL;
	this->ns1__SubAttributeType::LegalActList = NULL;
	this->ns1__SubAttributeType::Value = NULL;
	/* transient soap skipped */
}

void ns1__SubAttributeType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__SubAttributeType::AttributeID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SubAttributeType::AttributeID);
	soap_serialize_PointerTostd__string(soap, &this->ns1__SubAttributeType::Description);
	soap_serialize_PointerTons1__LegalActListType(soap, &this->ns1__SubAttributeType::LegalActList);
	soap_serialize_PointerTostd__string(soap, &this->ns1__SubAttributeType::Value);
#endif
}

int ns1__SubAttributeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubAttributeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubAttributeType(struct soap *soap, const char *tag, int id, const ns1__SubAttributeType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubAttributeType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:AttributeID", -1, &a->ns1__SubAttributeType::AttributeID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Description", -1, &a->ns1__SubAttributeType::Description, ""))
		return soap->error;
	if (soap_out_PointerTons1__LegalActListType(soap, "ns1:LegalActList", -1, &a->ns1__SubAttributeType::LegalActList, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Value", -1, &a->ns1__SubAttributeType::Value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubAttributeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SubAttributeType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubAttributeType * SOAP_FMAC4 soap_in_ns1__SubAttributeType(struct soap *soap, const char *tag, ns1__SubAttributeType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubAttributeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubAttributeType, sizeof(ns1__SubAttributeType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubAttributeType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubAttributeType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AttributeID1 = 1;
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_LegalActList1 = 1;
	size_t soap_flag_Value1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AttributeID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:AttributeID", &a->ns1__SubAttributeType::AttributeID, "xsd:string"))
				{	soap_flag_AttributeID1--;
					continue;
				}
			}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Description", &a->ns1__SubAttributeType::Description, "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			}
			if (soap_flag_LegalActList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__LegalActListType(soap, "ns1:LegalActList", &a->ns1__SubAttributeType::LegalActList, "ns1:LegalActListType"))
				{	soap_flag_LegalActList1--;
					continue;
				}
			}
			if (soap_flag_Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Value", &a->ns1__SubAttributeType::Value, "xsd:string"))
				{	soap_flag_Value1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AttributeID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SubAttributeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubAttributeType, SOAP_TYPE_ns1__SubAttributeType, sizeof(ns1__SubAttributeType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubAttributeType * SOAP_FMAC2 SCAP_instantiate_ns1__SubAttributeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns1__SubAttributeType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubAttributeType *p;
	size_t k = sizeof(ns1__SubAttributeType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__SubAttributeType);
		if (p)
			((ns1__SubAttributeType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__SubAttributeType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__SubAttributeType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubAttributeType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__SubAttributeType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__SubAttributeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubAttributeType(soap, tag ? tag : "ns1:SubAttributeType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubAttributeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubAttributeType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubAttributeType * SOAP_FMAC4 soap_get_ns1__SubAttributeType(struct soap *soap, ns1__SubAttributeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubAttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubAttributeListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__SubAttributeType(soap, &this->ns1__SubAttributeListType::SubAttribute);
	/* transient soap skipped */
}

void ns1__SubAttributeListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__SubAttributeType(soap, &this->ns1__SubAttributeListType::SubAttribute);
#endif
}

int ns1__SubAttributeListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubAttributeListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubAttributeListType(struct soap *soap, const char *tag, int id, const ns1__SubAttributeListType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubAttributeListType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__SubAttributeType(soap, "ns1:SubAttribute", -1, &a->ns1__SubAttributeListType::SubAttribute, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubAttributeListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SubAttributeListType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubAttributeListType * SOAP_FMAC4 soap_in_ns1__SubAttributeListType(struct soap *soap, const char *tag, ns1__SubAttributeListType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubAttributeListType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubAttributeListType, sizeof(ns1__SubAttributeListType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubAttributeListType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubAttributeListType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__SubAttributeType(soap, "ns1:SubAttribute", &a->ns1__SubAttributeListType::SubAttribute, "ns1:SubAttributeType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns1__SubAttributeListType::SubAttribute.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__SubAttributeListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubAttributeListType, SOAP_TYPE_ns1__SubAttributeListType, sizeof(ns1__SubAttributeListType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubAttributeListType * SOAP_FMAC2 SCAP_instantiate_ns1__SubAttributeListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns1__SubAttributeListType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubAttributeListType *p;
	size_t k = sizeof(ns1__SubAttributeListType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__SubAttributeListType);
		if (p)
			((ns1__SubAttributeListType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__SubAttributeListType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__SubAttributeListType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubAttributeListType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__SubAttributeListType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__SubAttributeListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubAttributeListType(soap, tag ? tag : "ns1:SubAttributeListType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubAttributeListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubAttributeListType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubAttributeListType * SOAP_FMAC4 soap_get_ns1__SubAttributeListType(struct soap *soap, ns1__SubAttributeListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubAttributeListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__LegalActListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__LegalActListType::LegalAct);
	/* transient soap skipped */
}

void ns1__LegalActListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__LegalActListType::LegalAct);
#endif
}

int ns1__LegalActListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__LegalActListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LegalActListType(struct soap *soap, const char *tag, int id, const ns1__LegalActListType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LegalActListType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "ns1:LegalAct", -1, &a->ns1__LegalActListType::LegalAct, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__LegalActListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__LegalActListType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__LegalActListType * SOAP_FMAC4 soap_in_ns1__LegalActListType(struct soap *soap, const char *tag, ns1__LegalActListType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__LegalActListType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LegalActListType, sizeof(ns1__LegalActListType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__LegalActListType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__LegalActListType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "ns1:LegalAct", &a->ns1__LegalActListType::LegalAct, "xsd:string"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns1__LegalActListType::LegalAct.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__LegalActListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LegalActListType, SOAP_TYPE_ns1__LegalActListType, sizeof(ns1__LegalActListType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__LegalActListType * SOAP_FMAC2 SCAP_instantiate_ns1__LegalActListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns1__LegalActListType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__LegalActListType *p;
	size_t k = sizeof(ns1__LegalActListType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__LegalActListType);
		if (p)
			((ns1__LegalActListType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__LegalActListType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__LegalActListType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__LegalActListType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__LegalActListType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__LegalActListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__LegalActListType(soap, tag ? tag : "ns1:LegalActListType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__LegalActListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__LegalActListType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__LegalActListType * SOAP_FMAC4 soap_get_ns1__LegalActListType(struct soap *soap, ns1__LegalActListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LegalActListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__MainAttributeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__MainAttributeType::AttributeID);
	this->ns1__MainAttributeType::Description = NULL;
	this->ns1__MainAttributeType::LegalActList = NULL;
	this->ns1__MainAttributeType::SubAttributeList = NULL;
	/* transient soap skipped */
}

void ns1__MainAttributeType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__MainAttributeType::AttributeID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__MainAttributeType::AttributeID);
	soap_serialize_PointerTostd__string(soap, &this->ns1__MainAttributeType::Description);
	soap_serialize_PointerTons1__LegalActListType(soap, &this->ns1__MainAttributeType::LegalActList);
	soap_serialize_PointerTons1__SubAttributeListType(soap, &this->ns1__MainAttributeType::SubAttributeList);
#endif
}

int ns1__MainAttributeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MainAttributeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MainAttributeType(struct soap *soap, const char *tag, int id, const ns1__MainAttributeType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MainAttributeType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:AttributeID", -1, &a->ns1__MainAttributeType::AttributeID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Description", -1, &a->ns1__MainAttributeType::Description, ""))
		return soap->error;
	if (soap_out_PointerTons1__LegalActListType(soap, "ns1:LegalActList", -1, &a->ns1__MainAttributeType::LegalActList, ""))
		return soap->error;
	if (soap_out_PointerTons1__SubAttributeListType(soap, "ns1:SubAttributeList", -1, &a->ns1__MainAttributeType::SubAttributeList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__MainAttributeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MainAttributeType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MainAttributeType * SOAP_FMAC4 soap_in_ns1__MainAttributeType(struct soap *soap, const char *tag, ns1__MainAttributeType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MainAttributeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MainAttributeType, sizeof(ns1__MainAttributeType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__MainAttributeType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__MainAttributeType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AttributeID1 = 1;
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_LegalActList1 = 1;
	size_t soap_flag_SubAttributeList1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AttributeID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:AttributeID", &a->ns1__MainAttributeType::AttributeID, "xsd:string"))
				{	soap_flag_AttributeID1--;
					continue;
				}
			}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Description", &a->ns1__MainAttributeType::Description, "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			}
			if (soap_flag_LegalActList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__LegalActListType(soap, "ns1:LegalActList", &a->ns1__MainAttributeType::LegalActList, "ns1:LegalActListType"))
				{	soap_flag_LegalActList1--;
					continue;
				}
			}
			if (soap_flag_SubAttributeList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubAttributeListType(soap, "ns1:SubAttributeList", &a->ns1__MainAttributeType::SubAttributeList, "ns1:SubAttributeListType"))
				{	soap_flag_SubAttributeList1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AttributeID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__MainAttributeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MainAttributeType, SOAP_TYPE_ns1__MainAttributeType, sizeof(ns1__MainAttributeType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__MainAttributeType * SOAP_FMAC2 SCAP_instantiate_ns1__MainAttributeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns1__MainAttributeType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__MainAttributeType *p;
	size_t k = sizeof(ns1__MainAttributeType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__MainAttributeType);
		if (p)
			((ns1__MainAttributeType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__MainAttributeType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__MainAttributeType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__MainAttributeType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__MainAttributeType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__MainAttributeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__MainAttributeType(soap, tag ? tag : "ns1:MainAttributeType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__MainAttributeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MainAttributeType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MainAttributeType * SOAP_FMAC4 soap_get_ns1__MainAttributeType(struct soap *soap, ns1__MainAttributeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MainAttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__AttributeSupplierType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__AttributeSupplierType::Id);
	soap_default_std__string(soap, &this->ns1__AttributeSupplierType::Name);
	this->ns1__AttributeSupplierType::Type = NULL;
	/* transient soap skipped */
}

void ns1__AttributeSupplierType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__AttributeSupplierType::Id, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__AttributeSupplierType::Id);
	soap_embedded(soap, &this->ns1__AttributeSupplierType::Name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__AttributeSupplierType::Name);
	soap_serialize_PointerTostd__string(soap, &this->ns1__AttributeSupplierType::Type);
#endif
}

int ns1__AttributeSupplierType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AttributeSupplierType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AttributeSupplierType(struct soap *soap, const char *tag, int id, const ns1__AttributeSupplierType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AttributeSupplierType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Id", -1, &a->ns1__AttributeSupplierType::Id, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Name", -1, &a->ns1__AttributeSupplierType::Name, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Type", -1, &a->ns1__AttributeSupplierType::Type, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__AttributeSupplierType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AttributeSupplierType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AttributeSupplierType * SOAP_FMAC4 soap_in_ns1__AttributeSupplierType(struct soap *soap, const char *tag, ns1__AttributeSupplierType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AttributeSupplierType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AttributeSupplierType, sizeof(ns1__AttributeSupplierType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__AttributeSupplierType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__AttributeSupplierType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Type1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:Id", &a->ns1__AttributeSupplierType::Id, "xsd:string"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:Name", &a->ns1__AttributeSupplierType::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_Type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Type", &a->ns1__AttributeSupplierType::Type, "xsd:string"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_Name1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__AttributeSupplierType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AttributeSupplierType, SOAP_TYPE_ns1__AttributeSupplierType, sizeof(ns1__AttributeSupplierType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__AttributeSupplierType * SOAP_FMAC2 SCAP_instantiate_ns1__AttributeSupplierType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns1__AttributeSupplierType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__AttributeSupplierType *p;
	size_t k = sizeof(ns1__AttributeSupplierType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__AttributeSupplierType);
		if (p)
			((ns1__AttributeSupplierType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__AttributeSupplierType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__AttributeSupplierType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__AttributeSupplierType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__AttributeSupplierType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__AttributeSupplierType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__AttributeSupplierType(soap, tag ? tag : "ns1:AttributeSupplierType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__AttributeSupplierType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AttributeSupplierType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AttributeSupplierType * SOAP_FMAC4 soap_get_ns1__AttributeSupplierType(struct soap *soap, ns1__AttributeSupplierType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AttributeSupplierType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__AttributeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__AttributeType::AttributeSupplier = NULL;
	this->ns1__AttributeType::MainAttribute = NULL;
	/* transient soap skipped */
}

void ns1__AttributeType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__AttributeSupplierType(soap, &this->ns1__AttributeType::AttributeSupplier);
	soap_serialize_PointerTons1__MainAttributeType(soap, &this->ns1__AttributeType::MainAttribute);
#endif
}

int ns1__AttributeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AttributeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AttributeType(struct soap *soap, const char *tag, int id, const ns1__AttributeType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AttributeType), type))
		return soap->error;
	if (!a->ns1__AttributeType::AttributeSupplier)
	{	if (soap_element_empty(soap, "ns1:AttributeSupplier"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__AttributeSupplierType(soap, "ns1:AttributeSupplier", -1, &a->ns1__AttributeType::AttributeSupplier, ""))
		return soap->error;
	if (soap_out_PointerTons1__MainAttributeType(soap, "ns1:MainAttribute", -1, &a->ns1__AttributeType::MainAttribute, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__AttributeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AttributeType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AttributeType * SOAP_FMAC4 soap_in_ns1__AttributeType(struct soap *soap, const char *tag, ns1__AttributeType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AttributeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AttributeType, sizeof(ns1__AttributeType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__AttributeType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__AttributeType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AttributeSupplier1 = 1;
	size_t soap_flag_MainAttribute1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AttributeSupplier1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__AttributeSupplierType(soap, "ns1:AttributeSupplier", &a->ns1__AttributeType::AttributeSupplier, "ns1:AttributeSupplierType"))
				{	soap_flag_AttributeSupplier1--;
					continue;
				}
			}
			if (soap_flag_MainAttribute1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__MainAttributeType(soap, "ns1:MainAttribute", &a->ns1__AttributeType::MainAttribute, "ns1:MainAttributeType"))
				{	soap_flag_MainAttribute1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__AttributeType::AttributeSupplier))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__AttributeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AttributeType, SOAP_TYPE_ns1__AttributeType, sizeof(ns1__AttributeType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__AttributeType * SOAP_FMAC2 SCAP_instantiate_ns1__AttributeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns1__AttributeType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__AttributeType *p;
	size_t k = sizeof(ns1__AttributeType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__AttributeType);
		if (p)
			((ns1__AttributeType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__AttributeType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__AttributeType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__AttributeType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__AttributeType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__AttributeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__AttributeType(soap, tag ? tag : "ns1:AttributeType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__AttributeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AttributeType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AttributeType * SOAP_FMAC4 soap_get_ns1__AttributeType(struct soap *soap, ns1__AttributeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__AttributeListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__AttributeType(soap, &this->ns1__AttributeListType::Attribute);
	/* transient soap skipped */
}

void ns1__AttributeListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__AttributeType(soap, &this->ns1__AttributeListType::Attribute);
#endif
}

int ns1__AttributeListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AttributeListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AttributeListType(struct soap *soap, const char *tag, int id, const ns1__AttributeListType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AttributeListType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__AttributeType(soap, "ns1:Attribute", -1, &a->ns1__AttributeListType::Attribute, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__AttributeListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AttributeListType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AttributeListType * SOAP_FMAC4 soap_in_ns1__AttributeListType(struct soap *soap, const char *tag, ns1__AttributeListType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AttributeListType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AttributeListType, sizeof(ns1__AttributeListType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__AttributeListType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__AttributeListType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__AttributeType(soap, "ns1:Attribute", &a->ns1__AttributeListType::Attribute, "ns1:AttributeType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns1__AttributeListType::Attribute.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__AttributeListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AttributeListType, SOAP_TYPE_ns1__AttributeListType, sizeof(ns1__AttributeListType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__AttributeListType * SOAP_FMAC2 SCAP_instantiate_ns1__AttributeListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns1__AttributeListType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__AttributeListType *p;
	size_t k = sizeof(ns1__AttributeListType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__AttributeListType);
		if (p)
			((ns1__AttributeListType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__AttributeListType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__AttributeListType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__AttributeListType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__AttributeListType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__AttributeListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__AttributeListType(soap, tag ? tag : "ns1:AttributeListType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__AttributeListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AttributeListType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AttributeListType * SOAP_FMAC4 soap_get_ns1__AttributeListType(struct soap *soap, ns1__AttributeListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AttributeListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__PersonalData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__PersonalData::Name);
	soap_default_std__string(soap, &this->ns1__PersonalData::NIC);
	/* transient soap skipped */
}

void ns1__PersonalData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__PersonalData::Name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__PersonalData::Name);
	soap_embedded(soap, &this->ns1__PersonalData::NIC, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__PersonalData::NIC);
#endif
}

int ns1__PersonalData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PersonalData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PersonalData(struct soap *soap, const char *tag, int id, const ns1__PersonalData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PersonalData), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Name", -1, &a->ns1__PersonalData::Name, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:NIC", -1, &a->ns1__PersonalData::NIC, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__PersonalData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PersonalData(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PersonalData * SOAP_FMAC4 soap_in_ns1__PersonalData(struct soap *soap, const char *tag, ns1__PersonalData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PersonalData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PersonalData, sizeof(ns1__PersonalData), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__PersonalData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__PersonalData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_NIC1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:Name", &a->ns1__PersonalData::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_NIC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:NIC", &a->ns1__PersonalData::NIC, "xsd:string"))
				{	soap_flag_NIC1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0 || soap_flag_NIC1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__PersonalData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PersonalData, SOAP_TYPE_ns1__PersonalData, sizeof(ns1__PersonalData), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__PersonalData * SOAP_FMAC2 SCAP_instantiate_ns1__PersonalData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns1__PersonalData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__PersonalData *p;
	size_t k = sizeof(ns1__PersonalData);
	if (n < 0)
	{	p = SOAP_NEW(ns1__PersonalData);
		if (p)
			((ns1__PersonalData*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__PersonalData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__PersonalData*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__PersonalData location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__PersonalData, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__PersonalData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__PersonalData(soap, tag ? tag : "ns1:PersonalData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PersonalData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PersonalData(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PersonalData * SOAP_FMAC4 soap_get_ns1__PersonalData(struct soap *soap, ns1__PersonalData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PersonalData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns9__AttributeSupplierResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__AttributeSupplierType(soap, &this->ns9__AttributeSupplierResponseType::AttributeSupplier);
	this->ns9__AttributeSupplierResponseType::ErrorMessage = NULL;
	/* transient soap skipped */
}

void ns9__AttributeSupplierResponseType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__AttributeSupplierType(soap, &this->ns9__AttributeSupplierResponseType::AttributeSupplier);
	soap_serialize_PointerTostd__string(soap, &this->ns9__AttributeSupplierResponseType::ErrorMessage);
#endif
}

int ns9__AttributeSupplierResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns9__AttributeSupplierResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns9__AttributeSupplierResponseType(struct soap *soap, const char *tag, int id, const ns9__AttributeSupplierResponseType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns9__AttributeSupplierResponseType), type))
		return soap->error;
	soap_element_result(soap, "ns9:AttributeSupplier");
	if (soap_out_std__vectorTemplateOfPointerTons3__AttributeSupplierType(soap, "ns9:AttributeSupplier", -1, &a->ns9__AttributeSupplierResponseType::AttributeSupplier, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns9:ErrorMessage", -1, &a->ns9__AttributeSupplierResponseType::ErrorMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns9__AttributeSupplierResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns9__AttributeSupplierResponseType(soap, tag, this, type);
}

SOAP_FMAC3 ns9__AttributeSupplierResponseType * SOAP_FMAC4 soap_in_ns9__AttributeSupplierResponseType(struct soap *soap, const char *tag, ns9__AttributeSupplierResponseType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns9__AttributeSupplierResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns9__AttributeSupplierResponseType, sizeof(ns9__AttributeSupplierResponseType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns9__AttributeSupplierResponseType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns9__AttributeSupplierResponseType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ErrorMessage1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__AttributeSupplierType(soap, "ns9:AttributeSupplier", &a->ns9__AttributeSupplierResponseType::AttributeSupplier, "ns3:AttributeSupplierType"))
					continue;
			}
			if (soap_flag_ErrorMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns9:ErrorMessage", &a->ns9__AttributeSupplierResponseType::ErrorMessage, "xsd:string"))
				{	soap_flag_ErrorMessage1--;
					continue;
				}
			}
			soap_check_result(soap, "ns9:AttributeSupplier");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns9__AttributeSupplierResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns9__AttributeSupplierResponseType, SOAP_TYPE_ns9__AttributeSupplierResponseType, sizeof(ns9__AttributeSupplierResponseType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns9__AttributeSupplierResponseType * SOAP_FMAC2 SCAP_instantiate_ns9__AttributeSupplierResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns9__AttributeSupplierResponseType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns9__AttributeSupplierResponseType *p;
	size_t k = sizeof(ns9__AttributeSupplierResponseType);
	if (n < 0)
	{	p = SOAP_NEW(ns9__AttributeSupplierResponseType);
		if (p)
			((ns9__AttributeSupplierResponseType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns9__AttributeSupplierResponseType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns9__AttributeSupplierResponseType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns9__AttributeSupplierResponseType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns9__AttributeSupplierResponseType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns9__AttributeSupplierResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns9__AttributeSupplierResponseType(soap, tag ? tag : "ns9:AttributeSupplierResponseType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns9__AttributeSupplierResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns9__AttributeSupplierResponseType(soap, this, tag, type);
}

SOAP_FMAC3 ns9__AttributeSupplierResponseType * SOAP_FMAC4 soap_get_ns9__AttributeSupplierResponseType(struct soap *soap, ns9__AttributeSupplierResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns9__AttributeSupplierResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__SVGListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfns7__SVGType(soap, &this->ns7__SVGListType::ns7__SVG);
	/* transient soap skipped */
}

void ns7__SVGListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfns7__SVGType(soap, &this->ns7__SVGListType::ns7__SVG);
#endif
}

int ns7__SVGListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__SVGListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SVGListType(struct soap *soap, const char *tag, int id, const ns7__SVGListType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SVGListType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns7__SVGType(soap, "ns7:SVG", -1, &a->ns7__SVGListType::ns7__SVG, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__SVGListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__SVGListType(soap, tag, this, type);
}

SOAP_FMAC3 ns7__SVGListType * SOAP_FMAC4 soap_in_ns7__SVGListType(struct soap *soap, const char *tag, ns7__SVGListType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__SVGListType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SVGListType, sizeof(ns7__SVGListType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__SVGListType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__SVGListType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns7__SVGType(soap, "ns7:SVG", &a->ns7__SVGListType::ns7__SVG, "ns7:SVGType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns7__SVGListType::ns7__SVG.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns7__SVGListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SVGListType, SOAP_TYPE_ns7__SVGListType, sizeof(ns7__SVGListType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__SVGListType * SOAP_FMAC2 SCAP_instantiate_ns7__SVGListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns7__SVGListType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__SVGListType *p;
	size_t k = sizeof(ns7__SVGListType);
	if (n < 0)
	{	p = SOAP_NEW(ns7__SVGListType);
		if (p)
			((ns7__SVGListType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__SVGListType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__SVGListType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__SVGListType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__SVGListType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__SVGListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__SVGListType(soap, tag ? tag : "ns7:SVGListType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__SVGListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__SVGListType(soap, this, tag, type);
}

SOAP_FMAC3 ns7__SVGListType * SOAP_FMAC4 soap_get_ns7__SVGListType(struct soap *soap, ns7__SVGListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SVGListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__ArchiveTimeStampType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__ArchiveTimeStampType::ns5__CanonicalizationMethod = NULL;
	soap_default_ns6__EncapsulatedTimeStampType(soap, &this->ns6__ArchiveTimeStampType::ns6__EncapsulatedTimeStamp);
	/* transient soap skipped */
}

void ns6__ArchiveTimeStampType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__CanonicalizationMethodType(soap, &this->ns6__ArchiveTimeStampType::ns5__CanonicalizationMethod);
	soap_serialize_ns6__EncapsulatedTimeStampType(soap, &this->ns6__ArchiveTimeStampType::ns6__EncapsulatedTimeStamp);
#endif
}

int ns6__ArchiveTimeStampType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ArchiveTimeStampType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ArchiveTimeStampType(struct soap *soap, const char *tag, int id, const ns6__ArchiveTimeStampType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ArchiveTimeStampType), type))
		return soap->error;
	if (!a->ns6__ArchiveTimeStampType::ns5__CanonicalizationMethod)
	{	if (soap_element_empty(soap, "ns5:CanonicalizationMethod"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__CanonicalizationMethodType(soap, "ns5:CanonicalizationMethod", -1, &a->ns6__ArchiveTimeStampType::ns5__CanonicalizationMethod, ""))
		return soap->error;
	if (soap_out_ns6__EncapsulatedTimeStampType(soap, "ns6:EncapsulatedTimeStamp", -1, &a->ns6__ArchiveTimeStampType::ns6__EncapsulatedTimeStamp, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__ArchiveTimeStampType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__ArchiveTimeStampType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ArchiveTimeStampType * SOAP_FMAC4 soap_in_ns6__ArchiveTimeStampType(struct soap *soap, const char *tag, ns6__ArchiveTimeStampType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ArchiveTimeStampType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ArchiveTimeStampType, sizeof(ns6__ArchiveTimeStampType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__ArchiveTimeStampType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__ArchiveTimeStampType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ns5__CanonicalizationMethod1 = 1;
	size_t soap_flag_ns6__EncapsulatedTimeStamp1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__CanonicalizationMethod1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__CanonicalizationMethodType(soap, "ns5:CanonicalizationMethod", &a->ns6__ArchiveTimeStampType::ns5__CanonicalizationMethod, "ns5:CanonicalizationMethodType"))
				{	soap_flag_ns5__CanonicalizationMethod1--;
					continue;
				}
			}
			if (soap_flag_ns6__EncapsulatedTimeStamp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns6__EncapsulatedTimeStampType(soap, "ns6:EncapsulatedTimeStamp", &a->ns6__ArchiveTimeStampType::ns6__EncapsulatedTimeStamp, "ns6:EncapsulatedTimeStampType"))
				{	soap_flag_ns6__EncapsulatedTimeStamp1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns6__ArchiveTimeStampType::ns5__CanonicalizationMethod || soap_flag_ns6__EncapsulatedTimeStamp1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__ArchiveTimeStampType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ArchiveTimeStampType, SOAP_TYPE_ns6__ArchiveTimeStampType, sizeof(ns6__ArchiveTimeStampType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__ArchiveTimeStampType * SOAP_FMAC2 SCAP_instantiate_ns6__ArchiveTimeStampType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__ArchiveTimeStampType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__ArchiveTimeStampType *p;
	size_t k = sizeof(ns6__ArchiveTimeStampType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__ArchiveTimeStampType);
		if (p)
			((ns6__ArchiveTimeStampType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__ArchiveTimeStampType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__ArchiveTimeStampType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__ArchiveTimeStampType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__ArchiveTimeStampType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__ArchiveTimeStampType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__ArchiveTimeStampType(soap, tag ? tag : "ns6:ArchiveTimeStampType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__ArchiveTimeStampType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ArchiveTimeStampType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ArchiveTimeStampType * SOAP_FMAC4 soap_get_ns6__ArchiveTimeStampType(struct soap *soap, ns6__ArchiveTimeStampType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ArchiveTimeStampType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__EncapsulatedOCSPValueType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__EncapsulatedOCSPValueType::__item.xsd__base64Binary::soap_default(soap);
	soap_default_xsd__ID(soap, &this->ns6__EncapsulatedOCSPValueType::Id);
	/* transient soap skipped */
}

void ns6__EncapsulatedOCSPValueType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns6__EncapsulatedOCSPValueType::__item, SOAP_TYPE_xsd__base64Binary);
	this->ns6__EncapsulatedOCSPValueType::__item.soap_serialize(soap);
#endif
}

int ns6__EncapsulatedOCSPValueType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__EncapsulatedOCSPValueType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__EncapsulatedOCSPValueType(struct soap *soap, const char *tag, int id, const ns6__EncapsulatedOCSPValueType *a, const char *type)
{
	soap_set_attr(soap, "Id", soap_xsd__ID2s(soap, ((ns6__EncapsulatedOCSPValueType*)a)->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return (a->ns6__EncapsulatedOCSPValueType::__item).soap_out(soap, tag, id, "");
}

void *ns6__EncapsulatedOCSPValueType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__EncapsulatedOCSPValueType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__EncapsulatedOCSPValueType * SOAP_FMAC4 soap_in_ns6__EncapsulatedOCSPValueType(struct soap *soap, const char *tag, ns6__EncapsulatedOCSPValueType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns6__EncapsulatedOCSPValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__EncapsulatedOCSPValueType, sizeof(ns6__EncapsulatedOCSPValueType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__EncapsulatedOCSPValueType)
		return (ns6__EncapsulatedOCSPValueType *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__ID(soap, soap_attr_value(soap, "Id", 5, 1), &((ns6__EncapsulatedOCSPValueType*)a)->Id))
		return NULL;
	if (!(a->ns6__EncapsulatedOCSPValueType::__item).soap_in(soap, tag, "ns6:EncapsulatedOCSPValueType"))
		return NULL;
	return a;
}

SOAP_FMAC1 ns6__EncapsulatedOCSPValueType * SOAP_FMAC2 SCAP_instantiate_ns6__EncapsulatedOCSPValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__EncapsulatedOCSPValueType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__EncapsulatedOCSPValueType *p;
	size_t k = sizeof(ns6__EncapsulatedOCSPValueType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__EncapsulatedOCSPValueType);
		if (p)
			((ns6__EncapsulatedOCSPValueType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__EncapsulatedOCSPValueType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__EncapsulatedOCSPValueType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__EncapsulatedOCSPValueType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__EncapsulatedOCSPValueType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__EncapsulatedOCSPValueType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__EncapsulatedOCSPValueType(soap, tag ? tag : "ns6:EncapsulatedOCSPValueType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__EncapsulatedOCSPValueType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__EncapsulatedOCSPValueType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__EncapsulatedOCSPValueType * SOAP_FMAC4 soap_get_ns6__EncapsulatedOCSPValueType(struct soap *soap, ns6__EncapsulatedOCSPValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__EncapsulatedOCSPValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__OCSPValuesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons6__EncapsulatedOCSPValueType(soap, &this->ns6__OCSPValuesType::ns6__EncapsulatedOCSPValue);
	soap_default_xsd__ID(soap, &this->ns6__OCSPValuesType::Id);
	/* transient soap skipped */
}

void ns6__OCSPValuesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons6__EncapsulatedOCSPValueType(soap, &this->ns6__OCSPValuesType::ns6__EncapsulatedOCSPValue);
#endif
}

int ns6__OCSPValuesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__OCSPValuesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__OCSPValuesType(struct soap *soap, const char *tag, int id, const ns6__OCSPValuesType *a, const char *type)
{
	soap_set_attr(soap, "Id", soap_xsd__ID2s(soap, ((ns6__OCSPValuesType*)a)->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__OCSPValuesType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons6__EncapsulatedOCSPValueType(soap, "ns6:EncapsulatedOCSPValue", -1, &a->ns6__OCSPValuesType::ns6__EncapsulatedOCSPValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__OCSPValuesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__OCSPValuesType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__OCSPValuesType * SOAP_FMAC4 soap_in_ns6__OCSPValuesType(struct soap *soap, const char *tag, ns6__OCSPValuesType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__OCSPValuesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__OCSPValuesType, sizeof(ns6__OCSPValuesType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__OCSPValuesType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__OCSPValuesType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__ID(soap, soap_attr_value(soap, "Id", 5, 1), &((ns6__OCSPValuesType*)a)->Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons6__EncapsulatedOCSPValueType(soap, "ns6:EncapsulatedOCSPValue", &a->ns6__OCSPValuesType::ns6__EncapsulatedOCSPValue, "ns6:EncapsulatedOCSPValueType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns6__OCSPValuesType::ns6__EncapsulatedOCSPValue.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__OCSPValuesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__OCSPValuesType, SOAP_TYPE_ns6__OCSPValuesType, sizeof(ns6__OCSPValuesType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__OCSPValuesType * SOAP_FMAC2 SCAP_instantiate_ns6__OCSPValuesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__OCSPValuesType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__OCSPValuesType *p;
	size_t k = sizeof(ns6__OCSPValuesType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__OCSPValuesType);
		if (p)
			((ns6__OCSPValuesType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__OCSPValuesType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__OCSPValuesType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__OCSPValuesType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__OCSPValuesType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__OCSPValuesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__OCSPValuesType(soap, tag ? tag : "ns6:OCSPValuesType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__OCSPValuesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__OCSPValuesType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__OCSPValuesType * SOAP_FMAC4 soap_get_ns6__OCSPValuesType(struct soap *soap, ns6__OCSPValuesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__OCSPValuesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__EncapsulatedCRLValueType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__EncapsulatedCRLValueType::__item.xsd__base64Binary::soap_default(soap);
	soap_default_xsd__ID(soap, &this->ns6__EncapsulatedCRLValueType::Id);
	/* transient soap skipped */
}

void ns6__EncapsulatedCRLValueType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns6__EncapsulatedCRLValueType::__item, SOAP_TYPE_xsd__base64Binary);
	this->ns6__EncapsulatedCRLValueType::__item.soap_serialize(soap);
#endif
}

int ns6__EncapsulatedCRLValueType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__EncapsulatedCRLValueType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__EncapsulatedCRLValueType(struct soap *soap, const char *tag, int id, const ns6__EncapsulatedCRLValueType *a, const char *type)
{
	soap_set_attr(soap, "Id", soap_xsd__ID2s(soap, ((ns6__EncapsulatedCRLValueType*)a)->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return (a->ns6__EncapsulatedCRLValueType::__item).soap_out(soap, tag, id, "");
}

void *ns6__EncapsulatedCRLValueType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__EncapsulatedCRLValueType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__EncapsulatedCRLValueType * SOAP_FMAC4 soap_in_ns6__EncapsulatedCRLValueType(struct soap *soap, const char *tag, ns6__EncapsulatedCRLValueType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns6__EncapsulatedCRLValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__EncapsulatedCRLValueType, sizeof(ns6__EncapsulatedCRLValueType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__EncapsulatedCRLValueType)
		return (ns6__EncapsulatedCRLValueType *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__ID(soap, soap_attr_value(soap, "Id", 5, 1), &((ns6__EncapsulatedCRLValueType*)a)->Id))
		return NULL;
	if (!(a->ns6__EncapsulatedCRLValueType::__item).soap_in(soap, tag, "ns6:EncapsulatedCRLValueType"))
		return NULL;
	return a;
}

SOAP_FMAC1 ns6__EncapsulatedCRLValueType * SOAP_FMAC2 SCAP_instantiate_ns6__EncapsulatedCRLValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__EncapsulatedCRLValueType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__EncapsulatedCRLValueType *p;
	size_t k = sizeof(ns6__EncapsulatedCRLValueType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__EncapsulatedCRLValueType);
		if (p)
			((ns6__EncapsulatedCRLValueType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__EncapsulatedCRLValueType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__EncapsulatedCRLValueType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__EncapsulatedCRLValueType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__EncapsulatedCRLValueType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__EncapsulatedCRLValueType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__EncapsulatedCRLValueType(soap, tag ? tag : "ns6:EncapsulatedCRLValueType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__EncapsulatedCRLValueType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__EncapsulatedCRLValueType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__EncapsulatedCRLValueType * SOAP_FMAC4 soap_get_ns6__EncapsulatedCRLValueType(struct soap *soap, ns6__EncapsulatedCRLValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__EncapsulatedCRLValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__CRLValuesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons6__EncapsulatedCRLValueType(soap, &this->ns6__CRLValuesType::ns6__EncapsulatedCRLValue);
	soap_default_xsd__ID(soap, &this->ns6__CRLValuesType::Id);
	/* transient soap skipped */
}

void ns6__CRLValuesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons6__EncapsulatedCRLValueType(soap, &this->ns6__CRLValuesType::ns6__EncapsulatedCRLValue);
#endif
}

int ns6__CRLValuesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__CRLValuesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__CRLValuesType(struct soap *soap, const char *tag, int id, const ns6__CRLValuesType *a, const char *type)
{
	soap_set_attr(soap, "Id", soap_xsd__ID2s(soap, ((ns6__CRLValuesType*)a)->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__CRLValuesType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons6__EncapsulatedCRLValueType(soap, "ns6:EncapsulatedCRLValue", -1, &a->ns6__CRLValuesType::ns6__EncapsulatedCRLValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__CRLValuesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__CRLValuesType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__CRLValuesType * SOAP_FMAC4 soap_in_ns6__CRLValuesType(struct soap *soap, const char *tag, ns6__CRLValuesType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__CRLValuesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__CRLValuesType, sizeof(ns6__CRLValuesType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__CRLValuesType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__CRLValuesType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__ID(soap, soap_attr_value(soap, "Id", 5, 1), &((ns6__CRLValuesType*)a)->Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons6__EncapsulatedCRLValueType(soap, "ns6:EncapsulatedCRLValue", &a->ns6__CRLValuesType::ns6__EncapsulatedCRLValue, "ns6:EncapsulatedCRLValueType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns6__CRLValuesType::ns6__EncapsulatedCRLValue.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__CRLValuesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__CRLValuesType, SOAP_TYPE_ns6__CRLValuesType, sizeof(ns6__CRLValuesType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__CRLValuesType * SOAP_FMAC2 SCAP_instantiate_ns6__CRLValuesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__CRLValuesType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__CRLValuesType *p;
	size_t k = sizeof(ns6__CRLValuesType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__CRLValuesType);
		if (p)
			((ns6__CRLValuesType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__CRLValuesType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__CRLValuesType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__CRLValuesType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__CRLValuesType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__CRLValuesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__CRLValuesType(soap, tag ? tag : "ns6:CRLValuesType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__CRLValuesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__CRLValuesType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__CRLValuesType * SOAP_FMAC4 soap_get_ns6__CRLValuesType(struct soap *soap, ns6__CRLValuesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__CRLValuesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__RevocationValuesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__RevocationValuesType::ns6__CRLValues = NULL;
	this->ns6__RevocationValuesType::ns6__OCSPValues = NULL;
	soap_default_xsd__ID(soap, &this->ns6__RevocationValuesType::Id);
	/* transient soap skipped */
}

void ns6__RevocationValuesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons6__CRLValuesType(soap, &this->ns6__RevocationValuesType::ns6__CRLValues);
	soap_serialize_PointerTons6__OCSPValuesType(soap, &this->ns6__RevocationValuesType::ns6__OCSPValues);
#endif
}

int ns6__RevocationValuesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__RevocationValuesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__RevocationValuesType(struct soap *soap, const char *tag, int id, const ns6__RevocationValuesType *a, const char *type)
{
	soap_set_attr(soap, "Id", soap_xsd__ID2s(soap, ((ns6__RevocationValuesType*)a)->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__RevocationValuesType), type))
		return soap->error;
	if (!a->ns6__RevocationValuesType::ns6__CRLValues)
	{	if (soap_element_empty(soap, "ns6:CRLValues"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__CRLValuesType(soap, "ns6:CRLValues", -1, &a->ns6__RevocationValuesType::ns6__CRLValues, ""))
		return soap->error;
	if (!a->ns6__RevocationValuesType::ns6__OCSPValues)
	{	if (soap_element_empty(soap, "ns6:OCSPValues"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__OCSPValuesType(soap, "ns6:OCSPValues", -1, &a->ns6__RevocationValuesType::ns6__OCSPValues, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__RevocationValuesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__RevocationValuesType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__RevocationValuesType * SOAP_FMAC4 soap_in_ns6__RevocationValuesType(struct soap *soap, const char *tag, ns6__RevocationValuesType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__RevocationValuesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__RevocationValuesType, sizeof(ns6__RevocationValuesType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__RevocationValuesType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__RevocationValuesType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__ID(soap, soap_attr_value(soap, "Id", 5, 1), &((ns6__RevocationValuesType*)a)->Id))
		return NULL;
	size_t soap_flag_ns6__CRLValues1 = 1;
	size_t soap_flag_ns6__OCSPValues1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__CRLValues1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__CRLValuesType(soap, "ns6:CRLValues", &a->ns6__RevocationValuesType::ns6__CRLValues, "ns6:CRLValuesType"))
				{	soap_flag_ns6__CRLValues1--;
					continue;
				}
			}
			if (soap_flag_ns6__OCSPValues1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__OCSPValuesType(soap, "ns6:OCSPValues", &a->ns6__RevocationValuesType::ns6__OCSPValues, "ns6:OCSPValuesType"))
				{	soap_flag_ns6__OCSPValues1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns6__RevocationValuesType::ns6__CRLValues || !a->ns6__RevocationValuesType::ns6__OCSPValues))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__RevocationValuesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__RevocationValuesType, SOAP_TYPE_ns6__RevocationValuesType, sizeof(ns6__RevocationValuesType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__RevocationValuesType * SOAP_FMAC2 SCAP_instantiate_ns6__RevocationValuesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__RevocationValuesType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__RevocationValuesType *p;
	size_t k = sizeof(ns6__RevocationValuesType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__RevocationValuesType);
		if (p)
			((ns6__RevocationValuesType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__RevocationValuesType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__RevocationValuesType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__RevocationValuesType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__RevocationValuesType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__RevocationValuesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__RevocationValuesType(soap, tag ? tag : "ns6:RevocationValuesType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__RevocationValuesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__RevocationValuesType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__RevocationValuesType * SOAP_FMAC4 soap_get_ns6__RevocationValuesType(struct soap *soap, ns6__RevocationValuesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__RevocationValuesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__EncapsulatedX509CertificateType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__EncapsulatedX509CertificateType::__item.xsd__base64Binary::soap_default(soap);
	soap_default_xsd__ID(soap, &this->ns6__EncapsulatedX509CertificateType::Id);
	/* transient soap skipped */
}

void ns6__EncapsulatedX509CertificateType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns6__EncapsulatedX509CertificateType::__item, SOAP_TYPE_xsd__base64Binary);
	this->ns6__EncapsulatedX509CertificateType::__item.soap_serialize(soap);
#endif
}

int ns6__EncapsulatedX509CertificateType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__EncapsulatedX509CertificateType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__EncapsulatedX509CertificateType(struct soap *soap, const char *tag, int id, const ns6__EncapsulatedX509CertificateType *a, const char *type)
{
	soap_set_attr(soap, "Id", soap_xsd__ID2s(soap, ((ns6__EncapsulatedX509CertificateType*)a)->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return (a->ns6__EncapsulatedX509CertificateType::__item).soap_out(soap, tag, id, "");
}

void *ns6__EncapsulatedX509CertificateType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__EncapsulatedX509CertificateType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__EncapsulatedX509CertificateType * SOAP_FMAC4 soap_in_ns6__EncapsulatedX509CertificateType(struct soap *soap, const char *tag, ns6__EncapsulatedX509CertificateType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns6__EncapsulatedX509CertificateType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__EncapsulatedX509CertificateType, sizeof(ns6__EncapsulatedX509CertificateType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__EncapsulatedX509CertificateType)
		return (ns6__EncapsulatedX509CertificateType *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__ID(soap, soap_attr_value(soap, "Id", 5, 1), &((ns6__EncapsulatedX509CertificateType*)a)->Id))
		return NULL;
	if (!(a->ns6__EncapsulatedX509CertificateType::__item).soap_in(soap, tag, "ns6:EncapsulatedX509CertificateType"))
		return NULL;
	return a;
}

SOAP_FMAC1 ns6__EncapsulatedX509CertificateType * SOAP_FMAC2 SCAP_instantiate_ns6__EncapsulatedX509CertificateType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__EncapsulatedX509CertificateType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__EncapsulatedX509CertificateType *p;
	size_t k = sizeof(ns6__EncapsulatedX509CertificateType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__EncapsulatedX509CertificateType);
		if (p)
			((ns6__EncapsulatedX509CertificateType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__EncapsulatedX509CertificateType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__EncapsulatedX509CertificateType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__EncapsulatedX509CertificateType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__EncapsulatedX509CertificateType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__EncapsulatedX509CertificateType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__EncapsulatedX509CertificateType(soap, tag ? tag : "ns6:EncapsulatedX509CertificateType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__EncapsulatedX509CertificateType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__EncapsulatedX509CertificateType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__EncapsulatedX509CertificateType * SOAP_FMAC4 soap_get_ns6__EncapsulatedX509CertificateType(struct soap *soap, ns6__EncapsulatedX509CertificateType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__EncapsulatedX509CertificateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__CertificateValuesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons6__EncapsulatedX509CertificateType(soap, &this->ns6__CertificateValuesType::ns6__EncapsulatedX509Certificate);
	soap_default_xsd__ID(soap, &this->ns6__CertificateValuesType::Id);
	/* transient soap skipped */
}

void ns6__CertificateValuesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons6__EncapsulatedX509CertificateType(soap, &this->ns6__CertificateValuesType::ns6__EncapsulatedX509Certificate);
#endif
}

int ns6__CertificateValuesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__CertificateValuesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__CertificateValuesType(struct soap *soap, const char *tag, int id, const ns6__CertificateValuesType *a, const char *type)
{
	soap_set_attr(soap, "Id", soap_xsd__ID2s(soap, ((ns6__CertificateValuesType*)a)->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__CertificateValuesType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons6__EncapsulatedX509CertificateType(soap, "ns6:EncapsulatedX509Certificate", -1, &a->ns6__CertificateValuesType::ns6__EncapsulatedX509Certificate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__CertificateValuesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__CertificateValuesType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__CertificateValuesType * SOAP_FMAC4 soap_in_ns6__CertificateValuesType(struct soap *soap, const char *tag, ns6__CertificateValuesType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__CertificateValuesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__CertificateValuesType, sizeof(ns6__CertificateValuesType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__CertificateValuesType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__CertificateValuesType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__ID(soap, soap_attr_value(soap, "Id", 5, 1), &((ns6__CertificateValuesType*)a)->Id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons6__EncapsulatedX509CertificateType(soap, "ns6:EncapsulatedX509Certificate", &a->ns6__CertificateValuesType::ns6__EncapsulatedX509Certificate, "ns6:EncapsulatedX509CertificateType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns6__CertificateValuesType::ns6__EncapsulatedX509Certificate.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__CertificateValuesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__CertificateValuesType, SOAP_TYPE_ns6__CertificateValuesType, sizeof(ns6__CertificateValuesType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__CertificateValuesType * SOAP_FMAC2 SCAP_instantiate_ns6__CertificateValuesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__CertificateValuesType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__CertificateValuesType *p;
	size_t k = sizeof(ns6__CertificateValuesType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__CertificateValuesType);
		if (p)
			((ns6__CertificateValuesType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__CertificateValuesType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__CertificateValuesType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__CertificateValuesType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__CertificateValuesType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__CertificateValuesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__CertificateValuesType(soap, tag ? tag : "ns6:CertificateValuesType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__CertificateValuesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__CertificateValuesType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__CertificateValuesType * SOAP_FMAC4 soap_get_ns6__CertificateValuesType(struct soap *soap, ns6__CertificateValuesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__CertificateValuesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__SigAndRefsTimeStampType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__SigAndRefsTimeStampType::ns5__CanonicalizationMethod = NULL;
	soap_default_ns6__EncapsulatedTimeStampType(soap, &this->ns6__SigAndRefsTimeStampType::ns6__EncapsulatedTimeStamp);
	/* transient soap skipped */
}

void ns6__SigAndRefsTimeStampType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__CanonicalizationMethodType(soap, &this->ns6__SigAndRefsTimeStampType::ns5__CanonicalizationMethod);
	soap_serialize_ns6__EncapsulatedTimeStampType(soap, &this->ns6__SigAndRefsTimeStampType::ns6__EncapsulatedTimeStamp);
#endif
}

int ns6__SigAndRefsTimeStampType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__SigAndRefsTimeStampType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__SigAndRefsTimeStampType(struct soap *soap, const char *tag, int id, const ns6__SigAndRefsTimeStampType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__SigAndRefsTimeStampType), type))
		return soap->error;
	if (!a->ns6__SigAndRefsTimeStampType::ns5__CanonicalizationMethod)
	{	if (soap_element_empty(soap, "ns5:CanonicalizationMethod"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__CanonicalizationMethodType(soap, "ns5:CanonicalizationMethod", -1, &a->ns6__SigAndRefsTimeStampType::ns5__CanonicalizationMethod, ""))
		return soap->error;
	if (soap_out_ns6__EncapsulatedTimeStampType(soap, "ns6:EncapsulatedTimeStamp", -1, &a->ns6__SigAndRefsTimeStampType::ns6__EncapsulatedTimeStamp, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__SigAndRefsTimeStampType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__SigAndRefsTimeStampType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__SigAndRefsTimeStampType * SOAP_FMAC4 soap_in_ns6__SigAndRefsTimeStampType(struct soap *soap, const char *tag, ns6__SigAndRefsTimeStampType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__SigAndRefsTimeStampType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__SigAndRefsTimeStampType, sizeof(ns6__SigAndRefsTimeStampType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__SigAndRefsTimeStampType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__SigAndRefsTimeStampType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ns5__CanonicalizationMethod1 = 1;
	size_t soap_flag_ns6__EncapsulatedTimeStamp1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__CanonicalizationMethod1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__CanonicalizationMethodType(soap, "ns5:CanonicalizationMethod", &a->ns6__SigAndRefsTimeStampType::ns5__CanonicalizationMethod, "ns5:CanonicalizationMethodType"))
				{	soap_flag_ns5__CanonicalizationMethod1--;
					continue;
				}
			}
			if (soap_flag_ns6__EncapsulatedTimeStamp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns6__EncapsulatedTimeStampType(soap, "ns6:EncapsulatedTimeStamp", &a->ns6__SigAndRefsTimeStampType::ns6__EncapsulatedTimeStamp, "ns6:EncapsulatedTimeStampType"))
				{	soap_flag_ns6__EncapsulatedTimeStamp1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns6__SigAndRefsTimeStampType::ns5__CanonicalizationMethod || soap_flag_ns6__EncapsulatedTimeStamp1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__SigAndRefsTimeStampType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__SigAndRefsTimeStampType, SOAP_TYPE_ns6__SigAndRefsTimeStampType, sizeof(ns6__SigAndRefsTimeStampType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__SigAndRefsTimeStampType * SOAP_FMAC2 SCAP_instantiate_ns6__SigAndRefsTimeStampType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__SigAndRefsTimeStampType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__SigAndRefsTimeStampType *p;
	size_t k = sizeof(ns6__SigAndRefsTimeStampType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__SigAndRefsTimeStampType);
		if (p)
			((ns6__SigAndRefsTimeStampType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__SigAndRefsTimeStampType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__SigAndRefsTimeStampType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__SigAndRefsTimeStampType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__SigAndRefsTimeStampType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__SigAndRefsTimeStampType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__SigAndRefsTimeStampType(soap, tag ? tag : "ns6:SigAndRefsTimeStampType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__SigAndRefsTimeStampType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__SigAndRefsTimeStampType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__SigAndRefsTimeStampType * SOAP_FMAC4 soap_get_ns6__SigAndRefsTimeStampType(struct soap *soap, ns6__SigAndRefsTimeStampType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__SigAndRefsTimeStampType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__ResponderIDType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__ResponderIDType::ns6__ByName = NULL;
	/* transient soap skipped */
}

void ns6__ResponderIDType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns6__ResponderIDType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ResponderIDType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ResponderIDType(struct soap *soap, const char *tag, int id, const ns6__ResponderIDType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ResponderIDType), type))
		return soap->error;
	if (!a->ns6__ResponderIDType::ns6__ByName)
	{	if (soap_element_empty(soap, "ns6:ByName"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "ns6:ByName", (char*const*)&a->ns6__ResponderIDType::ns6__ByName, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__ResponderIDType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__ResponderIDType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ResponderIDType * SOAP_FMAC4 soap_in_ns6__ResponderIDType(struct soap *soap, const char *tag, ns6__ResponderIDType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ResponderIDType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ResponderIDType, sizeof(ns6__ResponderIDType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__ResponderIDType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__ResponderIDType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ns6__ByName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__ByName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns6:ByName", (char**)&a->ns6__ResponderIDType::ns6__ByName))
				{	soap_flag_ns6__ByName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns6__ResponderIDType::ns6__ByName))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__ResponderIDType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ResponderIDType, SOAP_TYPE_ns6__ResponderIDType, sizeof(ns6__ResponderIDType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__ResponderIDType * SOAP_FMAC2 SCAP_instantiate_ns6__ResponderIDType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__ResponderIDType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__ResponderIDType *p;
	size_t k = sizeof(ns6__ResponderIDType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__ResponderIDType);
		if (p)
			((ns6__ResponderIDType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__ResponderIDType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__ResponderIDType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__ResponderIDType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__ResponderIDType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__ResponderIDType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__ResponderIDType(soap, tag ? tag : "ns6:ResponderIDType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__ResponderIDType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ResponderIDType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ResponderIDType * SOAP_FMAC4 soap_get_ns6__ResponderIDType(struct soap *soap, ns6__ResponderIDType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ResponderIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__OCSPIdentifierType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__OCSPIdentifierType::ns6__ResponderID = NULL;
	this->ns6__OCSPIdentifierType::ns6__ProducedAt = NULL;
	/* transient soap skipped */
}

void ns6__OCSPIdentifierType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons6__ResponderIDType(soap, &this->ns6__OCSPIdentifierType::ns6__ResponderID);
#endif
}

int ns6__OCSPIdentifierType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__OCSPIdentifierType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__OCSPIdentifierType(struct soap *soap, const char *tag, int id, const ns6__OCSPIdentifierType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__OCSPIdentifierType), type))
		return soap->error;
	if (!a->ns6__OCSPIdentifierType::ns6__ResponderID)
	{	if (soap_element_empty(soap, "ns6:ResponderID"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__ResponderIDType(soap, "ns6:ResponderID", -1, &a->ns6__OCSPIdentifierType::ns6__ResponderID, ""))
		return soap->error;
	if (!a->ns6__OCSPIdentifierType::ns6__ProducedAt)
	{	if (soap_element_empty(soap, "ns6:ProducedAt"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "ns6:ProducedAt", (char*const*)&a->ns6__OCSPIdentifierType::ns6__ProducedAt, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__OCSPIdentifierType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__OCSPIdentifierType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__OCSPIdentifierType * SOAP_FMAC4 soap_in_ns6__OCSPIdentifierType(struct soap *soap, const char *tag, ns6__OCSPIdentifierType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__OCSPIdentifierType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__OCSPIdentifierType, sizeof(ns6__OCSPIdentifierType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__OCSPIdentifierType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__OCSPIdentifierType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ns6__ResponderID1 = 1;
	size_t soap_flag_ns6__ProducedAt1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__ResponderID1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__ResponderIDType(soap, "ns6:ResponderID", &a->ns6__OCSPIdentifierType::ns6__ResponderID, "ns6:ResponderIDType"))
				{	soap_flag_ns6__ResponderID1--;
					continue;
				}
			}
			if (soap_flag_ns6__ProducedAt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns6:ProducedAt", (char**)&a->ns6__OCSPIdentifierType::ns6__ProducedAt))
				{	soap_flag_ns6__ProducedAt1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns6__OCSPIdentifierType::ns6__ResponderID || !a->ns6__OCSPIdentifierType::ns6__ProducedAt))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__OCSPIdentifierType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__OCSPIdentifierType, SOAP_TYPE_ns6__OCSPIdentifierType, sizeof(ns6__OCSPIdentifierType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__OCSPIdentifierType * SOAP_FMAC2 SCAP_instantiate_ns6__OCSPIdentifierType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__OCSPIdentifierType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__OCSPIdentifierType *p;
	size_t k = sizeof(ns6__OCSPIdentifierType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__OCSPIdentifierType);
		if (p)
			((ns6__OCSPIdentifierType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__OCSPIdentifierType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__OCSPIdentifierType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__OCSPIdentifierType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__OCSPIdentifierType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__OCSPIdentifierType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__OCSPIdentifierType(soap, tag ? tag : "ns6:OCSPIdentifierType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__OCSPIdentifierType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__OCSPIdentifierType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__OCSPIdentifierType * SOAP_FMAC4 soap_get_ns6__OCSPIdentifierType(struct soap *soap, ns6__OCSPIdentifierType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__OCSPIdentifierType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__OCSPRefType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__OCSPRefType::ns6__OCSPIdentifier = NULL;
	this->ns6__OCSPRefType::ns6__DigestAlgAndValue = NULL;
	/* transient soap skipped */
}

void ns6__OCSPRefType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons6__OCSPIdentifierType(soap, &this->ns6__OCSPRefType::ns6__OCSPIdentifier);
	soap_serialize_PointerTons6__DigestAlgAndValueType(soap, &this->ns6__OCSPRefType::ns6__DigestAlgAndValue);
#endif
}

int ns6__OCSPRefType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__OCSPRefType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__OCSPRefType(struct soap *soap, const char *tag, int id, const ns6__OCSPRefType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__OCSPRefType), type))
		return soap->error;
	if (!a->ns6__OCSPRefType::ns6__OCSPIdentifier)
	{	if (soap_element_empty(soap, "ns6:OCSPIdentifier"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__OCSPIdentifierType(soap, "ns6:OCSPIdentifier", -1, &a->ns6__OCSPRefType::ns6__OCSPIdentifier, ""))
		return soap->error;
	if (!a->ns6__OCSPRefType::ns6__DigestAlgAndValue)
	{	if (soap_element_empty(soap, "ns6:DigestAlgAndValue"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__DigestAlgAndValueType(soap, "ns6:DigestAlgAndValue", -1, &a->ns6__OCSPRefType::ns6__DigestAlgAndValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__OCSPRefType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__OCSPRefType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__OCSPRefType * SOAP_FMAC4 soap_in_ns6__OCSPRefType(struct soap *soap, const char *tag, ns6__OCSPRefType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__OCSPRefType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__OCSPRefType, sizeof(ns6__OCSPRefType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__OCSPRefType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__OCSPRefType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ns6__OCSPIdentifier1 = 1;
	size_t soap_flag_ns6__DigestAlgAndValue1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__OCSPIdentifier1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__OCSPIdentifierType(soap, "ns6:OCSPIdentifier", &a->ns6__OCSPRefType::ns6__OCSPIdentifier, "ns6:OCSPIdentifierType"))
				{	soap_flag_ns6__OCSPIdentifier1--;
					continue;
				}
			}
			if (soap_flag_ns6__DigestAlgAndValue1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__DigestAlgAndValueType(soap, "ns6:DigestAlgAndValue", &a->ns6__OCSPRefType::ns6__DigestAlgAndValue, "ns6:DigestAlgAndValueType"))
				{	soap_flag_ns6__DigestAlgAndValue1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns6__OCSPRefType::ns6__OCSPIdentifier || !a->ns6__OCSPRefType::ns6__DigestAlgAndValue))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__OCSPRefType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__OCSPRefType, SOAP_TYPE_ns6__OCSPRefType, sizeof(ns6__OCSPRefType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__OCSPRefType * SOAP_FMAC2 SCAP_instantiate_ns6__OCSPRefType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__OCSPRefType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__OCSPRefType *p;
	size_t k = sizeof(ns6__OCSPRefType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__OCSPRefType);
		if (p)
			((ns6__OCSPRefType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__OCSPRefType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__OCSPRefType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__OCSPRefType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__OCSPRefType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__OCSPRefType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__OCSPRefType(soap, tag ? tag : "ns6:OCSPRefType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__OCSPRefType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__OCSPRefType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__OCSPRefType * SOAP_FMAC4 soap_get_ns6__OCSPRefType(struct soap *soap, ns6__OCSPRefType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__OCSPRefType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__OCSPRefsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons6__OCSPRefType(soap, &this->ns6__OCSPRefsType::ns6__OCSPRef);
	/* transient soap skipped */
}

void ns6__OCSPRefsType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons6__OCSPRefType(soap, &this->ns6__OCSPRefsType::ns6__OCSPRef);
#endif
}

int ns6__OCSPRefsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__OCSPRefsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__OCSPRefsType(struct soap *soap, const char *tag, int id, const ns6__OCSPRefsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__OCSPRefsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons6__OCSPRefType(soap, "ns6:OCSPRef", -1, &a->ns6__OCSPRefsType::ns6__OCSPRef, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__OCSPRefsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__OCSPRefsType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__OCSPRefsType * SOAP_FMAC4 soap_in_ns6__OCSPRefsType(struct soap *soap, const char *tag, ns6__OCSPRefsType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__OCSPRefsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__OCSPRefsType, sizeof(ns6__OCSPRefsType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__OCSPRefsType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__OCSPRefsType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons6__OCSPRefType(soap, "ns6:OCSPRef", &a->ns6__OCSPRefsType::ns6__OCSPRef, "ns6:OCSPRefType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns6__OCSPRefsType::ns6__OCSPRef.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__OCSPRefsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__OCSPRefsType, SOAP_TYPE_ns6__OCSPRefsType, sizeof(ns6__OCSPRefsType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__OCSPRefsType * SOAP_FMAC2 SCAP_instantiate_ns6__OCSPRefsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__OCSPRefsType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__OCSPRefsType *p;
	size_t k = sizeof(ns6__OCSPRefsType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__OCSPRefsType);
		if (p)
			((ns6__OCSPRefsType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__OCSPRefsType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__OCSPRefsType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__OCSPRefsType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__OCSPRefsType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__OCSPRefsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__OCSPRefsType(soap, tag ? tag : "ns6:OCSPRefsType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__OCSPRefsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__OCSPRefsType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__OCSPRefsType * SOAP_FMAC4 soap_get_ns6__OCSPRefsType(struct soap *soap, ns6__OCSPRefsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__OCSPRefsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__CRLIdentifierType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__CRLIdentifierType::ns6__Issuer = NULL;
	this->ns6__CRLIdentifierType::ns6__IssueTime = NULL;
	this->ns6__CRLIdentifierType::ns6__Number = NULL;
	/* transient soap skipped */
}

void ns6__CRLIdentifierType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns6__CRLIdentifierType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__CRLIdentifierType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__CRLIdentifierType(struct soap *soap, const char *tag, int id, const ns6__CRLIdentifierType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__CRLIdentifierType), type))
		return soap->error;
	if (!a->ns6__CRLIdentifierType::ns6__Issuer)
	{	if (soap_element_empty(soap, "ns6:Issuer"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "ns6:Issuer", (char*const*)&a->ns6__CRLIdentifierType::ns6__Issuer, NULL))
		return soap->error;
	if (!a->ns6__CRLIdentifierType::ns6__IssueTime)
	{	if (soap_element_empty(soap, "ns6:IssueTime"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "ns6:IssueTime", (char*const*)&a->ns6__CRLIdentifierType::ns6__IssueTime, NULL))
		return soap->error;
	if (!a->ns6__CRLIdentifierType::ns6__Number)
	{	if (soap_element_empty(soap, "ns6:Number"))
			return soap->error;
	}
	else
	if (soap_outliteral(soap, "ns6:Number", (char*const*)&a->ns6__CRLIdentifierType::ns6__Number, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__CRLIdentifierType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__CRLIdentifierType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__CRLIdentifierType * SOAP_FMAC4 soap_in_ns6__CRLIdentifierType(struct soap *soap, const char *tag, ns6__CRLIdentifierType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__CRLIdentifierType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__CRLIdentifierType, sizeof(ns6__CRLIdentifierType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__CRLIdentifierType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__CRLIdentifierType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ns6__Issuer1 = 1;
	size_t soap_flag_ns6__IssueTime1 = 1;
	size_t soap_flag_ns6__Number1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__Issuer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns6:Issuer", (char**)&a->ns6__CRLIdentifierType::ns6__Issuer))
				{	soap_flag_ns6__Issuer1--;
					continue;
				}
			}
			if (soap_flag_ns6__IssueTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns6:IssueTime", (char**)&a->ns6__CRLIdentifierType::ns6__IssueTime))
				{	soap_flag_ns6__IssueTime1--;
					continue;
				}
			}
			if (soap_flag_ns6__Number1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns6:Number", (char**)&a->ns6__CRLIdentifierType::ns6__Number))
				{	soap_flag_ns6__Number1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns6__CRLIdentifierType::ns6__Issuer || !a->ns6__CRLIdentifierType::ns6__IssueTime || !a->ns6__CRLIdentifierType::ns6__Number))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__CRLIdentifierType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__CRLIdentifierType, SOAP_TYPE_ns6__CRLIdentifierType, sizeof(ns6__CRLIdentifierType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__CRLIdentifierType * SOAP_FMAC2 SCAP_instantiate_ns6__CRLIdentifierType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__CRLIdentifierType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__CRLIdentifierType *p;
	size_t k = sizeof(ns6__CRLIdentifierType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__CRLIdentifierType);
		if (p)
			((ns6__CRLIdentifierType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__CRLIdentifierType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__CRLIdentifierType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__CRLIdentifierType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__CRLIdentifierType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__CRLIdentifierType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__CRLIdentifierType(soap, tag ? tag : "ns6:CRLIdentifierType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__CRLIdentifierType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__CRLIdentifierType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__CRLIdentifierType * SOAP_FMAC4 soap_get_ns6__CRLIdentifierType(struct soap *soap, ns6__CRLIdentifierType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__CRLIdentifierType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__DigestAlgAndValueType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__DigestAlgAndValueType::ns5__DigestMethod = NULL;
	this->ns6__DigestAlgAndValueType::ns5__DigestValue = NULL;
	/* transient soap skipped */
}

void ns6__DigestAlgAndValueType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__DigestMethodType(soap, &this->ns6__DigestAlgAndValueType::ns5__DigestMethod);
	soap_serialize_PointerTons5__DigestValueType(soap, &this->ns6__DigestAlgAndValueType::ns5__DigestValue);
#endif
}

int ns6__DigestAlgAndValueType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__DigestAlgAndValueType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__DigestAlgAndValueType(struct soap *soap, const char *tag, int id, const ns6__DigestAlgAndValueType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__DigestAlgAndValueType), type))
		return soap->error;
	if (!a->ns6__DigestAlgAndValueType::ns5__DigestMethod)
	{	if (soap_element_empty(soap, "ns5:DigestMethod"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__DigestMethodType(soap, "ns5:DigestMethod", -1, &a->ns6__DigestAlgAndValueType::ns5__DigestMethod, ""))
		return soap->error;
	if (!a->ns6__DigestAlgAndValueType::ns5__DigestValue)
	{	if (soap_element_empty(soap, "ns5:DigestValue"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__DigestValueType(soap, "ns5:DigestValue", -1, &a->ns6__DigestAlgAndValueType::ns5__DigestValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__DigestAlgAndValueType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__DigestAlgAndValueType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__DigestAlgAndValueType * SOAP_FMAC4 soap_in_ns6__DigestAlgAndValueType(struct soap *soap, const char *tag, ns6__DigestAlgAndValueType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__DigestAlgAndValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__DigestAlgAndValueType, sizeof(ns6__DigestAlgAndValueType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__DigestAlgAndValueType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__DigestAlgAndValueType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ns5__DigestMethod1 = 1;
	size_t soap_flag_ns5__DigestValue1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__DigestMethod1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__DigestMethodType(soap, "ns5:DigestMethod", &a->ns6__DigestAlgAndValueType::ns5__DigestMethod, "ns5:DigestMethodType"))
				{	soap_flag_ns5__DigestMethod1--;
					continue;
				}
			}
			if (soap_flag_ns5__DigestValue1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__DigestValueType(soap, "ns5:DigestValue", &a->ns6__DigestAlgAndValueType::ns5__DigestValue, "ns5:DigestValueType"))
				{	soap_flag_ns5__DigestValue1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns6__DigestAlgAndValueType::ns5__DigestMethod || !a->ns6__DigestAlgAndValueType::ns5__DigestValue))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__DigestAlgAndValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__DigestAlgAndValueType, SOAP_TYPE_ns6__DigestAlgAndValueType, sizeof(ns6__DigestAlgAndValueType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__DigestAlgAndValueType * SOAP_FMAC2 SCAP_instantiate_ns6__DigestAlgAndValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__DigestAlgAndValueType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__DigestAlgAndValueType *p;
	size_t k = sizeof(ns6__DigestAlgAndValueType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__DigestAlgAndValueType);
		if (p)
			((ns6__DigestAlgAndValueType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__DigestAlgAndValueType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__DigestAlgAndValueType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__DigestAlgAndValueType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__DigestAlgAndValueType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__DigestAlgAndValueType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__DigestAlgAndValueType(soap, tag ? tag : "ns6:DigestAlgAndValueType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__DigestAlgAndValueType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__DigestAlgAndValueType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__DigestAlgAndValueType * SOAP_FMAC4 soap_get_ns6__DigestAlgAndValueType(struct soap *soap, ns6__DigestAlgAndValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__DigestAlgAndValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__CRLRefType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__CRLRefType::ns6__DigestAlgAndValue = NULL;
	this->ns6__CRLRefType::ns6__CRLIdentifier = NULL;
	/* transient soap skipped */
}

void ns6__CRLRefType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons6__DigestAlgAndValueType(soap, &this->ns6__CRLRefType::ns6__DigestAlgAndValue);
	soap_serialize_PointerTons6__CRLIdentifierType(soap, &this->ns6__CRLRefType::ns6__CRLIdentifier);
#endif
}

int ns6__CRLRefType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__CRLRefType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__CRLRefType(struct soap *soap, const char *tag, int id, const ns6__CRLRefType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__CRLRefType), type))
		return soap->error;
	if (!a->ns6__CRLRefType::ns6__DigestAlgAndValue)
	{	if (soap_element_empty(soap, "ns6:DigestAlgAndValue"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__DigestAlgAndValueType(soap, "ns6:DigestAlgAndValue", -1, &a->ns6__CRLRefType::ns6__DigestAlgAndValue, ""))
		return soap->error;
	if (!a->ns6__CRLRefType::ns6__CRLIdentifier)
	{	if (soap_element_empty(soap, "ns6:CRLIdentifier"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__CRLIdentifierType(soap, "ns6:CRLIdentifier", -1, &a->ns6__CRLRefType::ns6__CRLIdentifier, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__CRLRefType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__CRLRefType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__CRLRefType * SOAP_FMAC4 soap_in_ns6__CRLRefType(struct soap *soap, const char *tag, ns6__CRLRefType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__CRLRefType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__CRLRefType, sizeof(ns6__CRLRefType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__CRLRefType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__CRLRefType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ns6__DigestAlgAndValue1 = 1;
	size_t soap_flag_ns6__CRLIdentifier1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__DigestAlgAndValue1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__DigestAlgAndValueType(soap, "ns6:DigestAlgAndValue", &a->ns6__CRLRefType::ns6__DigestAlgAndValue, "ns6:DigestAlgAndValueType"))
				{	soap_flag_ns6__DigestAlgAndValue1--;
					continue;
				}
			}
			if (soap_flag_ns6__CRLIdentifier1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__CRLIdentifierType(soap, "ns6:CRLIdentifier", &a->ns6__CRLRefType::ns6__CRLIdentifier, "ns6:CRLIdentifierType"))
				{	soap_flag_ns6__CRLIdentifier1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns6__CRLRefType::ns6__DigestAlgAndValue || !a->ns6__CRLRefType::ns6__CRLIdentifier))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__CRLRefType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__CRLRefType, SOAP_TYPE_ns6__CRLRefType, sizeof(ns6__CRLRefType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__CRLRefType * SOAP_FMAC2 SCAP_instantiate_ns6__CRLRefType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__CRLRefType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__CRLRefType *p;
	size_t k = sizeof(ns6__CRLRefType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__CRLRefType);
		if (p)
			((ns6__CRLRefType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__CRLRefType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__CRLRefType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__CRLRefType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__CRLRefType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__CRLRefType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__CRLRefType(soap, tag ? tag : "ns6:CRLRefType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__CRLRefType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__CRLRefType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__CRLRefType * SOAP_FMAC4 soap_get_ns6__CRLRefType(struct soap *soap, ns6__CRLRefType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__CRLRefType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__CRLRefsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons6__CRLRefType(soap, &this->ns6__CRLRefsType::ns6__CRLRef);
	/* transient soap skipped */
}

void ns6__CRLRefsType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons6__CRLRefType(soap, &this->ns6__CRLRefsType::ns6__CRLRef);
#endif
}

int ns6__CRLRefsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__CRLRefsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__CRLRefsType(struct soap *soap, const char *tag, int id, const ns6__CRLRefsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__CRLRefsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons6__CRLRefType(soap, "ns6:CRLRef", -1, &a->ns6__CRLRefsType::ns6__CRLRef, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__CRLRefsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__CRLRefsType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__CRLRefsType * SOAP_FMAC4 soap_in_ns6__CRLRefsType(struct soap *soap, const char *tag, ns6__CRLRefsType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__CRLRefsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__CRLRefsType, sizeof(ns6__CRLRefsType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__CRLRefsType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__CRLRefsType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons6__CRLRefType(soap, "ns6:CRLRef", &a->ns6__CRLRefsType::ns6__CRLRef, "ns6:CRLRefType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns6__CRLRefsType::ns6__CRLRef.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__CRLRefsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__CRLRefsType, SOAP_TYPE_ns6__CRLRefsType, sizeof(ns6__CRLRefsType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__CRLRefsType * SOAP_FMAC2 SCAP_instantiate_ns6__CRLRefsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__CRLRefsType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__CRLRefsType *p;
	size_t k = sizeof(ns6__CRLRefsType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__CRLRefsType);
		if (p)
			((ns6__CRLRefsType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__CRLRefsType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__CRLRefsType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__CRLRefsType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__CRLRefsType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__CRLRefsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__CRLRefsType(soap, tag ? tag : "ns6:CRLRefsType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__CRLRefsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__CRLRefsType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__CRLRefsType * SOAP_FMAC4 soap_get_ns6__CRLRefsType(struct soap *soap, ns6__CRLRefsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__CRLRefsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__CompleteRevocationRefsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__CompleteRevocationRefsType::ns6__CRLRefs = NULL;
	this->ns6__CompleteRevocationRefsType::ns6__OCSPRefs = NULL;
	/* transient soap skipped */
}

void ns6__CompleteRevocationRefsType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons6__CRLRefsType(soap, &this->ns6__CompleteRevocationRefsType::ns6__CRLRefs);
	soap_serialize_PointerTons6__OCSPRefsType(soap, &this->ns6__CompleteRevocationRefsType::ns6__OCSPRefs);
#endif
}

int ns6__CompleteRevocationRefsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__CompleteRevocationRefsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__CompleteRevocationRefsType(struct soap *soap, const char *tag, int id, const ns6__CompleteRevocationRefsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__CompleteRevocationRefsType), type))
		return soap->error;
	if (!a->ns6__CompleteRevocationRefsType::ns6__CRLRefs)
	{	if (soap_element_empty(soap, "ns6:CRLRefs"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__CRLRefsType(soap, "ns6:CRLRefs", -1, &a->ns6__CompleteRevocationRefsType::ns6__CRLRefs, ""))
		return soap->error;
	if (!a->ns6__CompleteRevocationRefsType::ns6__OCSPRefs)
	{	if (soap_element_empty(soap, "ns6:OCSPRefs"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__OCSPRefsType(soap, "ns6:OCSPRefs", -1, &a->ns6__CompleteRevocationRefsType::ns6__OCSPRefs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__CompleteRevocationRefsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__CompleteRevocationRefsType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__CompleteRevocationRefsType * SOAP_FMAC4 soap_in_ns6__CompleteRevocationRefsType(struct soap *soap, const char *tag, ns6__CompleteRevocationRefsType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__CompleteRevocationRefsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__CompleteRevocationRefsType, sizeof(ns6__CompleteRevocationRefsType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__CompleteRevocationRefsType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__CompleteRevocationRefsType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ns6__CRLRefs1 = 1;
	size_t soap_flag_ns6__OCSPRefs1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__CRLRefs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__CRLRefsType(soap, "ns6:CRLRefs", &a->ns6__CompleteRevocationRefsType::ns6__CRLRefs, "ns6:CRLRefsType"))
				{	soap_flag_ns6__CRLRefs1--;
					continue;
				}
			}
			if (soap_flag_ns6__OCSPRefs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__OCSPRefsType(soap, "ns6:OCSPRefs", &a->ns6__CompleteRevocationRefsType::ns6__OCSPRefs, "ns6:OCSPRefsType"))
				{	soap_flag_ns6__OCSPRefs1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns6__CompleteRevocationRefsType::ns6__CRLRefs || !a->ns6__CompleteRevocationRefsType::ns6__OCSPRefs))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__CompleteRevocationRefsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__CompleteRevocationRefsType, SOAP_TYPE_ns6__CompleteRevocationRefsType, sizeof(ns6__CompleteRevocationRefsType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__CompleteRevocationRefsType * SOAP_FMAC2 SCAP_instantiate_ns6__CompleteRevocationRefsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__CompleteRevocationRefsType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__CompleteRevocationRefsType *p;
	size_t k = sizeof(ns6__CompleteRevocationRefsType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__CompleteRevocationRefsType);
		if (p)
			((ns6__CompleteRevocationRefsType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__CompleteRevocationRefsType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__CompleteRevocationRefsType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__CompleteRevocationRefsType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__CompleteRevocationRefsType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__CompleteRevocationRefsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__CompleteRevocationRefsType(soap, tag ? tag : "ns6:CompleteRevocationRefsType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__CompleteRevocationRefsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__CompleteRevocationRefsType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__CompleteRevocationRefsType * SOAP_FMAC4 soap_get_ns6__CompleteRevocationRefsType(struct soap *soap, ns6__CompleteRevocationRefsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__CompleteRevocationRefsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__CertRefsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons6__CertType(soap, &this->ns6__CertRefsType::ns6__Cert);
	/* transient soap skipped */
}

void ns6__CertRefsType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons6__CertType(soap, &this->ns6__CertRefsType::ns6__Cert);
#endif
}

int ns6__CertRefsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__CertRefsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__CertRefsType(struct soap *soap, const char *tag, int id, const ns6__CertRefsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__CertRefsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons6__CertType(soap, "ns6:Cert", -1, &a->ns6__CertRefsType::ns6__Cert, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__CertRefsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__CertRefsType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__CertRefsType * SOAP_FMAC4 soap_in_ns6__CertRefsType(struct soap *soap, const char *tag, ns6__CertRefsType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__CertRefsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__CertRefsType, sizeof(ns6__CertRefsType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__CertRefsType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__CertRefsType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons6__CertType(soap, "ns6:Cert", &a->ns6__CertRefsType::ns6__Cert, "ns6:CertType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns6__CertRefsType::ns6__Cert.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__CertRefsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__CertRefsType, SOAP_TYPE_ns6__CertRefsType, sizeof(ns6__CertRefsType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__CertRefsType * SOAP_FMAC2 SCAP_instantiate_ns6__CertRefsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__CertRefsType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__CertRefsType *p;
	size_t k = sizeof(ns6__CertRefsType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__CertRefsType);
		if (p)
			((ns6__CertRefsType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__CertRefsType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__CertRefsType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__CertRefsType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__CertRefsType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__CertRefsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__CertRefsType(soap, tag ? tag : "ns6:CertRefsType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__CertRefsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__CertRefsType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__CertRefsType * SOAP_FMAC4 soap_get_ns6__CertRefsType(struct soap *soap, ns6__CertRefsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__CertRefsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__CompleteCertificateRefsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__CompleteCertificateRefsType::ns6__CertRefs = NULL;
	/* transient soap skipped */
}

void ns6__CompleteCertificateRefsType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons6__CertRefsType(soap, &this->ns6__CompleteCertificateRefsType::ns6__CertRefs);
#endif
}

int ns6__CompleteCertificateRefsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__CompleteCertificateRefsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__CompleteCertificateRefsType(struct soap *soap, const char *tag, int id, const ns6__CompleteCertificateRefsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__CompleteCertificateRefsType), type))
		return soap->error;
	if (!a->ns6__CompleteCertificateRefsType::ns6__CertRefs)
	{	if (soap_element_empty(soap, "ns6:CertRefs"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__CertRefsType(soap, "ns6:CertRefs", -1, &a->ns6__CompleteCertificateRefsType::ns6__CertRefs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__CompleteCertificateRefsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__CompleteCertificateRefsType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__CompleteCertificateRefsType * SOAP_FMAC4 soap_in_ns6__CompleteCertificateRefsType(struct soap *soap, const char *tag, ns6__CompleteCertificateRefsType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__CompleteCertificateRefsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__CompleteCertificateRefsType, sizeof(ns6__CompleteCertificateRefsType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__CompleteCertificateRefsType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__CompleteCertificateRefsType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ns6__CertRefs1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__CertRefs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__CertRefsType(soap, "ns6:CertRefs", &a->ns6__CompleteCertificateRefsType::ns6__CertRefs, "ns6:CertRefsType"))
				{	soap_flag_ns6__CertRefs1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns6__CompleteCertificateRefsType::ns6__CertRefs))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__CompleteCertificateRefsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__CompleteCertificateRefsType, SOAP_TYPE_ns6__CompleteCertificateRefsType, sizeof(ns6__CompleteCertificateRefsType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__CompleteCertificateRefsType * SOAP_FMAC2 SCAP_instantiate_ns6__CompleteCertificateRefsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__CompleteCertificateRefsType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__CompleteCertificateRefsType *p;
	size_t k = sizeof(ns6__CompleteCertificateRefsType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__CompleteCertificateRefsType);
		if (p)
			((ns6__CompleteCertificateRefsType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__CompleteCertificateRefsType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__CompleteCertificateRefsType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__CompleteCertificateRefsType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__CompleteCertificateRefsType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__CompleteCertificateRefsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__CompleteCertificateRefsType(soap, tag ? tag : "ns6:CompleteCertificateRefsType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__CompleteCertificateRefsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__CompleteCertificateRefsType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__CompleteCertificateRefsType * SOAP_FMAC4 soap_get_ns6__CompleteCertificateRefsType(struct soap *soap, ns6__CompleteCertificateRefsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__CompleteCertificateRefsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__SignatureTimeStampType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__SignatureTimeStampType::ns5__CanonicalizationMethod = NULL;
	soap_default_ns6__EncapsulatedTimeStampType(soap, &this->ns6__SignatureTimeStampType::ns6__EncapsulatedTimeStamp);
	/* transient soap skipped */
}

void ns6__SignatureTimeStampType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__CanonicalizationMethodType(soap, &this->ns6__SignatureTimeStampType::ns5__CanonicalizationMethod);
	soap_serialize_ns6__EncapsulatedTimeStampType(soap, &this->ns6__SignatureTimeStampType::ns6__EncapsulatedTimeStamp);
#endif
}

int ns6__SignatureTimeStampType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__SignatureTimeStampType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__SignatureTimeStampType(struct soap *soap, const char *tag, int id, const ns6__SignatureTimeStampType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__SignatureTimeStampType), type))
		return soap->error;
	if (!a->ns6__SignatureTimeStampType::ns5__CanonicalizationMethod)
	{	if (soap_element_empty(soap, "ns5:CanonicalizationMethod"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__CanonicalizationMethodType(soap, "ns5:CanonicalizationMethod", -1, &a->ns6__SignatureTimeStampType::ns5__CanonicalizationMethod, ""))
		return soap->error;
	if (soap_out_ns6__EncapsulatedTimeStampType(soap, "ns6:EncapsulatedTimeStamp", -1, &a->ns6__SignatureTimeStampType::ns6__EncapsulatedTimeStamp, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__SignatureTimeStampType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__SignatureTimeStampType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__SignatureTimeStampType * SOAP_FMAC4 soap_in_ns6__SignatureTimeStampType(struct soap *soap, const char *tag, ns6__SignatureTimeStampType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__SignatureTimeStampType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__SignatureTimeStampType, sizeof(ns6__SignatureTimeStampType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__SignatureTimeStampType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__SignatureTimeStampType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ns5__CanonicalizationMethod1 = 1;
	size_t soap_flag_ns6__EncapsulatedTimeStamp1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__CanonicalizationMethod1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__CanonicalizationMethodType(soap, "ns5:CanonicalizationMethod", &a->ns6__SignatureTimeStampType::ns5__CanonicalizationMethod, "ns5:CanonicalizationMethodType"))
				{	soap_flag_ns5__CanonicalizationMethod1--;
					continue;
				}
			}
			if (soap_flag_ns6__EncapsulatedTimeStamp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns6__EncapsulatedTimeStampType(soap, "ns6:EncapsulatedTimeStamp", &a->ns6__SignatureTimeStampType::ns6__EncapsulatedTimeStamp, "ns6:EncapsulatedTimeStampType"))
				{	soap_flag_ns6__EncapsulatedTimeStamp1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns6__SignatureTimeStampType::ns5__CanonicalizationMethod || soap_flag_ns6__EncapsulatedTimeStamp1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__SignatureTimeStampType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__SignatureTimeStampType, SOAP_TYPE_ns6__SignatureTimeStampType, sizeof(ns6__SignatureTimeStampType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__SignatureTimeStampType * SOAP_FMAC2 SCAP_instantiate_ns6__SignatureTimeStampType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__SignatureTimeStampType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__SignatureTimeStampType *p;
	size_t k = sizeof(ns6__SignatureTimeStampType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__SignatureTimeStampType);
		if (p)
			((ns6__SignatureTimeStampType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__SignatureTimeStampType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__SignatureTimeStampType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__SignatureTimeStampType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__SignatureTimeStampType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__SignatureTimeStampType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__SignatureTimeStampType(soap, tag ? tag : "ns6:SignatureTimeStampType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__SignatureTimeStampType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__SignatureTimeStampType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__SignatureTimeStampType * SOAP_FMAC4 soap_get_ns6__SignatureTimeStampType(struct soap *soap, ns6__SignatureTimeStampType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__SignatureTimeStampType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__CounterSignatureType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__CounterSignatureType::ns5__Signature = NULL;
	/* transient soap skipped */
}

void ns6__CounterSignatureType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__SignatureType(soap, &this->ns6__CounterSignatureType::ns5__Signature);
#endif
}

int ns6__CounterSignatureType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__CounterSignatureType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__CounterSignatureType(struct soap *soap, const char *tag, int id, const ns6__CounterSignatureType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__CounterSignatureType), type))
		return soap->error;
	if (!a->ns6__CounterSignatureType::ns5__Signature)
	{	if (soap_element_empty(soap, "ns5:Signature"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__SignatureType(soap, "ns5:Signature", -1, &a->ns6__CounterSignatureType::ns5__Signature, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__CounterSignatureType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__CounterSignatureType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__CounterSignatureType * SOAP_FMAC4 soap_in_ns6__CounterSignatureType(struct soap *soap, const char *tag, ns6__CounterSignatureType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__CounterSignatureType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__CounterSignatureType, sizeof(ns6__CounterSignatureType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__CounterSignatureType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__CounterSignatureType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ns5__Signature1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__Signature1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__SignatureType(soap, "ns5:Signature", &a->ns6__CounterSignatureType::ns5__Signature, "ns5:SignatureType"))
				{	soap_flag_ns5__Signature1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns6__CounterSignatureType::ns5__Signature))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__CounterSignatureType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__CounterSignatureType, SOAP_TYPE_ns6__CounterSignatureType, sizeof(ns6__CounterSignatureType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__CounterSignatureType * SOAP_FMAC2 SCAP_instantiate_ns6__CounterSignatureType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__CounterSignatureType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__CounterSignatureType *p;
	size_t k = sizeof(ns6__CounterSignatureType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__CounterSignatureType);
		if (p)
			((ns6__CounterSignatureType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__CounterSignatureType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__CounterSignatureType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__CounterSignatureType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__CounterSignatureType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__CounterSignatureType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__CounterSignatureType(soap, tag ? tag : "ns6:CounterSignatureType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__CounterSignatureType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__CounterSignatureType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__CounterSignatureType * SOAP_FMAC4 soap_get_ns6__CounterSignatureType(struct soap *soap, ns6__CounterSignatureType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__CounterSignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__UnsignedSignaturePropertiesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__UnsignedSignaturePropertiesType::ns6__CounterSignature = NULL;
	this->ns6__UnsignedSignaturePropertiesType::ns6__SignatureTimeStamp = NULL;
	this->ns6__UnsignedSignaturePropertiesType::ns6__CompleteCertificateRefs = NULL;
	this->ns6__UnsignedSignaturePropertiesType::ns6__CompleteRevocationRefs = NULL;
	this->ns6__UnsignedSignaturePropertiesType::ns6__SigAndRefsTimeStamp = NULL;
	this->ns6__UnsignedSignaturePropertiesType::ns6__CertificateValues = NULL;
	this->ns6__UnsignedSignaturePropertiesType::ns6__RevocationValues = NULL;
	this->ns6__UnsignedSignaturePropertiesType::ns6__ArchiveTimeStamp = NULL;
	/* transient soap skipped */
}

void ns6__UnsignedSignaturePropertiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons6__CounterSignatureType(soap, &this->ns6__UnsignedSignaturePropertiesType::ns6__CounterSignature);
	soap_serialize_PointerTons6__SignatureTimeStampType(soap, &this->ns6__UnsignedSignaturePropertiesType::ns6__SignatureTimeStamp);
	soap_serialize_PointerTons6__CompleteCertificateRefsType(soap, &this->ns6__UnsignedSignaturePropertiesType::ns6__CompleteCertificateRefs);
	soap_serialize_PointerTons6__CompleteRevocationRefsType(soap, &this->ns6__UnsignedSignaturePropertiesType::ns6__CompleteRevocationRefs);
	soap_serialize_PointerTons6__SigAndRefsTimeStampType(soap, &this->ns6__UnsignedSignaturePropertiesType::ns6__SigAndRefsTimeStamp);
	soap_serialize_PointerTons6__CertificateValuesType(soap, &this->ns6__UnsignedSignaturePropertiesType::ns6__CertificateValues);
	soap_serialize_PointerTons6__RevocationValuesType(soap, &this->ns6__UnsignedSignaturePropertiesType::ns6__RevocationValues);
	soap_serialize_PointerTons6__ArchiveTimeStampType(soap, &this->ns6__UnsignedSignaturePropertiesType::ns6__ArchiveTimeStamp);
#endif
}

int ns6__UnsignedSignaturePropertiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__UnsignedSignaturePropertiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__UnsignedSignaturePropertiesType(struct soap *soap, const char *tag, int id, const ns6__UnsignedSignaturePropertiesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__UnsignedSignaturePropertiesType), type))
		return soap->error;
	if (soap_out_PointerTons6__CounterSignatureType(soap, "ns6:CounterSignature", -1, &a->ns6__UnsignedSignaturePropertiesType::ns6__CounterSignature, ""))
		return soap->error;
	if (!a->ns6__UnsignedSignaturePropertiesType::ns6__SignatureTimeStamp)
	{	if (soap_element_empty(soap, "ns6:SignatureTimeStamp"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__SignatureTimeStampType(soap, "ns6:SignatureTimeStamp", -1, &a->ns6__UnsignedSignaturePropertiesType::ns6__SignatureTimeStamp, ""))
		return soap->error;
	if (!a->ns6__UnsignedSignaturePropertiesType::ns6__CompleteCertificateRefs)
	{	if (soap_element_empty(soap, "ns6:CompleteCertificateRefs"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__CompleteCertificateRefsType(soap, "ns6:CompleteCertificateRefs", -1, &a->ns6__UnsignedSignaturePropertiesType::ns6__CompleteCertificateRefs, ""))
		return soap->error;
	if (!a->ns6__UnsignedSignaturePropertiesType::ns6__CompleteRevocationRefs)
	{	if (soap_element_empty(soap, "ns6:CompleteRevocationRefs"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__CompleteRevocationRefsType(soap, "ns6:CompleteRevocationRefs", -1, &a->ns6__UnsignedSignaturePropertiesType::ns6__CompleteRevocationRefs, ""))
		return soap->error;
	if (!a->ns6__UnsignedSignaturePropertiesType::ns6__SigAndRefsTimeStamp)
	{	if (soap_element_empty(soap, "ns6:SigAndRefsTimeStamp"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__SigAndRefsTimeStampType(soap, "ns6:SigAndRefsTimeStamp", -1, &a->ns6__UnsignedSignaturePropertiesType::ns6__SigAndRefsTimeStamp, ""))
		return soap->error;
	if (!a->ns6__UnsignedSignaturePropertiesType::ns6__CertificateValues)
	{	if (soap_element_empty(soap, "ns6:CertificateValues"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__CertificateValuesType(soap, "ns6:CertificateValues", -1, &a->ns6__UnsignedSignaturePropertiesType::ns6__CertificateValues, ""))
		return soap->error;
	if (!a->ns6__UnsignedSignaturePropertiesType::ns6__RevocationValues)
	{	if (soap_element_empty(soap, "ns6:RevocationValues"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__RevocationValuesType(soap, "ns6:RevocationValues", -1, &a->ns6__UnsignedSignaturePropertiesType::ns6__RevocationValues, ""))
		return soap->error;
	if (!a->ns6__UnsignedSignaturePropertiesType::ns6__ArchiveTimeStamp)
	{	if (soap_element_empty(soap, "ns6:ArchiveTimeStamp"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__ArchiveTimeStampType(soap, "ns6:ArchiveTimeStamp", -1, &a->ns6__UnsignedSignaturePropertiesType::ns6__ArchiveTimeStamp, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__UnsignedSignaturePropertiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__UnsignedSignaturePropertiesType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__UnsignedSignaturePropertiesType * SOAP_FMAC4 soap_in_ns6__UnsignedSignaturePropertiesType(struct soap *soap, const char *tag, ns6__UnsignedSignaturePropertiesType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__UnsignedSignaturePropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__UnsignedSignaturePropertiesType, sizeof(ns6__UnsignedSignaturePropertiesType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__UnsignedSignaturePropertiesType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__UnsignedSignaturePropertiesType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ns6__CounterSignature1 = 1;
	size_t soap_flag_ns6__SignatureTimeStamp1 = 1;
	size_t soap_flag_ns6__CompleteCertificateRefs1 = 1;
	size_t soap_flag_ns6__CompleteRevocationRefs1 = 1;
	size_t soap_flag_ns6__SigAndRefsTimeStamp1 = 1;
	size_t soap_flag_ns6__CertificateValues1 = 1;
	size_t soap_flag_ns6__RevocationValues1 = 1;
	size_t soap_flag_ns6__ArchiveTimeStamp1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__CounterSignature1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__CounterSignatureType(soap, "ns6:CounterSignature", &a->ns6__UnsignedSignaturePropertiesType::ns6__CounterSignature, "ns6:CounterSignatureType"))
				{	soap_flag_ns6__CounterSignature1--;
					continue;
				}
			}
			if (soap_flag_ns6__SignatureTimeStamp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__SignatureTimeStampType(soap, "ns6:SignatureTimeStamp", &a->ns6__UnsignedSignaturePropertiesType::ns6__SignatureTimeStamp, "ns6:SignatureTimeStampType"))
				{	soap_flag_ns6__SignatureTimeStamp1--;
					continue;
				}
			}
			if (soap_flag_ns6__CompleteCertificateRefs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__CompleteCertificateRefsType(soap, "ns6:CompleteCertificateRefs", &a->ns6__UnsignedSignaturePropertiesType::ns6__CompleteCertificateRefs, "ns6:CompleteCertificateRefsType"))
				{	soap_flag_ns6__CompleteCertificateRefs1--;
					continue;
				}
			}
			if (soap_flag_ns6__CompleteRevocationRefs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__CompleteRevocationRefsType(soap, "ns6:CompleteRevocationRefs", &a->ns6__UnsignedSignaturePropertiesType::ns6__CompleteRevocationRefs, "ns6:CompleteRevocationRefsType"))
				{	soap_flag_ns6__CompleteRevocationRefs1--;
					continue;
				}
			}
			if (soap_flag_ns6__SigAndRefsTimeStamp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__SigAndRefsTimeStampType(soap, "ns6:SigAndRefsTimeStamp", &a->ns6__UnsignedSignaturePropertiesType::ns6__SigAndRefsTimeStamp, "ns6:SigAndRefsTimeStampType"))
				{	soap_flag_ns6__SigAndRefsTimeStamp1--;
					continue;
				}
			}
			if (soap_flag_ns6__CertificateValues1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__CertificateValuesType(soap, "ns6:CertificateValues", &a->ns6__UnsignedSignaturePropertiesType::ns6__CertificateValues, "ns6:CertificateValuesType"))
				{	soap_flag_ns6__CertificateValues1--;
					continue;
				}
			}
			if (soap_flag_ns6__RevocationValues1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__RevocationValuesType(soap, "ns6:RevocationValues", &a->ns6__UnsignedSignaturePropertiesType::ns6__RevocationValues, "ns6:RevocationValuesType"))
				{	soap_flag_ns6__RevocationValues1--;
					continue;
				}
			}
			if (soap_flag_ns6__ArchiveTimeStamp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__ArchiveTimeStampType(soap, "ns6:ArchiveTimeStamp", &a->ns6__UnsignedSignaturePropertiesType::ns6__ArchiveTimeStamp, "ns6:ArchiveTimeStampType"))
				{	soap_flag_ns6__ArchiveTimeStamp1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns6__UnsignedSignaturePropertiesType::ns6__SignatureTimeStamp || !a->ns6__UnsignedSignaturePropertiesType::ns6__CompleteCertificateRefs || !a->ns6__UnsignedSignaturePropertiesType::ns6__CompleteRevocationRefs || !a->ns6__UnsignedSignaturePropertiesType::ns6__SigAndRefsTimeStamp || !a->ns6__UnsignedSignaturePropertiesType::ns6__CertificateValues || !a->ns6__UnsignedSignaturePropertiesType::ns6__RevocationValues || !a->ns6__UnsignedSignaturePropertiesType::ns6__ArchiveTimeStamp))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__UnsignedSignaturePropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__UnsignedSignaturePropertiesType, SOAP_TYPE_ns6__UnsignedSignaturePropertiesType, sizeof(ns6__UnsignedSignaturePropertiesType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__UnsignedSignaturePropertiesType * SOAP_FMAC2 SCAP_instantiate_ns6__UnsignedSignaturePropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__UnsignedSignaturePropertiesType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__UnsignedSignaturePropertiesType *p;
	size_t k = sizeof(ns6__UnsignedSignaturePropertiesType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__UnsignedSignaturePropertiesType);
		if (p)
			((ns6__UnsignedSignaturePropertiesType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__UnsignedSignaturePropertiesType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__UnsignedSignaturePropertiesType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__UnsignedSignaturePropertiesType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__UnsignedSignaturePropertiesType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__UnsignedSignaturePropertiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__UnsignedSignaturePropertiesType(soap, tag ? tag : "ns6:UnsignedSignaturePropertiesType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__UnsignedSignaturePropertiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__UnsignedSignaturePropertiesType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__UnsignedSignaturePropertiesType * SOAP_FMAC4 soap_get_ns6__UnsignedSignaturePropertiesType(struct soap *soap, ns6__UnsignedSignaturePropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__UnsignedSignaturePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__UnsignedPropertiesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__UnsignedPropertiesType::ns6__UnsignedSignatureProperties = NULL;
	/* transient soap skipped */
}

void ns6__UnsignedPropertiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons6__UnsignedSignaturePropertiesType(soap, &this->ns6__UnsignedPropertiesType::ns6__UnsignedSignatureProperties);
#endif
}

int ns6__UnsignedPropertiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__UnsignedPropertiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__UnsignedPropertiesType(struct soap *soap, const char *tag, int id, const ns6__UnsignedPropertiesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__UnsignedPropertiesType), type))
		return soap->error;
	if (!a->ns6__UnsignedPropertiesType::ns6__UnsignedSignatureProperties)
	{	if (soap_element_empty(soap, "ns6:UnsignedSignatureProperties"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__UnsignedSignaturePropertiesType(soap, "ns6:UnsignedSignatureProperties", -1, &a->ns6__UnsignedPropertiesType::ns6__UnsignedSignatureProperties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__UnsignedPropertiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__UnsignedPropertiesType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__UnsignedPropertiesType * SOAP_FMAC4 soap_in_ns6__UnsignedPropertiesType(struct soap *soap, const char *tag, ns6__UnsignedPropertiesType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__UnsignedPropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__UnsignedPropertiesType, sizeof(ns6__UnsignedPropertiesType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__UnsignedPropertiesType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__UnsignedPropertiesType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ns6__UnsignedSignatureProperties1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__UnsignedSignatureProperties1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__UnsignedSignaturePropertiesType(soap, "ns6:UnsignedSignatureProperties", &a->ns6__UnsignedPropertiesType::ns6__UnsignedSignatureProperties, "ns6:UnsignedSignaturePropertiesType"))
				{	soap_flag_ns6__UnsignedSignatureProperties1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns6__UnsignedPropertiesType::ns6__UnsignedSignatureProperties))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__UnsignedPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__UnsignedPropertiesType, SOAP_TYPE_ns6__UnsignedPropertiesType, sizeof(ns6__UnsignedPropertiesType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__UnsignedPropertiesType * SOAP_FMAC2 SCAP_instantiate_ns6__UnsignedPropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__UnsignedPropertiesType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__UnsignedPropertiesType *p;
	size_t k = sizeof(ns6__UnsignedPropertiesType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__UnsignedPropertiesType);
		if (p)
			((ns6__UnsignedPropertiesType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__UnsignedPropertiesType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__UnsignedPropertiesType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__UnsignedPropertiesType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__UnsignedPropertiesType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__UnsignedPropertiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__UnsignedPropertiesType(soap, tag ? tag : "ns6:UnsignedPropertiesType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__UnsignedPropertiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__UnsignedPropertiesType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__UnsignedPropertiesType * SOAP_FMAC4 soap_get_ns6__UnsignedPropertiesType(struct soap *soap, ns6__UnsignedPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__UnsignedPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__ClaimedRoleType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__ClaimedRoleType::ns3__SignatureAttribute = NULL;
	/* transient soap skipped */
}

void ns6__ClaimedRoleType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__SignatureType(soap, &this->ns6__ClaimedRoleType::ns3__SignatureAttribute);
#endif
}

int ns6__ClaimedRoleType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ClaimedRoleType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ClaimedRoleType(struct soap *soap, const char *tag, int id, const ns6__ClaimedRoleType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ClaimedRoleType), type))
		return soap->error;
	if (!a->ns6__ClaimedRoleType::ns3__SignatureAttribute)
	{	if (soap_element_empty(soap, "ns3:SignatureAttribute"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__SignatureType(soap, "ns3:SignatureAttribute", -1, &a->ns6__ClaimedRoleType::ns3__SignatureAttribute, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__ClaimedRoleType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__ClaimedRoleType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ClaimedRoleType * SOAP_FMAC4 soap_in_ns6__ClaimedRoleType(struct soap *soap, const char *tag, ns6__ClaimedRoleType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ClaimedRoleType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ClaimedRoleType, sizeof(ns6__ClaimedRoleType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__ClaimedRoleType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__ClaimedRoleType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ns3__SignatureAttribute1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__SignatureAttribute1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__SignatureType(soap, "ns3:SignatureAttribute", &a->ns6__ClaimedRoleType::ns3__SignatureAttribute, "ns5:SignatureType"))
				{	soap_flag_ns3__SignatureAttribute1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns6__ClaimedRoleType::ns3__SignatureAttribute))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__ClaimedRoleType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ClaimedRoleType, SOAP_TYPE_ns6__ClaimedRoleType, sizeof(ns6__ClaimedRoleType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__ClaimedRoleType * SOAP_FMAC2 SCAP_instantiate_ns6__ClaimedRoleType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__ClaimedRoleType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__ClaimedRoleType *p;
	size_t k = sizeof(ns6__ClaimedRoleType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__ClaimedRoleType);
		if (p)
			((ns6__ClaimedRoleType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__ClaimedRoleType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__ClaimedRoleType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__ClaimedRoleType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__ClaimedRoleType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__ClaimedRoleType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__ClaimedRoleType(soap, tag ? tag : "ns6:ClaimedRoleType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__ClaimedRoleType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ClaimedRoleType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ClaimedRoleType * SOAP_FMAC4 soap_get_ns6__ClaimedRoleType(struct soap *soap, ns6__ClaimedRoleType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ClaimedRoleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__ClaimedRolesListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons6__ClaimedRoleType(soap, &this->ns6__ClaimedRolesListType::ns6__ClaimedRole);
	/* transient soap skipped */
}

void ns6__ClaimedRolesListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons6__ClaimedRoleType(soap, &this->ns6__ClaimedRolesListType::ns6__ClaimedRole);
#endif
}

int ns6__ClaimedRolesListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ClaimedRolesListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ClaimedRolesListType(struct soap *soap, const char *tag, int id, const ns6__ClaimedRolesListType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ClaimedRolesListType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons6__ClaimedRoleType(soap, "ns6:ClaimedRole", -1, &a->ns6__ClaimedRolesListType::ns6__ClaimedRole, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__ClaimedRolesListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__ClaimedRolesListType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ClaimedRolesListType * SOAP_FMAC4 soap_in_ns6__ClaimedRolesListType(struct soap *soap, const char *tag, ns6__ClaimedRolesListType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ClaimedRolesListType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ClaimedRolesListType, sizeof(ns6__ClaimedRolesListType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__ClaimedRolesListType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__ClaimedRolesListType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons6__ClaimedRoleType(soap, "ns6:ClaimedRole", &a->ns6__ClaimedRolesListType::ns6__ClaimedRole, "ns6:ClaimedRoleType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns6__ClaimedRolesListType::ns6__ClaimedRole.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__ClaimedRolesListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ClaimedRolesListType, SOAP_TYPE_ns6__ClaimedRolesListType, sizeof(ns6__ClaimedRolesListType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__ClaimedRolesListType * SOAP_FMAC2 SCAP_instantiate_ns6__ClaimedRolesListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__ClaimedRolesListType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__ClaimedRolesListType *p;
	size_t k = sizeof(ns6__ClaimedRolesListType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__ClaimedRolesListType);
		if (p)
			((ns6__ClaimedRolesListType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__ClaimedRolesListType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__ClaimedRolesListType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__ClaimedRolesListType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__ClaimedRolesListType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__ClaimedRolesListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__ClaimedRolesListType(soap, tag ? tag : "ns6:ClaimedRolesListType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__ClaimedRolesListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ClaimedRolesListType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ClaimedRolesListType * SOAP_FMAC4 soap_get_ns6__ClaimedRolesListType(struct soap *soap, ns6__ClaimedRolesListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ClaimedRolesListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__SignerRoleType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__SignerRoleType::ns6__ClaimedRoles = NULL;
	/* transient soap skipped */
}

void ns6__SignerRoleType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons6__ClaimedRolesListType(soap, &this->ns6__SignerRoleType::ns6__ClaimedRoles);
#endif
}

int ns6__SignerRoleType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__SignerRoleType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__SignerRoleType(struct soap *soap, const char *tag, int id, const ns6__SignerRoleType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__SignerRoleType), type))
		return soap->error;
	if (!a->ns6__SignerRoleType::ns6__ClaimedRoles)
	{	if (soap_element_empty(soap, "ns6:ClaimedRoles"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__ClaimedRolesListType(soap, "ns6:ClaimedRoles", -1, &a->ns6__SignerRoleType::ns6__ClaimedRoles, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__SignerRoleType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__SignerRoleType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__SignerRoleType * SOAP_FMAC4 soap_in_ns6__SignerRoleType(struct soap *soap, const char *tag, ns6__SignerRoleType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__SignerRoleType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__SignerRoleType, sizeof(ns6__SignerRoleType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__SignerRoleType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__SignerRoleType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ns6__ClaimedRoles1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__ClaimedRoles1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__ClaimedRolesListType(soap, "ns6:ClaimedRoles", &a->ns6__SignerRoleType::ns6__ClaimedRoles, "ns6:ClaimedRolesListType"))
				{	soap_flag_ns6__ClaimedRoles1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns6__SignerRoleType::ns6__ClaimedRoles))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__SignerRoleType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__SignerRoleType, SOAP_TYPE_ns6__SignerRoleType, sizeof(ns6__SignerRoleType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__SignerRoleType * SOAP_FMAC2 SCAP_instantiate_ns6__SignerRoleType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__SignerRoleType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__SignerRoleType *p;
	size_t k = sizeof(ns6__SignerRoleType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__SignerRoleType);
		if (p)
			((ns6__SignerRoleType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__SignerRoleType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__SignerRoleType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__SignerRoleType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__SignerRoleType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__SignerRoleType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__SignerRoleType(soap, tag ? tag : "ns6:SignerRoleType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__SignerRoleType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__SignerRoleType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__SignerRoleType * SOAP_FMAC4 soap_get_ns6__SignerRoleType(struct soap *soap, ns6__SignerRoleType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__SignerRoleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__IssuerSerialType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns5__X509IssuerNameType(soap, &this->ns6__IssuerSerialType::ns5__X509IssuerName);
	soap_default_ns5__X509SerialNumberType(soap, &this->ns6__IssuerSerialType::ns5__X509SerialNumber);
	/* transient soap skipped */
}

void ns6__IssuerSerialType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns5__X509IssuerNameType(soap, &this->ns6__IssuerSerialType::ns5__X509IssuerName);
	soap_serialize_ns5__X509SerialNumberType(soap, &this->ns6__IssuerSerialType::ns5__X509SerialNumber);
#endif
}

int ns6__IssuerSerialType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__IssuerSerialType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__IssuerSerialType(struct soap *soap, const char *tag, int id, const ns6__IssuerSerialType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__IssuerSerialType), type))
		return soap->error;
	if (soap_out_ns5__X509IssuerNameType(soap, "ns5:X509IssuerName", -1, &a->ns6__IssuerSerialType::ns5__X509IssuerName, ""))
		return soap->error;
	if (soap_out_ns5__X509SerialNumberType(soap, "ns5:X509SerialNumber", -1, &a->ns6__IssuerSerialType::ns5__X509SerialNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__IssuerSerialType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__IssuerSerialType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__IssuerSerialType * SOAP_FMAC4 soap_in_ns6__IssuerSerialType(struct soap *soap, const char *tag, ns6__IssuerSerialType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__IssuerSerialType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__IssuerSerialType, sizeof(ns6__IssuerSerialType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__IssuerSerialType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__IssuerSerialType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ns5__X509IssuerName1 = 1;
	size_t soap_flag_ns5__X509SerialNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__X509IssuerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns5__X509IssuerNameType(soap, "ns5:X509IssuerName", &a->ns6__IssuerSerialType::ns5__X509IssuerName, "ns5:X509IssuerNameType"))
				{	soap_flag_ns5__X509IssuerName1--;
					continue;
				}
			}
			if (soap_flag_ns5__X509SerialNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns5__X509SerialNumberType(soap, "ns5:X509SerialNumber", &a->ns6__IssuerSerialType::ns5__X509SerialNumber, "ns5:X509SerialNumberType"))
				{	soap_flag_ns5__X509SerialNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns5__X509IssuerName1 > 0 || soap_flag_ns5__X509SerialNumber1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__IssuerSerialType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__IssuerSerialType, SOAP_TYPE_ns6__IssuerSerialType, sizeof(ns6__IssuerSerialType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__IssuerSerialType * SOAP_FMAC2 SCAP_instantiate_ns6__IssuerSerialType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__IssuerSerialType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__IssuerSerialType *p;
	size_t k = sizeof(ns6__IssuerSerialType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__IssuerSerialType);
		if (p)
			((ns6__IssuerSerialType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__IssuerSerialType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__IssuerSerialType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__IssuerSerialType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__IssuerSerialType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__IssuerSerialType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__IssuerSerialType(soap, tag ? tag : "ns6:IssuerSerialType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__IssuerSerialType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__IssuerSerialType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__IssuerSerialType * SOAP_FMAC4 soap_get_ns6__IssuerSerialType(struct soap *soap, ns6__IssuerSerialType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__CertDigestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__CertDigestType::ns5__DigestMethod = NULL;
	this->ns6__CertDigestType::ns5__DigestValue = NULL;
	/* transient soap skipped */
}

void ns6__CertDigestType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__DigestMethodType(soap, &this->ns6__CertDigestType::ns5__DigestMethod);
	soap_serialize_PointerTons5__DigestValueType(soap, &this->ns6__CertDigestType::ns5__DigestValue);
#endif
}

int ns6__CertDigestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__CertDigestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__CertDigestType(struct soap *soap, const char *tag, int id, const ns6__CertDigestType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__CertDigestType), type))
		return soap->error;
	if (!a->ns6__CertDigestType::ns5__DigestMethod)
	{	if (soap_element_empty(soap, "ns5:DigestMethod"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__DigestMethodType(soap, "ns5:DigestMethod", -1, &a->ns6__CertDigestType::ns5__DigestMethod, ""))
		return soap->error;
	if (!a->ns6__CertDigestType::ns5__DigestValue)
	{	if (soap_element_empty(soap, "ns5:DigestValue"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__DigestValueType(soap, "ns5:DigestValue", -1, &a->ns6__CertDigestType::ns5__DigestValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__CertDigestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__CertDigestType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__CertDigestType * SOAP_FMAC4 soap_in_ns6__CertDigestType(struct soap *soap, const char *tag, ns6__CertDigestType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__CertDigestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__CertDigestType, sizeof(ns6__CertDigestType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__CertDigestType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__CertDigestType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ns5__DigestMethod1 = 1;
	size_t soap_flag_ns5__DigestValue1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__DigestMethod1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__DigestMethodType(soap, "ns5:DigestMethod", &a->ns6__CertDigestType::ns5__DigestMethod, "ns5:DigestMethodType"))
				{	soap_flag_ns5__DigestMethod1--;
					continue;
				}
			}
			if (soap_flag_ns5__DigestValue1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__DigestValueType(soap, "ns5:DigestValue", &a->ns6__CertDigestType::ns5__DigestValue, "ns5:DigestValueType"))
				{	soap_flag_ns5__DigestValue1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns6__CertDigestType::ns5__DigestMethod || !a->ns6__CertDigestType::ns5__DigestValue))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__CertDigestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__CertDigestType, SOAP_TYPE_ns6__CertDigestType, sizeof(ns6__CertDigestType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__CertDigestType * SOAP_FMAC2 SCAP_instantiate_ns6__CertDigestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__CertDigestType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__CertDigestType *p;
	size_t k = sizeof(ns6__CertDigestType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__CertDigestType);
		if (p)
			((ns6__CertDigestType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__CertDigestType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__CertDigestType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__CertDigestType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__CertDigestType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__CertDigestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__CertDigestType(soap, tag ? tag : "ns6:CertDigestType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__CertDigestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__CertDigestType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__CertDigestType * SOAP_FMAC4 soap_get_ns6__CertDigestType(struct soap *soap, ns6__CertDigestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__CertDigestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__CertType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__CertType::ns6__CertDigest = NULL;
	this->ns6__CertType::ns6__IssuerSerial = NULL;
	/* transient soap skipped */
}

void ns6__CertType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons6__CertDigestType(soap, &this->ns6__CertType::ns6__CertDigest);
	soap_serialize_PointerTons6__IssuerSerialType(soap, &this->ns6__CertType::ns6__IssuerSerial);
#endif
}

int ns6__CertType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__CertType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__CertType(struct soap *soap, const char *tag, int id, const ns6__CertType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__CertType), type))
		return soap->error;
	if (!a->ns6__CertType::ns6__CertDigest)
	{	if (soap_element_empty(soap, "ns6:CertDigest"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__CertDigestType(soap, "ns6:CertDigest", -1, &a->ns6__CertType::ns6__CertDigest, ""))
		return soap->error;
	if (!a->ns6__CertType::ns6__IssuerSerial)
	{	if (soap_element_empty(soap, "ns6:IssuerSerial"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__IssuerSerialType(soap, "ns6:IssuerSerial", -1, &a->ns6__CertType::ns6__IssuerSerial, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__CertType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__CertType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__CertType * SOAP_FMAC4 soap_in_ns6__CertType(struct soap *soap, const char *tag, ns6__CertType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__CertType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__CertType, sizeof(ns6__CertType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__CertType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__CertType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ns6__CertDigest1 = 1;
	size_t soap_flag_ns6__IssuerSerial1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__CertDigest1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__CertDigestType(soap, "ns6:CertDigest", &a->ns6__CertType::ns6__CertDigest, "ns6:CertDigestType"))
				{	soap_flag_ns6__CertDigest1--;
					continue;
				}
			}
			if (soap_flag_ns6__IssuerSerial1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__IssuerSerialType(soap, "ns6:IssuerSerial", &a->ns6__CertType::ns6__IssuerSerial, "ns6:IssuerSerialType"))
				{	soap_flag_ns6__IssuerSerial1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns6__CertType::ns6__CertDigest || !a->ns6__CertType::ns6__IssuerSerial))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__CertType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__CertType, SOAP_TYPE_ns6__CertType, sizeof(ns6__CertType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__CertType * SOAP_FMAC2 SCAP_instantiate_ns6__CertType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__CertType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__CertType *p;
	size_t k = sizeof(ns6__CertType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__CertType);
		if (p)
			((ns6__CertType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__CertType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__CertType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__CertType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__CertType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__CertType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__CertType(soap, tag ? tag : "ns6:CertType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__CertType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__CertType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__CertType * SOAP_FMAC4 soap_get_ns6__CertType(struct soap *soap, ns6__CertType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__CertType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__SigningCertificateType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__SigningCertificateType::ns6__Cert = NULL;
	/* transient soap skipped */
}

void ns6__SigningCertificateType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons6__CertType(soap, &this->ns6__SigningCertificateType::ns6__Cert);
#endif
}

int ns6__SigningCertificateType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__SigningCertificateType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__SigningCertificateType(struct soap *soap, const char *tag, int id, const ns6__SigningCertificateType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__SigningCertificateType), type))
		return soap->error;
	if (!a->ns6__SigningCertificateType::ns6__Cert)
	{	if (soap_element_empty(soap, "ns6:Cert"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__CertType(soap, "ns6:Cert", -1, &a->ns6__SigningCertificateType::ns6__Cert, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__SigningCertificateType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__SigningCertificateType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__SigningCertificateType * SOAP_FMAC4 soap_in_ns6__SigningCertificateType(struct soap *soap, const char *tag, ns6__SigningCertificateType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__SigningCertificateType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__SigningCertificateType, sizeof(ns6__SigningCertificateType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__SigningCertificateType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__SigningCertificateType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ns6__Cert1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__Cert1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__CertType(soap, "ns6:Cert", &a->ns6__SigningCertificateType::ns6__Cert, "ns6:CertType"))
				{	soap_flag_ns6__Cert1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns6__SigningCertificateType::ns6__Cert))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__SigningCertificateType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__SigningCertificateType, SOAP_TYPE_ns6__SigningCertificateType, sizeof(ns6__SigningCertificateType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__SigningCertificateType * SOAP_FMAC2 SCAP_instantiate_ns6__SigningCertificateType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__SigningCertificateType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__SigningCertificateType *p;
	size_t k = sizeof(ns6__SigningCertificateType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__SigningCertificateType);
		if (p)
			((ns6__SigningCertificateType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__SigningCertificateType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__SigningCertificateType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__SigningCertificateType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__SigningCertificateType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__SigningCertificateType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__SigningCertificateType(soap, tag ? tag : "ns6:SigningCertificateType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__SigningCertificateType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__SigningCertificateType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__SigningCertificateType * SOAP_FMAC4 soap_get_ns6__SigningCertificateType(struct soap *soap, ns6__SigningCertificateType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__SigningCertificateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__SignedSignaturePropertiesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns6__SigningTimeType(soap, &this->ns6__SignedSignaturePropertiesType::ns6__SigningTime);
	this->ns6__SignedSignaturePropertiesType::ns6__SigningCertificate = NULL;
	this->ns6__SignedSignaturePropertiesType::ns6__SignerRole = NULL;
	/* transient soap skipped */
}

void ns6__SignedSignaturePropertiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons6__SigningCertificateType(soap, &this->ns6__SignedSignaturePropertiesType::ns6__SigningCertificate);
	soap_serialize_PointerTons6__SignerRoleType(soap, &this->ns6__SignedSignaturePropertiesType::ns6__SignerRole);
#endif
}

int ns6__SignedSignaturePropertiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__SignedSignaturePropertiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__SignedSignaturePropertiesType(struct soap *soap, const char *tag, int id, const ns6__SignedSignaturePropertiesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__SignedSignaturePropertiesType), type))
		return soap->error;
	if (soap_out_ns6__SigningTimeType(soap, "ns6:SigningTime", -1, &a->ns6__SignedSignaturePropertiesType::ns6__SigningTime, ""))
		return soap->error;
	if (!a->ns6__SignedSignaturePropertiesType::ns6__SigningCertificate)
	{	if (soap_element_empty(soap, "ns6:SigningCertificate"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__SigningCertificateType(soap, "ns6:SigningCertificate", -1, &a->ns6__SignedSignaturePropertiesType::ns6__SigningCertificate, ""))
		return soap->error;
	if (soap_out_PointerTons6__SignerRoleType(soap, "ns6:SignerRole", -1, &a->ns6__SignedSignaturePropertiesType::ns6__SignerRole, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__SignedSignaturePropertiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__SignedSignaturePropertiesType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__SignedSignaturePropertiesType * SOAP_FMAC4 soap_in_ns6__SignedSignaturePropertiesType(struct soap *soap, const char *tag, ns6__SignedSignaturePropertiesType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__SignedSignaturePropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__SignedSignaturePropertiesType, sizeof(ns6__SignedSignaturePropertiesType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__SignedSignaturePropertiesType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__SignedSignaturePropertiesType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ns6__SigningTime1 = 1;
	size_t soap_flag_ns6__SigningCertificate1 = 1;
	size_t soap_flag_ns6__SignerRole1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__SigningTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns6__SigningTimeType(soap, "ns6:SigningTime", &a->ns6__SignedSignaturePropertiesType::ns6__SigningTime, "ns6:SigningTimeType"))
				{	soap_flag_ns6__SigningTime1--;
					continue;
				}
			}
			if (soap_flag_ns6__SigningCertificate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__SigningCertificateType(soap, "ns6:SigningCertificate", &a->ns6__SignedSignaturePropertiesType::ns6__SigningCertificate, "ns6:SigningCertificateType"))
				{	soap_flag_ns6__SigningCertificate1--;
					continue;
				}
			}
			if (soap_flag_ns6__SignerRole1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__SignerRoleType(soap, "ns6:SignerRole", &a->ns6__SignedSignaturePropertiesType::ns6__SignerRole, "ns6:SignerRoleType"))
				{	soap_flag_ns6__SignerRole1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__SigningTime1 > 0 || !a->ns6__SignedSignaturePropertiesType::ns6__SigningCertificate))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__SignedSignaturePropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__SignedSignaturePropertiesType, SOAP_TYPE_ns6__SignedSignaturePropertiesType, sizeof(ns6__SignedSignaturePropertiesType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__SignedSignaturePropertiesType * SOAP_FMAC2 SCAP_instantiate_ns6__SignedSignaturePropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__SignedSignaturePropertiesType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__SignedSignaturePropertiesType *p;
	size_t k = sizeof(ns6__SignedSignaturePropertiesType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__SignedSignaturePropertiesType);
		if (p)
			((ns6__SignedSignaturePropertiesType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__SignedSignaturePropertiesType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__SignedSignaturePropertiesType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__SignedSignaturePropertiesType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__SignedSignaturePropertiesType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__SignedSignaturePropertiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__SignedSignaturePropertiesType(soap, tag ? tag : "ns6:SignedSignaturePropertiesType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__SignedSignaturePropertiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__SignedSignaturePropertiesType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__SignedSignaturePropertiesType * SOAP_FMAC4 soap_get_ns6__SignedSignaturePropertiesType(struct soap *soap, ns6__SignedSignaturePropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__SignedSignaturePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__SignedPropertiesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__SignedPropertiesType::ns6__SignedSignatureProperties = NULL;
	soap_default_xsd__ID(soap, &this->ns6__SignedPropertiesType::Id);
	/* transient soap skipped */
}

void ns6__SignedPropertiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons6__SignedSignaturePropertiesType(soap, &this->ns6__SignedPropertiesType::ns6__SignedSignatureProperties);
#endif
}

int ns6__SignedPropertiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__SignedPropertiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__SignedPropertiesType(struct soap *soap, const char *tag, int id, const ns6__SignedPropertiesType *a, const char *type)
{
	soap_set_attr(soap, "Id", soap_xsd__ID2s(soap, ((ns6__SignedPropertiesType*)a)->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__SignedPropertiesType), type))
		return soap->error;
	if (!a->ns6__SignedPropertiesType::ns6__SignedSignatureProperties)
	{	if (soap_element_empty(soap, "ns6:SignedSignatureProperties"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__SignedSignaturePropertiesType(soap, "ns6:SignedSignatureProperties", -1, &a->ns6__SignedPropertiesType::ns6__SignedSignatureProperties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__SignedPropertiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__SignedPropertiesType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__SignedPropertiesType * SOAP_FMAC4 soap_in_ns6__SignedPropertiesType(struct soap *soap, const char *tag, ns6__SignedPropertiesType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__SignedPropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__SignedPropertiesType, sizeof(ns6__SignedPropertiesType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__SignedPropertiesType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__SignedPropertiesType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__ID(soap, soap_attr_value(soap, "Id", 5, 1), &((ns6__SignedPropertiesType*)a)->Id))
		return NULL;
	size_t soap_flag_ns6__SignedSignatureProperties1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__SignedSignatureProperties1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__SignedSignaturePropertiesType(soap, "ns6:SignedSignatureProperties", &a->ns6__SignedPropertiesType::ns6__SignedSignatureProperties, "ns6:SignedSignaturePropertiesType"))
				{	soap_flag_ns6__SignedSignatureProperties1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns6__SignedPropertiesType::ns6__SignedSignatureProperties))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__SignedPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__SignedPropertiesType, SOAP_TYPE_ns6__SignedPropertiesType, sizeof(ns6__SignedPropertiesType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__SignedPropertiesType * SOAP_FMAC2 SCAP_instantiate_ns6__SignedPropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__SignedPropertiesType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__SignedPropertiesType *p;
	size_t k = sizeof(ns6__SignedPropertiesType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__SignedPropertiesType);
		if (p)
			((ns6__SignedPropertiesType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__SignedPropertiesType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__SignedPropertiesType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__SignedPropertiesType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__SignedPropertiesType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__SignedPropertiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__SignedPropertiesType(soap, tag ? tag : "ns6:SignedPropertiesType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__SignedPropertiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__SignedPropertiesType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__SignedPropertiesType * SOAP_FMAC4 soap_get_ns6__SignedPropertiesType(struct soap *soap, ns6__SignedPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__SignedPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns6__QualifyingPropertiesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__QualifyingPropertiesType::ns6__SignedProperties = NULL;
	this->ns6__QualifyingPropertiesType::ns6__UnsignedProperties = NULL;
	soap_default_xsd__anyURI(soap, &this->ns6__QualifyingPropertiesType::Target);
	/* transient soap skipped */
}

void ns6__QualifyingPropertiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons6__SignedPropertiesType(soap, &this->ns6__QualifyingPropertiesType::ns6__SignedProperties);
	soap_serialize_PointerTons6__UnsignedPropertiesType(soap, &this->ns6__QualifyingPropertiesType::ns6__UnsignedProperties);
#endif
}

int ns6__QualifyingPropertiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__QualifyingPropertiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__QualifyingPropertiesType(struct soap *soap, const char *tag, int id, const ns6__QualifyingPropertiesType *a, const char *type)
{
	soap_set_attr(soap, "Target", soap_xsd__anyURI2s(soap, ((ns6__QualifyingPropertiesType*)a)->Target), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__QualifyingPropertiesType), type))
		return soap->error;
	if (!a->ns6__QualifyingPropertiesType::ns6__SignedProperties)
	{	if (soap_element_empty(soap, "ns6:SignedProperties"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__SignedPropertiesType(soap, "ns6:SignedProperties", -1, &a->ns6__QualifyingPropertiesType::ns6__SignedProperties, ""))
		return soap->error;
	if (soap_out_PointerTons6__UnsignedPropertiesType(soap, "ns6:UnsignedProperties", -1, &a->ns6__QualifyingPropertiesType::ns6__UnsignedProperties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__QualifyingPropertiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__QualifyingPropertiesType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__QualifyingPropertiesType * SOAP_FMAC4 soap_in_ns6__QualifyingPropertiesType(struct soap *soap, const char *tag, ns6__QualifyingPropertiesType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__QualifyingPropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__QualifyingPropertiesType, sizeof(ns6__QualifyingPropertiesType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns6__QualifyingPropertiesType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns6__QualifyingPropertiesType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Target", 4, 1), &((ns6__QualifyingPropertiesType*)a)->Target))
		return NULL;
	size_t soap_flag_ns6__SignedProperties1 = 1;
	size_t soap_flag_ns6__UnsignedProperties1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__SignedProperties1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__SignedPropertiesType(soap, "ns6:SignedProperties", &a->ns6__QualifyingPropertiesType::ns6__SignedProperties, "ns6:SignedPropertiesType"))
				{	soap_flag_ns6__SignedProperties1--;
					continue;
				}
			}
			if (soap_flag_ns6__UnsignedProperties1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons6__UnsignedPropertiesType(soap, "ns6:UnsignedProperties", &a->ns6__QualifyingPropertiesType::ns6__UnsignedProperties, "ns6:UnsignedPropertiesType"))
				{	soap_flag_ns6__UnsignedProperties1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns6__QualifyingPropertiesType::ns6__SignedProperties))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns6__QualifyingPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__QualifyingPropertiesType, SOAP_TYPE_ns6__QualifyingPropertiesType, sizeof(ns6__QualifyingPropertiesType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns6__QualifyingPropertiesType * SOAP_FMAC2 SCAP_instantiate_ns6__QualifyingPropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns6__QualifyingPropertiesType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns6__QualifyingPropertiesType *p;
	size_t k = sizeof(ns6__QualifyingPropertiesType);
	if (n < 0)
	{	p = SOAP_NEW(ns6__QualifyingPropertiesType);
		if (p)
			((ns6__QualifyingPropertiesType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns6__QualifyingPropertiesType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns6__QualifyingPropertiesType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns6__QualifyingPropertiesType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns6__QualifyingPropertiesType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns6__QualifyingPropertiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns6__QualifyingPropertiesType(soap, tag ? tag : "ns6:QualifyingPropertiesType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__QualifyingPropertiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__QualifyingPropertiesType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__QualifyingPropertiesType * SOAP_FMAC4 soap_get_ns6__QualifyingPropertiesType(struct soap *soap, ns6__QualifyingPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__QualifyingPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ResponseCodeStatusType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns4__ResponseCodeType(soap, &this->ns3__ResponseCodeStatusType::Code);
	this->ns3__ResponseCodeStatusType::Message = NULL;
	/* transient soap skipped */
}

void ns3__ResponseCodeStatusType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns4__ResponseCodeType(soap, &this->ns3__ResponseCodeStatusType::Code);
	soap_serialize_PointerTons4__ResponseCodeMessage(soap, &this->ns3__ResponseCodeStatusType::Message);
#endif
}

int ns3__ResponseCodeStatusType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ResponseCodeStatusType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ResponseCodeStatusType(struct soap *soap, const char *tag, int id, const ns3__ResponseCodeStatusType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ResponseCodeStatusType), type))
		return soap->error;
	if (soap_out_ns4__ResponseCodeType(soap, "ns3:Code", -1, &a->ns3__ResponseCodeStatusType::Code, ""))
		return soap->error;
	if (soap_out_PointerTons4__ResponseCodeMessage(soap, "ns3:Message", -1, &a->ns3__ResponseCodeStatusType::Message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ResponseCodeStatusType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ResponseCodeStatusType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ResponseCodeStatusType * SOAP_FMAC4 soap_in_ns3__ResponseCodeStatusType(struct soap *soap, const char *tag, ns3__ResponseCodeStatusType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ResponseCodeStatusType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ResponseCodeStatusType, sizeof(ns3__ResponseCodeStatusType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__ResponseCodeStatusType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ResponseCodeStatusType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Code1 = 1;
	size_t soap_flag_Message1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns4__ResponseCodeType(soap, "ns3:Code", &a->ns3__ResponseCodeStatusType::Code, "ns4:ResponseCodeType"))
				{	soap_flag_Code1--;
					continue;
				}
			}
			if (soap_flag_Message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons4__ResponseCodeMessage(soap, "ns3:Message", &a->ns3__ResponseCodeStatusType::Message, "ns4:ResponseCodeMessage"))
				{	soap_flag_Message1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Code1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__ResponseCodeStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ResponseCodeStatusType, SOAP_TYPE_ns3__ResponseCodeStatusType, sizeof(ns3__ResponseCodeStatusType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ResponseCodeStatusType * SOAP_FMAC2 SCAP_instantiate_ns3__ResponseCodeStatusType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns3__ResponseCodeStatusType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ResponseCodeStatusType *p;
	size_t k = sizeof(ns3__ResponseCodeStatusType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__ResponseCodeStatusType);
		if (p)
			((ns3__ResponseCodeStatusType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__ResponseCodeStatusType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns3__ResponseCodeStatusType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ResponseCodeStatusType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__ResponseCodeStatusType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__ResponseCodeStatusType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ResponseCodeStatusType(soap, tag ? tag : "ns3:ResponseCodeStatusType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ResponseCodeStatusType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ResponseCodeStatusType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ResponseCodeStatusType * SOAP_FMAC4 soap_get_ns3__ResponseCodeStatusType(struct soap *soap, ns3__ResponseCodeStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ResponseCodeStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__SubAttributeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns4__AttributeIDType(soap, &this->ns3__SubAttributeType::AttributeID);
	this->ns3__SubAttributeType::Description = NULL;
	this->ns3__SubAttributeType::Value = NULL;
	this->ns3__SubAttributeType::LegalActList = NULL;
	/* transient soap skipped */
}

void ns3__SubAttributeType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns4__AttributeIDType(soap, &this->ns3__SubAttributeType::AttributeID);
	soap_serialize_PointerTons4__DescriptionType(soap, &this->ns3__SubAttributeType::Description);
	soap_serialize_PointerTons4__SubAttributeValueType(soap, &this->ns3__SubAttributeType::Value);
	soap_serialize_PointerTons3__LegalActListType(soap, &this->ns3__SubAttributeType::LegalActList);
#endif
}

int ns3__SubAttributeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__SubAttributeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__SubAttributeType(struct soap *soap, const char *tag, int id, const ns3__SubAttributeType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__SubAttributeType), type))
		return soap->error;
	if (soap_out_ns4__AttributeIDType(soap, "ns3:AttributeID", -1, &a->ns3__SubAttributeType::AttributeID, ""))
		return soap->error;
	if (soap_out_PointerTons4__DescriptionType(soap, "ns3:Description", -1, &a->ns3__SubAttributeType::Description, ""))
		return soap->error;
	if (soap_out_PointerTons4__SubAttributeValueType(soap, "ns3:Value", -1, &a->ns3__SubAttributeType::Value, ""))
		return soap->error;
	if (soap_out_PointerTons3__LegalActListType(soap, "ns3:LegalActList", -1, &a->ns3__SubAttributeType::LegalActList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__SubAttributeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__SubAttributeType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__SubAttributeType * SOAP_FMAC4 soap_in_ns3__SubAttributeType(struct soap *soap, const char *tag, ns3__SubAttributeType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__SubAttributeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__SubAttributeType, sizeof(ns3__SubAttributeType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__SubAttributeType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__SubAttributeType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AttributeID1 = 1;
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_Value1 = 1;
	size_t soap_flag_LegalActList1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AttributeID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns4__AttributeIDType(soap, "ns3:AttributeID", &a->ns3__SubAttributeType::AttributeID, "ns4:AttributeIDType"))
				{	soap_flag_AttributeID1--;
					continue;
				}
			}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons4__DescriptionType(soap, "ns3:Description", &a->ns3__SubAttributeType::Description, "ns4:DescriptionType"))
				{	soap_flag_Description1--;
					continue;
				}
			}
			if (soap_flag_Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons4__SubAttributeValueType(soap, "ns3:Value", &a->ns3__SubAttributeType::Value, "ns4:SubAttributeValueType"))
				{	soap_flag_Value1--;
					continue;
				}
			}
			if (soap_flag_LegalActList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__LegalActListType(soap, "ns3:LegalActList", &a->ns3__SubAttributeType::LegalActList, "ns3:LegalActListType"))
				{	soap_flag_LegalActList1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AttributeID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__SubAttributeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__SubAttributeType, SOAP_TYPE_ns3__SubAttributeType, sizeof(ns3__SubAttributeType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__SubAttributeType * SOAP_FMAC2 SCAP_instantiate_ns3__SubAttributeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns3__SubAttributeType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__SubAttributeType *p;
	size_t k = sizeof(ns3__SubAttributeType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__SubAttributeType);
		if (p)
			((ns3__SubAttributeType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__SubAttributeType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns3__SubAttributeType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__SubAttributeType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__SubAttributeType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__SubAttributeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__SubAttributeType(soap, tag ? tag : "ns3:SubAttributeType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__SubAttributeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__SubAttributeType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__SubAttributeType * SOAP_FMAC4 soap_get_ns3__SubAttributeType(struct soap *soap, ns3__SubAttributeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__SubAttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__SubAttributeListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__SubAttributeType(soap, &this->ns3__SubAttributeListType::SubAttribute);
	/* transient soap skipped */
}

void ns3__SubAttributeListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__SubAttributeType(soap, &this->ns3__SubAttributeListType::SubAttribute);
#endif
}

int ns3__SubAttributeListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__SubAttributeListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__SubAttributeListType(struct soap *soap, const char *tag, int id, const ns3__SubAttributeListType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__SubAttributeListType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__SubAttributeType(soap, "ns3:SubAttribute", -1, &a->ns3__SubAttributeListType::SubAttribute, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__SubAttributeListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__SubAttributeListType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__SubAttributeListType * SOAP_FMAC4 soap_in_ns3__SubAttributeListType(struct soap *soap, const char *tag, ns3__SubAttributeListType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__SubAttributeListType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__SubAttributeListType, sizeof(ns3__SubAttributeListType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__SubAttributeListType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__SubAttributeListType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__SubAttributeType(soap, "ns3:SubAttribute", &a->ns3__SubAttributeListType::SubAttribute, "ns3:SubAttributeType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns3__SubAttributeListType::SubAttribute.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__SubAttributeListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__SubAttributeListType, SOAP_TYPE_ns3__SubAttributeListType, sizeof(ns3__SubAttributeListType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__SubAttributeListType * SOAP_FMAC2 SCAP_instantiate_ns3__SubAttributeListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns3__SubAttributeListType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__SubAttributeListType *p;
	size_t k = sizeof(ns3__SubAttributeListType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__SubAttributeListType);
		if (p)
			((ns3__SubAttributeListType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__SubAttributeListType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns3__SubAttributeListType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__SubAttributeListType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__SubAttributeListType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__SubAttributeListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__SubAttributeListType(soap, tag ? tag : "ns3:SubAttributeListType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__SubAttributeListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__SubAttributeListType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__SubAttributeListType * SOAP_FMAC4 soap_get_ns3__SubAttributeListType(struct soap *soap, ns3__SubAttributeListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__SubAttributeListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__LegalActListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfns4__LegalActType(soap, &this->ns3__LegalActListType::LegalAct);
	/* transient soap skipped */
}

void ns3__LegalActListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfns4__LegalActType(soap, &this->ns3__LegalActListType::LegalAct);
#endif
}

int ns3__LegalActListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__LegalActListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__LegalActListType(struct soap *soap, const char *tag, int id, const ns3__LegalActListType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__LegalActListType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns4__LegalActType(soap, "ns3:LegalAct", -1, &a->ns3__LegalActListType::LegalAct, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__LegalActListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__LegalActListType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__LegalActListType * SOAP_FMAC4 soap_in_ns3__LegalActListType(struct soap *soap, const char *tag, ns3__LegalActListType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__LegalActListType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__LegalActListType, sizeof(ns3__LegalActListType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__LegalActListType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__LegalActListType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns4__LegalActType(soap, "ns3:LegalAct", &a->ns3__LegalActListType::LegalAct, "ns4:LegalActType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns3__LegalActListType::LegalAct.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__LegalActListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__LegalActListType, SOAP_TYPE_ns3__LegalActListType, sizeof(ns3__LegalActListType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__LegalActListType * SOAP_FMAC2 SCAP_instantiate_ns3__LegalActListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns3__LegalActListType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__LegalActListType *p;
	size_t k = sizeof(ns3__LegalActListType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__LegalActListType);
		if (p)
			((ns3__LegalActListType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__LegalActListType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns3__LegalActListType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__LegalActListType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__LegalActListType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__LegalActListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__LegalActListType(soap, tag ? tag : "ns3:LegalActListType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__LegalActListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__LegalActListType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__LegalActListType * SOAP_FMAC4 soap_get_ns3__LegalActListType(struct soap *soap, ns3__LegalActListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__LegalActListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__MainAttributeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns4__AttributeIDType(soap, &this->ns3__MainAttributeType::AttributeID);
	this->ns3__MainAttributeType::Description = NULL;
	this->ns3__MainAttributeType::LegalActList = NULL;
	this->ns3__MainAttributeType::SubAttributeList = NULL;
	/* transient soap skipped */
}

void ns3__MainAttributeType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns4__AttributeIDType(soap, &this->ns3__MainAttributeType::AttributeID);
	soap_serialize_PointerTons4__DescriptionType(soap, &this->ns3__MainAttributeType::Description);
	soap_serialize_PointerTons3__LegalActListType(soap, &this->ns3__MainAttributeType::LegalActList);
	soap_serialize_PointerTons3__SubAttributeListType(soap, &this->ns3__MainAttributeType::SubAttributeList);
#endif
}

int ns3__MainAttributeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__MainAttributeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__MainAttributeType(struct soap *soap, const char *tag, int id, const ns3__MainAttributeType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__MainAttributeType), type))
		return soap->error;
	if (soap_out_ns4__AttributeIDType(soap, "ns3:AttributeID", -1, &a->ns3__MainAttributeType::AttributeID, ""))
		return soap->error;
	if (soap_out_PointerTons4__DescriptionType(soap, "ns3:Description", -1, &a->ns3__MainAttributeType::Description, ""))
		return soap->error;
	if (soap_out_PointerTons3__LegalActListType(soap, "ns3:LegalActList", -1, &a->ns3__MainAttributeType::LegalActList, ""))
		return soap->error;
	if (soap_out_PointerTons3__SubAttributeListType(soap, "ns3:SubAttributeList", -1, &a->ns3__MainAttributeType::SubAttributeList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__MainAttributeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__MainAttributeType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__MainAttributeType * SOAP_FMAC4 soap_in_ns3__MainAttributeType(struct soap *soap, const char *tag, ns3__MainAttributeType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__MainAttributeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__MainAttributeType, sizeof(ns3__MainAttributeType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__MainAttributeType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__MainAttributeType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AttributeID1 = 1;
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_LegalActList1 = 1;
	size_t soap_flag_SubAttributeList1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AttributeID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns4__AttributeIDType(soap, "ns3:AttributeID", &a->ns3__MainAttributeType::AttributeID, "ns4:AttributeIDType"))
				{	soap_flag_AttributeID1--;
					continue;
				}
			}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons4__DescriptionType(soap, "ns3:Description", &a->ns3__MainAttributeType::Description, "ns4:DescriptionType"))
				{	soap_flag_Description1--;
					continue;
				}
			}
			if (soap_flag_LegalActList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__LegalActListType(soap, "ns3:LegalActList", &a->ns3__MainAttributeType::LegalActList, "ns3:LegalActListType"))
				{	soap_flag_LegalActList1--;
					continue;
				}
			}
			if (soap_flag_SubAttributeList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__SubAttributeListType(soap, "ns3:SubAttributeList", &a->ns3__MainAttributeType::SubAttributeList, "ns3:SubAttributeListType"))
				{	soap_flag_SubAttributeList1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AttributeID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__MainAttributeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__MainAttributeType, SOAP_TYPE_ns3__MainAttributeType, sizeof(ns3__MainAttributeType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__MainAttributeType * SOAP_FMAC2 SCAP_instantiate_ns3__MainAttributeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns3__MainAttributeType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__MainAttributeType *p;
	size_t k = sizeof(ns3__MainAttributeType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__MainAttributeType);
		if (p)
			((ns3__MainAttributeType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__MainAttributeType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns3__MainAttributeType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__MainAttributeType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__MainAttributeType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__MainAttributeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__MainAttributeType(soap, tag ? tag : "ns3:MainAttributeType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__MainAttributeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__MainAttributeType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__MainAttributeType * SOAP_FMAC4 soap_get_ns3__MainAttributeType(struct soap *soap, ns3__MainAttributeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__MainAttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ExtraIDType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns4__NameType(soap, &this->ns3__ExtraIDType::Name);
	soap_default_ns4__ExtraIDValueType(soap, &this->ns3__ExtraIDType::Value);
	/* transient soap skipped */
}

void ns3__ExtraIDType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns4__NameType(soap, &this->ns3__ExtraIDType::Name);
	soap_serialize_ns4__ExtraIDValueType(soap, &this->ns3__ExtraIDType::Value);
#endif
}

int ns3__ExtraIDType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ExtraIDType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ExtraIDType(struct soap *soap, const char *tag, int id, const ns3__ExtraIDType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ExtraIDType), type))
		return soap->error;
	if (soap_out_ns4__NameType(soap, "ns3:Name", -1, &a->ns3__ExtraIDType::Name, ""))
		return soap->error;
	if (soap_out_ns4__ExtraIDValueType(soap, "ns3:Value", -1, &a->ns3__ExtraIDType::Value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ExtraIDType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ExtraIDType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ExtraIDType * SOAP_FMAC4 soap_in_ns3__ExtraIDType(struct soap *soap, const char *tag, ns3__ExtraIDType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ExtraIDType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ExtraIDType, sizeof(ns3__ExtraIDType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__ExtraIDType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ExtraIDType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Value1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns4__NameType(soap, "ns3:Name", &a->ns3__ExtraIDType::Name, "ns4:NameType"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns4__ExtraIDValueType(soap, "ns3:Value", &a->ns3__ExtraIDType::Value, "ns4:ExtraIDValueType"))
				{	soap_flag_Value1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0 || soap_flag_Value1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__ExtraIDType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ExtraIDType, SOAP_TYPE_ns3__ExtraIDType, sizeof(ns3__ExtraIDType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ExtraIDType * SOAP_FMAC2 SCAP_instantiate_ns3__ExtraIDType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns3__ExtraIDType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ExtraIDType *p;
	size_t k = sizeof(ns3__ExtraIDType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__ExtraIDType);
		if (p)
			((ns3__ExtraIDType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__ExtraIDType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns3__ExtraIDType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ExtraIDType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__ExtraIDType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__ExtraIDType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ExtraIDType(soap, tag ? tag : "ns3:ExtraIDType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ExtraIDType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ExtraIDType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ExtraIDType * SOAP_FMAC4 soap_get_ns3__ExtraIDType(struct soap *soap, ns3__ExtraIDType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ExtraIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ExtraIDListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__ExtraIDType(soap, &this->ns3__ExtraIDListType::ExtraID);
	/* transient soap skipped */
}

void ns3__ExtraIDListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__ExtraIDType(soap, &this->ns3__ExtraIDListType::ExtraID);
#endif
}

int ns3__ExtraIDListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ExtraIDListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ExtraIDListType(struct soap *soap, const char *tag, int id, const ns3__ExtraIDListType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ExtraIDListType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__ExtraIDType(soap, "ns3:ExtraID", -1, &a->ns3__ExtraIDListType::ExtraID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ExtraIDListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ExtraIDListType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ExtraIDListType * SOAP_FMAC4 soap_in_ns3__ExtraIDListType(struct soap *soap, const char *tag, ns3__ExtraIDListType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ExtraIDListType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ExtraIDListType, sizeof(ns3__ExtraIDListType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__ExtraIDListType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ExtraIDListType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__ExtraIDType(soap, "ns3:ExtraID", &a->ns3__ExtraIDListType::ExtraID, "ns3:ExtraIDType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns3__ExtraIDListType::ExtraID.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__ExtraIDListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ExtraIDListType, SOAP_TYPE_ns3__ExtraIDListType, sizeof(ns3__ExtraIDListType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ExtraIDListType * SOAP_FMAC2 SCAP_instantiate_ns3__ExtraIDListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns3__ExtraIDListType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ExtraIDListType *p;
	size_t k = sizeof(ns3__ExtraIDListType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__ExtraIDListType);
		if (p)
			((ns3__ExtraIDListType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__ExtraIDListType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns3__ExtraIDListType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ExtraIDListType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__ExtraIDListType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__ExtraIDListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ExtraIDListType(soap, tag ? tag : "ns3:ExtraIDListType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ExtraIDListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ExtraIDListType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ExtraIDListType * SOAP_FMAC4 soap_get_ns3__ExtraIDListType(struct soap *soap, ns3__ExtraIDListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ExtraIDListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__PersonalDataType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns4__NameType(soap, &this->ns3__PersonalDataType::Name);
	soap_default_ns4__NICType(soap, &this->ns3__PersonalDataType::NIC);
	this->ns3__PersonalDataType::ExtraIDList = NULL;
	/* transient soap skipped */
}

void ns3__PersonalDataType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns4__NameType(soap, &this->ns3__PersonalDataType::Name);
	soap_serialize_ns4__NICType(soap, &this->ns3__PersonalDataType::NIC);
	soap_serialize_PointerTons3__ExtraIDListType(soap, &this->ns3__PersonalDataType::ExtraIDList);
#endif
}

int ns3__PersonalDataType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__PersonalDataType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__PersonalDataType(struct soap *soap, const char *tag, int id, const ns3__PersonalDataType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__PersonalDataType), type))
		return soap->error;
	if (soap_out_ns4__NameType(soap, "ns3:Name", -1, &a->ns3__PersonalDataType::Name, ""))
		return soap->error;
	if (soap_out_ns4__NICType(soap, "ns3:NIC", -1, &a->ns3__PersonalDataType::NIC, ""))
		return soap->error;
	if (soap_out_PointerTons3__ExtraIDListType(soap, "ns3:ExtraIDList", -1, &a->ns3__PersonalDataType::ExtraIDList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__PersonalDataType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__PersonalDataType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__PersonalDataType * SOAP_FMAC4 soap_in_ns3__PersonalDataType(struct soap *soap, const char *tag, ns3__PersonalDataType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__PersonalDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__PersonalDataType, sizeof(ns3__PersonalDataType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__PersonalDataType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__PersonalDataType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_NIC1 = 1;
	size_t soap_flag_ExtraIDList1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns4__NameType(soap, "ns3:Name", &a->ns3__PersonalDataType::Name, "ns4:NameType"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_NIC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns4__NICType(soap, "ns3:NIC", &a->ns3__PersonalDataType::NIC, "ns4:NICType"))
				{	soap_flag_NIC1--;
					continue;
				}
			}
			if (soap_flag_ExtraIDList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ExtraIDListType(soap, "ns3:ExtraIDList", &a->ns3__PersonalDataType::ExtraIDList, "ns3:ExtraIDListType"))
				{	soap_flag_ExtraIDList1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0 || soap_flag_NIC1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__PersonalDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__PersonalDataType, SOAP_TYPE_ns3__PersonalDataType, sizeof(ns3__PersonalDataType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__PersonalDataType * SOAP_FMAC2 SCAP_instantiate_ns3__PersonalDataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns3__PersonalDataType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__PersonalDataType *p;
	size_t k = sizeof(ns3__PersonalDataType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__PersonalDataType);
		if (p)
			((ns3__PersonalDataType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__PersonalDataType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns3__PersonalDataType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__PersonalDataType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__PersonalDataType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__PersonalDataType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__PersonalDataType(soap, tag ? tag : "ns3:PersonalDataType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__PersonalDataType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__PersonalDataType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__PersonalDataType * SOAP_FMAC4 soap_get_ns3__PersonalDataType(struct soap *soap, ns3__PersonalDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__PersonalDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__AttributeSupplierType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->ns3__AttributeSupplierType::Id);
	soap_default_ns4__NameType(soap, &this->ns3__AttributeSupplierType::Name);
	/* transient soap skipped */
}

void ns3__AttributeSupplierType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns3__AttributeSupplierType::Id, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->ns3__AttributeSupplierType::Id);
	soap_serialize_ns4__NameType(soap, &this->ns3__AttributeSupplierType::Name);
#endif
}

int ns3__AttributeSupplierType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__AttributeSupplierType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__AttributeSupplierType(struct soap *soap, const char *tag, int id, const ns3__AttributeSupplierType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__AttributeSupplierType), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "ns3:Id", -1, &a->ns3__AttributeSupplierType::Id, ""))
		return soap->error;
	if (soap_out_ns4__NameType(soap, "ns3:Name", -1, &a->ns3__AttributeSupplierType::Name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__AttributeSupplierType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__AttributeSupplierType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__AttributeSupplierType * SOAP_FMAC4 soap_in_ns3__AttributeSupplierType(struct soap *soap, const char *tag, ns3__AttributeSupplierType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__AttributeSupplierType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__AttributeSupplierType, sizeof(ns3__AttributeSupplierType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__AttributeSupplierType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__AttributeSupplierType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Name1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "ns3:Id", &a->ns3__AttributeSupplierType::Id, "xsd:anyURI"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns4__NameType(soap, "ns3:Name", &a->ns3__AttributeSupplierType::Name, "ns4:NameType"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_Name1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__AttributeSupplierType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__AttributeSupplierType, SOAP_TYPE_ns3__AttributeSupplierType, sizeof(ns3__AttributeSupplierType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__AttributeSupplierType * SOAP_FMAC2 SCAP_instantiate_ns3__AttributeSupplierType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns3__AttributeSupplierType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__AttributeSupplierType *p;
	size_t k = sizeof(ns3__AttributeSupplierType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__AttributeSupplierType);
		if (p)
			((ns3__AttributeSupplierType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__AttributeSupplierType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns3__AttributeSupplierType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__AttributeSupplierType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__AttributeSupplierType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__AttributeSupplierType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__AttributeSupplierType(soap, tag ? tag : "ns3:AttributeSupplierType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__AttributeSupplierType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__AttributeSupplierType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__AttributeSupplierType * SOAP_FMAC4 soap_get_ns3__AttributeSupplierType(struct soap *soap, ns3__AttributeSupplierType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__AttributeSupplierType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__AttributeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__AttributeType::AttributeSupplier = NULL;
	soap_default_ns4__DateType(soap, &this->ns3__AttributeType::Date);
	soap_default_ns4__ValidityType(soap, &this->ns3__AttributeType::Validity);
	this->ns3__AttributeType::PersonalData = NULL;
	this->ns3__AttributeType::MainAttribute = NULL;
	/* transient soap skipped */
}

void ns3__AttributeType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__AttributeSupplierType(soap, &this->ns3__AttributeType::AttributeSupplier);
	soap_serialize_ns4__DateType(soap, &this->ns3__AttributeType::Date);
	soap_serialize_ns4__ValidityType(soap, &this->ns3__AttributeType::Validity);
	soap_serialize_PointerTons3__PersonalDataType(soap, &this->ns3__AttributeType::PersonalData);
	soap_serialize_PointerTons3__MainAttributeType(soap, &this->ns3__AttributeType::MainAttribute);
#endif
}

int ns3__AttributeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__AttributeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__AttributeType(struct soap *soap, const char *tag, int id, const ns3__AttributeType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__AttributeType), type))
		return soap->error;
	if (!a->ns3__AttributeType::AttributeSupplier)
	{	if (soap_element_empty(soap, "ns3:AttributeSupplier"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__AttributeSupplierType(soap, "ns3:AttributeSupplier", -1, &a->ns3__AttributeType::AttributeSupplier, ""))
		return soap->error;
	if (soap_out_ns4__DateType(soap, "ns3:Date", -1, &a->ns3__AttributeType::Date, ""))
		return soap->error;
	if (soap_out_ns4__ValidityType(soap, "ns3:Validity", -1, &a->ns3__AttributeType::Validity, ""))
		return soap->error;
	if (!a->ns3__AttributeType::PersonalData)
	{	if (soap_element_empty(soap, "ns3:PersonalData"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__PersonalDataType(soap, "ns3:PersonalData", -1, &a->ns3__AttributeType::PersonalData, ""))
		return soap->error;
	if (!a->ns3__AttributeType::MainAttribute)
	{	if (soap_element_empty(soap, "ns3:MainAttribute"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__MainAttributeType(soap, "ns3:MainAttribute", -1, &a->ns3__AttributeType::MainAttribute, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__AttributeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__AttributeType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__AttributeType * SOAP_FMAC4 soap_in_ns3__AttributeType(struct soap *soap, const char *tag, ns3__AttributeType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__AttributeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__AttributeType, sizeof(ns3__AttributeType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__AttributeType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__AttributeType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AttributeSupplier1 = 1;
	size_t soap_flag_Date1 = 1;
	size_t soap_flag_Validity1 = 1;
	size_t soap_flag_PersonalData1 = 1;
	size_t soap_flag_MainAttribute1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AttributeSupplier1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__AttributeSupplierType(soap, "ns3:AttributeSupplier", &a->ns3__AttributeType::AttributeSupplier, "ns3:AttributeSupplierType"))
				{	soap_flag_AttributeSupplier1--;
					continue;
				}
			}
			if (soap_flag_Date1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns4__DateType(soap, "ns3:Date", &a->ns3__AttributeType::Date, "ns4:DateType"))
				{	soap_flag_Date1--;
					continue;
				}
			}
			if (soap_flag_Validity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns4__ValidityType(soap, "ns3:Validity", &a->ns3__AttributeType::Validity, "ns4:ValidityType"))
				{	soap_flag_Validity1--;
					continue;
				}
			}
			if (soap_flag_PersonalData1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__PersonalDataType(soap, "ns3:PersonalData", &a->ns3__AttributeType::PersonalData, "ns3:PersonalDataType"))
				{	soap_flag_PersonalData1--;
					continue;
				}
			}
			if (soap_flag_MainAttribute1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__MainAttributeType(soap, "ns3:MainAttribute", &a->ns3__AttributeType::MainAttribute, "ns3:MainAttributeType"))
				{	soap_flag_MainAttribute1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns3__AttributeType::AttributeSupplier || soap_flag_Date1 > 0 || soap_flag_Validity1 > 0 || !a->ns3__AttributeType::PersonalData || !a->ns3__AttributeType::MainAttribute))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__AttributeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__AttributeType, SOAP_TYPE_ns3__AttributeType, sizeof(ns3__AttributeType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__AttributeType * SOAP_FMAC2 SCAP_instantiate_ns3__AttributeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns3__AttributeType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__AttributeType *p;
	size_t k = sizeof(ns3__AttributeType);
	if (n < 0)
	{	p = SOAP_NEW(ns3__AttributeType);
		if (p)
			((ns3__AttributeType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__AttributeType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns3__AttributeType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__AttributeType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__AttributeType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__AttributeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__AttributeType(soap, tag ? tag : "ns3:AttributeType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__AttributeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__AttributeType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__AttributeType * SOAP_FMAC4 soap_get_ns3__AttributeType(struct soap *soap, ns3__AttributeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__AttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__SignatureValueType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__SignatureValueType::__item.xsd__base64Binary::soap_default(soap);
	soap_default_xsd__ID(soap, &this->ns5__SignatureValueType::Id);
	/* transient soap skipped */
}

void ns5__SignatureValueType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns5__SignatureValueType::__item, SOAP_TYPE_xsd__base64Binary);
	this->ns5__SignatureValueType::__item.soap_serialize(soap);
#endif
}

int ns5__SignatureValueType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__SignatureValueType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__SignatureValueType(struct soap *soap, const char *tag, int id, const ns5__SignatureValueType *a, const char *type)
{
	soap_set_attr(soap, "Id", soap_xsd__ID2s(soap, ((ns5__SignatureValueType*)a)->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return (a->ns5__SignatureValueType::__item).soap_out(soap, tag, id, "");
}

void *ns5__SignatureValueType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__SignatureValueType(soap, tag, this, type);
}

SOAP_FMAC3 ns5__SignatureValueType * SOAP_FMAC4 soap_in_ns5__SignatureValueType(struct soap *soap, const char *tag, ns5__SignatureValueType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns5__SignatureValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__SignatureValueType, sizeof(ns5__SignatureValueType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__SignatureValueType)
		return (ns5__SignatureValueType *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__ID(soap, soap_attr_value(soap, "Id", 5, 1), &((ns5__SignatureValueType*)a)->Id))
		return NULL;
	if (!(a->ns5__SignatureValueType::__item).soap_in(soap, tag, "ns5:SignatureValueType"))
		return NULL;
	return a;
}

SOAP_FMAC1 ns5__SignatureValueType * SOAP_FMAC2 SCAP_instantiate_ns5__SignatureValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns5__SignatureValueType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__SignatureValueType *p;
	size_t k = sizeof(ns5__SignatureValueType);
	if (n < 0)
	{	p = SOAP_NEW(ns5__SignatureValueType);
		if (p)
			((ns5__SignatureValueType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__SignatureValueType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__SignatureValueType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__SignatureValueType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__SignatureValueType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__SignatureValueType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__SignatureValueType(soap, tag ? tag : "ns5:SignatureValueType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__SignatureValueType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__SignatureValueType(soap, this, tag, type);
}

SOAP_FMAC3 ns5__SignatureValueType * SOAP_FMAC4 soap_get_ns5__SignatureValueType(struct soap *soap, ns5__SignatureValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__SignatureValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__DigestValueType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__DigestValueType::__item.xsd__base64Binary::soap_default(soap);
	this->ns5__DigestValueType::Id = NULL;
	/* transient soap skipped */
}

void ns5__DigestValueType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns5__DigestValueType::__item, SOAP_TYPE_xsd__base64Binary);
	this->ns5__DigestValueType::__item.soap_serialize(soap);
#endif
}

int ns5__DigestValueType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__DigestValueType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__DigestValueType(struct soap *soap, const char *tag, int id, const ns5__DigestValueType *a, const char *type)
{
	if (((ns5__DigestValueType*)a)->Id)
	{	soap_set_attr(soap, "Id", soap_xsd__ID2s(soap, *((ns5__DigestValueType*)a)->Id), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return (a->ns5__DigestValueType::__item).soap_out(soap, tag, id, "");
}

void *ns5__DigestValueType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__DigestValueType(soap, tag, this, type);
}

SOAP_FMAC3 ns5__DigestValueType * SOAP_FMAC4 soap_in_ns5__DigestValueType(struct soap *soap, const char *tag, ns5__DigestValueType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns5__DigestValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__DigestValueType, sizeof(ns5__DigestValueType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__DigestValueType)
		return (ns5__DigestValueType *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "Id", 5, 0);
		if (t)
		{
			if (!(((ns5__DigestValueType*)a)->Id = soap_new_xsd__ID(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__ID(soap, t, ((ns5__DigestValueType*)a)->Id))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!(a->ns5__DigestValueType::__item).soap_in(soap, tag, "ns5:DigestValueType"))
		return NULL;
	return a;
}

SOAP_FMAC1 ns5__DigestValueType * SOAP_FMAC2 SCAP_instantiate_ns5__DigestValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns5__DigestValueType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__DigestValueType *p;
	size_t k = sizeof(ns5__DigestValueType);
	if (n < 0)
	{	p = SOAP_NEW(ns5__DigestValueType);
		if (p)
			((ns5__DigestValueType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__DigestValueType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__DigestValueType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__DigestValueType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__DigestValueType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__DigestValueType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__DigestValueType(soap, tag ? tag : "ns5:DigestValueType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__DigestValueType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__DigestValueType(soap, this, tag, type);
}

SOAP_FMAC3 ns5__DigestValueType * SOAP_FMAC4 soap_get_ns5__DigestValueType(struct soap *soap, ns5__DigestValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__DigestValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__X509CertificateType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__X509CertificateType::__item.xsd__base64Binary::soap_default(soap);
	soap_default_xsd__ID(soap, &this->ns5__X509CertificateType::Id);
	/* transient soap skipped */
}

void ns5__X509CertificateType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns5__X509CertificateType::__item, SOAP_TYPE_xsd__base64Binary);
	this->ns5__X509CertificateType::__item.soap_serialize(soap);
#endif
}

int ns5__X509CertificateType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__X509CertificateType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__X509CertificateType(struct soap *soap, const char *tag, int id, const ns5__X509CertificateType *a, const char *type)
{
	soap_set_attr(soap, "Id", soap_xsd__ID2s(soap, ((ns5__X509CertificateType*)a)->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return (a->ns5__X509CertificateType::__item).soap_out(soap, tag, id, "");
}

void *ns5__X509CertificateType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__X509CertificateType(soap, tag, this, type);
}

SOAP_FMAC3 ns5__X509CertificateType * SOAP_FMAC4 soap_in_ns5__X509CertificateType(struct soap *soap, const char *tag, ns5__X509CertificateType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns5__X509CertificateType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__X509CertificateType, sizeof(ns5__X509CertificateType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__X509CertificateType)
		return (ns5__X509CertificateType *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__ID(soap, soap_attr_value(soap, "Id", 5, 1), &((ns5__X509CertificateType*)a)->Id))
		return NULL;
	if (!(a->ns5__X509CertificateType::__item).soap_in(soap, tag, "ns5:X509CertificateType"))
		return NULL;
	return a;
}

SOAP_FMAC1 ns5__X509CertificateType * SOAP_FMAC2 SCAP_instantiate_ns5__X509CertificateType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns5__X509CertificateType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__X509CertificateType *p;
	size_t k = sizeof(ns5__X509CertificateType);
	if (n < 0)
	{	p = SOAP_NEW(ns5__X509CertificateType);
		if (p)
			((ns5__X509CertificateType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__X509CertificateType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__X509CertificateType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__X509CertificateType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__X509CertificateType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__X509CertificateType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__X509CertificateType(soap, tag ? tag : "ns5:X509CertificateType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__X509CertificateType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__X509CertificateType(soap, this, tag, type);
}

SOAP_FMAC3 ns5__X509CertificateType * SOAP_FMAC4 soap_get_ns5__X509CertificateType(struct soap *soap, ns5__X509CertificateType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__X509CertificateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__ObjectType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__ObjectType::__union_ObjectType = 0;
	soap_default_xsd__ID(soap, &this->ns5__ObjectType::Id);
	/* transient soap skipped */
}

void ns5__ObjectType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns5__union_ObjectType(soap, this->ns5__ObjectType::__union_ObjectType, &this->ns5__ObjectType::union_ObjectType);
#endif
}

int ns5__ObjectType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ObjectType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ObjectType(struct soap *soap, const char *tag, int id, const ns5__ObjectType *a, const char *type)
{
	soap_set_attr(soap, "Id", soap_xsd__ID2s(soap, ((ns5__ObjectType*)a)->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ObjectType), type))
		return soap->error;
	if (soap_out__ns5__union_ObjectType(soap, a->ns5__ObjectType::__union_ObjectType, &a->ns5__ObjectType::union_ObjectType))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__ObjectType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__ObjectType(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ObjectType * SOAP_FMAC4 soap_in_ns5__ObjectType(struct soap *soap, const char *tag, ns5__ObjectType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ObjectType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ObjectType, sizeof(ns5__ObjectType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__ObjectType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__ObjectType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__ID(soap, soap_attr_value(soap, "Id", 5, 1), &((ns5__ObjectType*)a)->Id))
		return NULL;
	size_t soap_flag_union_ObjectType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_union_ObjectType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__ns5__union_ObjectType(soap, &a->ns5__ObjectType::__union_ObjectType, &a->ns5__ObjectType::union_ObjectType))
				{	soap_flag_union_ObjectType1 = 0;
					continue;
				}
		}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__ObjectType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ObjectType, SOAP_TYPE_ns5__ObjectType, sizeof(ns5__ObjectType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__ObjectType * SOAP_FMAC2 SCAP_instantiate_ns5__ObjectType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns5__ObjectType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__ObjectType *p;
	size_t k = sizeof(ns5__ObjectType);
	if (n < 0)
	{	p = SOAP_NEW(ns5__ObjectType);
		if (p)
			((ns5__ObjectType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__ObjectType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__ObjectType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__ObjectType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__ObjectType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__ObjectType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__ObjectType(soap, tag ? tag : "ns5:ObjectType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__ObjectType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ObjectType(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ObjectType * SOAP_FMAC4 soap_get_ns5__ObjectType(struct soap *soap, ns5__ObjectType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ObjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__X509DataType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__X509CertificateType(soap, &this->ns5__X509DataType::ns5__X509Certificate);
	/* transient soap skipped */
}

void ns5__X509DataType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons5__X509CertificateType(soap, &this->ns5__X509DataType::ns5__X509Certificate);
#endif
}

int ns5__X509DataType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__X509DataType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__X509DataType(struct soap *soap, const char *tag, int id, const ns5__X509DataType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__X509DataType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__X509CertificateType(soap, "ns5:X509Certificate", -1, &a->ns5__X509DataType::ns5__X509Certificate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__X509DataType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__X509DataType(soap, tag, this, type);
}

SOAP_FMAC3 ns5__X509DataType * SOAP_FMAC4 soap_in_ns5__X509DataType(struct soap *soap, const char *tag, ns5__X509DataType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__X509DataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__X509DataType, sizeof(ns5__X509DataType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__X509DataType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__X509DataType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons5__X509CertificateType(soap, "ns5:X509Certificate", &a->ns5__X509DataType::ns5__X509Certificate, "ns5:X509CertificateType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns5__X509DataType::ns5__X509Certificate.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns5__X509DataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__X509DataType, SOAP_TYPE_ns5__X509DataType, sizeof(ns5__X509DataType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__X509DataType * SOAP_FMAC2 SCAP_instantiate_ns5__X509DataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns5__X509DataType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__X509DataType *p;
	size_t k = sizeof(ns5__X509DataType);
	if (n < 0)
	{	p = SOAP_NEW(ns5__X509DataType);
		if (p)
			((ns5__X509DataType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__X509DataType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__X509DataType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__X509DataType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__X509DataType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__X509DataType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__X509DataType(soap, tag ? tag : "ns5:X509DataType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__X509DataType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__X509DataType(soap, this, tag, type);
}

SOAP_FMAC3 ns5__X509DataType * SOAP_FMAC4 soap_get_ns5__X509DataType(struct soap *soap, ns5__X509DataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__KeyInfoType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__KeyInfoType::ns5__X509Data = NULL;
	soap_default_xsd__ID(soap, &this->ns5__KeyInfoType::Id);
	/* transient soap skipped */
}

void ns5__KeyInfoType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__X509DataType(soap, &this->ns5__KeyInfoType::ns5__X509Data);
#endif
}

int ns5__KeyInfoType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__KeyInfoType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__KeyInfoType(struct soap *soap, const char *tag, int id, const ns5__KeyInfoType *a, const char *type)
{
	soap_set_attr(soap, "Id", soap_xsd__ID2s(soap, ((ns5__KeyInfoType*)a)->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__KeyInfoType), type))
		return soap->error;
	if (!a->ns5__KeyInfoType::ns5__X509Data)
	{	if (soap_element_empty(soap, "ns5:X509Data"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__X509DataType(soap, "ns5:X509Data", -1, &a->ns5__KeyInfoType::ns5__X509Data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__KeyInfoType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__KeyInfoType(soap, tag, this, type);
}

SOAP_FMAC3 ns5__KeyInfoType * SOAP_FMAC4 soap_in_ns5__KeyInfoType(struct soap *soap, const char *tag, ns5__KeyInfoType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__KeyInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__KeyInfoType, sizeof(ns5__KeyInfoType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__KeyInfoType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__KeyInfoType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__ID(soap, soap_attr_value(soap, "Id", 5, 1), &((ns5__KeyInfoType*)a)->Id))
		return NULL;
	size_t soap_flag_ns5__X509Data1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__X509Data1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__X509DataType(soap, "ns5:X509Data", &a->ns5__KeyInfoType::ns5__X509Data, "ns5:X509DataType"))
				{	soap_flag_ns5__X509Data1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns5__KeyInfoType::ns5__X509Data))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns5__KeyInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__KeyInfoType, SOAP_TYPE_ns5__KeyInfoType, sizeof(ns5__KeyInfoType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__KeyInfoType * SOAP_FMAC2 SCAP_instantiate_ns5__KeyInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns5__KeyInfoType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__KeyInfoType *p;
	size_t k = sizeof(ns5__KeyInfoType);
	if (n < 0)
	{	p = SOAP_NEW(ns5__KeyInfoType);
		if (p)
			((ns5__KeyInfoType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__KeyInfoType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__KeyInfoType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__KeyInfoType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__KeyInfoType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__KeyInfoType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__KeyInfoType(soap, tag ? tag : "ns5:KeyInfoType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__KeyInfoType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__KeyInfoType(soap, this, tag, type);
}

SOAP_FMAC3 ns5__KeyInfoType * SOAP_FMAC4 soap_get_ns5__KeyInfoType(struct soap *soap, ns5__KeyInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__DigestMethodType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->ns5__DigestMethodType::Algorithm);
	/* transient soap skipped */
}

void ns5__DigestMethodType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns5__DigestMethodType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__DigestMethodType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__DigestMethodType(struct soap *soap, const char *tag, int id, const ns5__DigestMethodType *a, const char *type)
{
	soap_set_attr(soap, "Algorithm", soap_xsd__anyURI2s(soap, ((ns5__DigestMethodType*)a)->Algorithm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__DigestMethodType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__DigestMethodType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__DigestMethodType(soap, tag, this, type);
}

SOAP_FMAC3 ns5__DigestMethodType * SOAP_FMAC4 soap_in_ns5__DigestMethodType(struct soap *soap, const char *tag, ns5__DigestMethodType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__DigestMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__DigestMethodType, sizeof(ns5__DigestMethodType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__DigestMethodType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__DigestMethodType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Algorithm", 4, 1), &((ns5__DigestMethodType*)a)->Algorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__DigestMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__DigestMethodType, SOAP_TYPE_ns5__DigestMethodType, sizeof(ns5__DigestMethodType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__DigestMethodType * SOAP_FMAC2 SCAP_instantiate_ns5__DigestMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns5__DigestMethodType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__DigestMethodType *p;
	size_t k = sizeof(ns5__DigestMethodType);
	if (n < 0)
	{	p = SOAP_NEW(ns5__DigestMethodType);
		if (p)
			((ns5__DigestMethodType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__DigestMethodType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__DigestMethodType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__DigestMethodType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__DigestMethodType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__DigestMethodType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__DigestMethodType(soap, tag ? tag : "ns5:DigestMethodType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__DigestMethodType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__DigestMethodType(soap, this, tag, type);
}

SOAP_FMAC3 ns5__DigestMethodType * SOAP_FMAC4 soap_get_ns5__DigestMethodType(struct soap *soap, ns5__DigestMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__TransformType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->ns5__TransformType::Algorithm);
	/* transient soap skipped */
}

void ns5__TransformType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns5__TransformType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__TransformType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__TransformType(struct soap *soap, const char *tag, int id, const ns5__TransformType *a, const char *type)
{
	soap_set_attr(soap, "Algorithm", soap_xsd__anyURI2s(soap, ((ns5__TransformType*)a)->Algorithm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__TransformType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__TransformType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__TransformType(soap, tag, this, type);
}

SOAP_FMAC3 ns5__TransformType * SOAP_FMAC4 soap_in_ns5__TransformType(struct soap *soap, const char *tag, ns5__TransformType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__TransformType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__TransformType, sizeof(ns5__TransformType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__TransformType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__TransformType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Algorithm", 4, 1), &((ns5__TransformType*)a)->Algorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__TransformType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__TransformType, SOAP_TYPE_ns5__TransformType, sizeof(ns5__TransformType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__TransformType * SOAP_FMAC2 SCAP_instantiate_ns5__TransformType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns5__TransformType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__TransformType *p;
	size_t k = sizeof(ns5__TransformType);
	if (n < 0)
	{	p = SOAP_NEW(ns5__TransformType);
		if (p)
			((ns5__TransformType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__TransformType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__TransformType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__TransformType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__TransformType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__TransformType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__TransformType(soap, tag ? tag : "ns5:TransformType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__TransformType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__TransformType(soap, this, tag, type);
}

SOAP_FMAC3 ns5__TransformType * SOAP_FMAC4 soap_get_ns5__TransformType(struct soap *soap, ns5__TransformType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__TransformsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__TransformType(soap, &this->ns5__TransformsType::ns5__Transform);
	/* transient soap skipped */
}

void ns5__TransformsType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons5__TransformType(soap, &this->ns5__TransformsType::ns5__Transform);
#endif
}

int ns5__TransformsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__TransformsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__TransformsType(struct soap *soap, const char *tag, int id, const ns5__TransformsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__TransformsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__TransformType(soap, "ns5:Transform", -1, &a->ns5__TransformsType::ns5__Transform, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__TransformsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__TransformsType(soap, tag, this, type);
}

SOAP_FMAC3 ns5__TransformsType * SOAP_FMAC4 soap_in_ns5__TransformsType(struct soap *soap, const char *tag, ns5__TransformsType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__TransformsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__TransformsType, sizeof(ns5__TransformsType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__TransformsType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__TransformsType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons5__TransformType(soap, "ns5:Transform", &a->ns5__TransformsType::ns5__Transform, "ns5:TransformType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns5__TransformsType::ns5__Transform.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns5__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__TransformsType, SOAP_TYPE_ns5__TransformsType, sizeof(ns5__TransformsType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__TransformsType * SOAP_FMAC2 SCAP_instantiate_ns5__TransformsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns5__TransformsType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__TransformsType *p;
	size_t k = sizeof(ns5__TransformsType);
	if (n < 0)
	{	p = SOAP_NEW(ns5__TransformsType);
		if (p)
			((ns5__TransformsType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__TransformsType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__TransformsType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__TransformsType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__TransformsType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__TransformsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__TransformsType(soap, tag ? tag : "ns5:TransformsType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__TransformsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__TransformsType(soap, this, tag, type);
}

SOAP_FMAC3 ns5__TransformsType * SOAP_FMAC4 soap_get_ns5__TransformsType(struct soap *soap, ns5__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__ReferenceType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__ReferenceType::ns5__Transforms = NULL;
	this->ns5__ReferenceType::ns5__DigestMethod = NULL;
	this->ns5__ReferenceType::ns5__DigestValue = NULL;
	soap_default_xsd__ID(soap, &this->ns5__ReferenceType::Id);
	this->ns5__ReferenceType::Type = NULL;
	this->ns5__ReferenceType::URI = NULL;
	/* transient soap skipped */
}

void ns5__ReferenceType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__TransformsType(soap, &this->ns5__ReferenceType::ns5__Transforms);
	soap_serialize_PointerTons5__DigestMethodType(soap, &this->ns5__ReferenceType::ns5__DigestMethod);
	soap_serialize_PointerTons5__DigestValueType(soap, &this->ns5__ReferenceType::ns5__DigestValue);
#endif
}

int ns5__ReferenceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ReferenceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ReferenceType(struct soap *soap, const char *tag, int id, const ns5__ReferenceType *a, const char *type)
{
	soap_set_attr(soap, "Id", soap_xsd__ID2s(soap, ((ns5__ReferenceType*)a)->Id), 1);
	if (((ns5__ReferenceType*)a)->Type)
	{	soap_set_attr(soap, "Type", soap_xsd__anyURI2s(soap, *((ns5__ReferenceType*)a)->Type), 1);
	}
	if (((ns5__ReferenceType*)a)->URI)
	{	soap_set_attr(soap, "URI", soap_xsd__anyURI2s(soap, *((ns5__ReferenceType*)a)->URI), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ReferenceType), type))
		return soap->error;
	if (!a->ns5__ReferenceType::ns5__Transforms)
	{	if (soap_element_empty(soap, "ns5:Transforms"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__TransformsType(soap, "ns5:Transforms", -1, &a->ns5__ReferenceType::ns5__Transforms, ""))
		return soap->error;
	if (!a->ns5__ReferenceType::ns5__DigestMethod)
	{	if (soap_element_empty(soap, "ns5:DigestMethod"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__DigestMethodType(soap, "ns5:DigestMethod", -1, &a->ns5__ReferenceType::ns5__DigestMethod, ""))
		return soap->error;
	if (!a->ns5__ReferenceType::ns5__DigestValue)
	{	if (soap_element_empty(soap, "ns5:DigestValue"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__DigestValueType(soap, "ns5:DigestValue", -1, &a->ns5__ReferenceType::ns5__DigestValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__ReferenceType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__ReferenceType(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ReferenceType * SOAP_FMAC4 soap_in_ns5__ReferenceType(struct soap *soap, const char *tag, ns5__ReferenceType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ReferenceType, sizeof(ns5__ReferenceType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__ReferenceType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__ReferenceType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__ID(soap, soap_attr_value(soap, "Id", 5, 1), &((ns5__ReferenceType*)a)->Id))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "Type", 4, 0);
		if (t)
		{
			if (!(((ns5__ReferenceType*)a)->Type = soap_new_xsd__anyURI(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__anyURI(soap, t, ((ns5__ReferenceType*)a)->Type))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "URI", 4, 0);
		if (t)
		{
			if (!(((ns5__ReferenceType*)a)->URI = soap_new_xsd__anyURI(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__anyURI(soap, t, ((ns5__ReferenceType*)a)->URI))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_ns5__Transforms1 = 1;
	size_t soap_flag_ns5__DigestMethod1 = 1;
	size_t soap_flag_ns5__DigestValue1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__Transforms1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__TransformsType(soap, "ns5:Transforms", &a->ns5__ReferenceType::ns5__Transforms, "ns5:TransformsType"))
				{	soap_flag_ns5__Transforms1--;
					continue;
				}
			}
			if (soap_flag_ns5__DigestMethod1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__DigestMethodType(soap, "ns5:DigestMethod", &a->ns5__ReferenceType::ns5__DigestMethod, "ns5:DigestMethodType"))
				{	soap_flag_ns5__DigestMethod1--;
					continue;
				}
			}
			if (soap_flag_ns5__DigestValue1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__DigestValueType(soap, "ns5:DigestValue", &a->ns5__ReferenceType::ns5__DigestValue, "ns5:DigestValueType"))
				{	soap_flag_ns5__DigestValue1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns5__ReferenceType::ns5__Transforms || !a->ns5__ReferenceType::ns5__DigestMethod || !a->ns5__ReferenceType::ns5__DigestValue))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns5__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ReferenceType, SOAP_TYPE_ns5__ReferenceType, sizeof(ns5__ReferenceType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__ReferenceType * SOAP_FMAC2 SCAP_instantiate_ns5__ReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns5__ReferenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__ReferenceType *p;
	size_t k = sizeof(ns5__ReferenceType);
	if (n < 0)
	{	p = SOAP_NEW(ns5__ReferenceType);
		if (p)
			((ns5__ReferenceType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__ReferenceType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__ReferenceType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__ReferenceType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__ReferenceType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__ReferenceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__ReferenceType(soap, tag ? tag : "ns5:ReferenceType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__ReferenceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ReferenceType(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ReferenceType * SOAP_FMAC4 soap_get_ns5__ReferenceType(struct soap *soap, ns5__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__SignatureMethodType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->ns5__SignatureMethodType::Algorithm);
	/* transient soap skipped */
}

void ns5__SignatureMethodType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns5__SignatureMethodType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__SignatureMethodType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__SignatureMethodType(struct soap *soap, const char *tag, int id, const ns5__SignatureMethodType *a, const char *type)
{
	soap_set_attr(soap, "Algorithm", soap_xsd__anyURI2s(soap, ((ns5__SignatureMethodType*)a)->Algorithm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__SignatureMethodType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__SignatureMethodType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__SignatureMethodType(soap, tag, this, type);
}

SOAP_FMAC3 ns5__SignatureMethodType * SOAP_FMAC4 soap_in_ns5__SignatureMethodType(struct soap *soap, const char *tag, ns5__SignatureMethodType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__SignatureMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__SignatureMethodType, sizeof(ns5__SignatureMethodType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__SignatureMethodType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__SignatureMethodType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Algorithm", 4, 1), &((ns5__SignatureMethodType*)a)->Algorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__SignatureMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__SignatureMethodType, SOAP_TYPE_ns5__SignatureMethodType, sizeof(ns5__SignatureMethodType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__SignatureMethodType * SOAP_FMAC2 SCAP_instantiate_ns5__SignatureMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns5__SignatureMethodType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__SignatureMethodType *p;
	size_t k = sizeof(ns5__SignatureMethodType);
	if (n < 0)
	{	p = SOAP_NEW(ns5__SignatureMethodType);
		if (p)
			((ns5__SignatureMethodType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__SignatureMethodType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__SignatureMethodType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__SignatureMethodType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__SignatureMethodType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__SignatureMethodType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__SignatureMethodType(soap, tag ? tag : "ns5:SignatureMethodType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__SignatureMethodType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__SignatureMethodType(soap, this, tag, type);
}

SOAP_FMAC3 ns5__SignatureMethodType * SOAP_FMAC4 soap_get_ns5__SignatureMethodType(struct soap *soap, ns5__SignatureMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__CanonicalizationMethodType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->ns5__CanonicalizationMethodType::Algorithm);
	/* transient soap skipped */
}

void ns5__CanonicalizationMethodType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns5__CanonicalizationMethodType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__CanonicalizationMethodType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, const ns5__CanonicalizationMethodType *a, const char *type)
{
	soap_set_attr(soap, "Algorithm", soap_xsd__anyURI2s(soap, ((ns5__CanonicalizationMethodType*)a)->Algorithm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__CanonicalizationMethodType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__CanonicalizationMethodType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__CanonicalizationMethodType(soap, tag, this, type);
}

SOAP_FMAC3 ns5__CanonicalizationMethodType * SOAP_FMAC4 soap_in_ns5__CanonicalizationMethodType(struct soap *soap, const char *tag, ns5__CanonicalizationMethodType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__CanonicalizationMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CanonicalizationMethodType, sizeof(ns5__CanonicalizationMethodType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__CanonicalizationMethodType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__CanonicalizationMethodType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Algorithm", 4, 1), &((ns5__CanonicalizationMethodType*)a)->Algorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__CanonicalizationMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__CanonicalizationMethodType, SOAP_TYPE_ns5__CanonicalizationMethodType, sizeof(ns5__CanonicalizationMethodType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__CanonicalizationMethodType * SOAP_FMAC2 SCAP_instantiate_ns5__CanonicalizationMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns5__CanonicalizationMethodType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__CanonicalizationMethodType *p;
	size_t k = sizeof(ns5__CanonicalizationMethodType);
	if (n < 0)
	{	p = SOAP_NEW(ns5__CanonicalizationMethodType);
		if (p)
			((ns5__CanonicalizationMethodType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__CanonicalizationMethodType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__CanonicalizationMethodType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__CanonicalizationMethodType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__CanonicalizationMethodType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__CanonicalizationMethodType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__CanonicalizationMethodType(soap, tag ? tag : "ns5:CanonicalizationMethodType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__CanonicalizationMethodType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__CanonicalizationMethodType(soap, this, tag, type);
}

SOAP_FMAC3 ns5__CanonicalizationMethodType * SOAP_FMAC4 soap_get_ns5__CanonicalizationMethodType(struct soap *soap, ns5__CanonicalizationMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__SignedInfoType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__SignedInfoType::ns5__CanonicalizationMethod = NULL;
	this->ns5__SignedInfoType::ns5__SignatureMethod = NULL;
	soap_default_std__vectorTemplateOfPointerTons5__ReferenceType(soap, &this->ns5__SignedInfoType::ns5__Reference);
	soap_default_xsd__ID(soap, &this->ns5__SignedInfoType::Id);
	/* transient soap skipped */
}

void ns5__SignedInfoType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__CanonicalizationMethodType(soap, &this->ns5__SignedInfoType::ns5__CanonicalizationMethod);
	soap_serialize_PointerTons5__SignatureMethodType(soap, &this->ns5__SignedInfoType::ns5__SignatureMethod);
	soap_serialize_std__vectorTemplateOfPointerTons5__ReferenceType(soap, &this->ns5__SignedInfoType::ns5__Reference);
#endif
}

int ns5__SignedInfoType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__SignedInfoType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__SignedInfoType(struct soap *soap, const char *tag, int id, const ns5__SignedInfoType *a, const char *type)
{
	soap_set_attr(soap, "Id", soap_xsd__ID2s(soap, ((ns5__SignedInfoType*)a)->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__SignedInfoType), type))
		return soap->error;
	if (!a->ns5__SignedInfoType::ns5__CanonicalizationMethod)
	{	if (soap_element_empty(soap, "ns5:CanonicalizationMethod"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__CanonicalizationMethodType(soap, "ns5:CanonicalizationMethod", -1, &a->ns5__SignedInfoType::ns5__CanonicalizationMethod, ""))
		return soap->error;
	if (!a->ns5__SignedInfoType::ns5__SignatureMethod)
	{	if (soap_element_empty(soap, "ns5:SignatureMethod"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__SignatureMethodType(soap, "ns5:SignatureMethod", -1, &a->ns5__SignedInfoType::ns5__SignatureMethod, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__ReferenceType(soap, "ns5:Reference", -1, &a->ns5__SignedInfoType::ns5__Reference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__SignedInfoType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__SignedInfoType(soap, tag, this, type);
}

SOAP_FMAC3 ns5__SignedInfoType * SOAP_FMAC4 soap_in_ns5__SignedInfoType(struct soap *soap, const char *tag, ns5__SignedInfoType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__SignedInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__SignedInfoType, sizeof(ns5__SignedInfoType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__SignedInfoType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__SignedInfoType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__ID(soap, soap_attr_value(soap, "Id", 5, 1), &((ns5__SignedInfoType*)a)->Id))
		return NULL;
	size_t soap_flag_ns5__CanonicalizationMethod1 = 1;
	size_t soap_flag_ns5__SignatureMethod1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__CanonicalizationMethod1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__CanonicalizationMethodType(soap, "ns5:CanonicalizationMethod", &a->ns5__SignedInfoType::ns5__CanonicalizationMethod, "ns5:CanonicalizationMethodType"))
				{	soap_flag_ns5__CanonicalizationMethod1--;
					continue;
				}
			}
			if (soap_flag_ns5__SignatureMethod1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__SignatureMethodType(soap, "ns5:SignatureMethod", &a->ns5__SignedInfoType::ns5__SignatureMethod, "ns5:SignatureMethodType"))
				{	soap_flag_ns5__SignatureMethod1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons5__ReferenceType(soap, "ns5:Reference", &a->ns5__SignedInfoType::ns5__Reference, "ns5:ReferenceType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns5__SignedInfoType::ns5__CanonicalizationMethod || !a->ns5__SignedInfoType::ns5__SignatureMethod || a->ns5__SignedInfoType::ns5__Reference.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns5__SignedInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__SignedInfoType, SOAP_TYPE_ns5__SignedInfoType, sizeof(ns5__SignedInfoType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__SignedInfoType * SOAP_FMAC2 SCAP_instantiate_ns5__SignedInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns5__SignedInfoType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__SignedInfoType *p;
	size_t k = sizeof(ns5__SignedInfoType);
	if (n < 0)
	{	p = SOAP_NEW(ns5__SignedInfoType);
		if (p)
			((ns5__SignedInfoType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__SignedInfoType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__SignedInfoType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__SignedInfoType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__SignedInfoType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__SignedInfoType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__SignedInfoType(soap, tag ? tag : "ns5:SignedInfoType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__SignedInfoType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__SignedInfoType(soap, this, tag, type);
}

SOAP_FMAC3 ns5__SignedInfoType * SOAP_FMAC4 soap_get_ns5__SignedInfoType(struct soap *soap, ns5__SignedInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__SignatureType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__SignatureType::ns5__SignedInfo = NULL;
	this->ns5__SignatureType::ns5__SignatureValue = NULL;
	this->ns5__SignatureType::ns5__KeyInfo = NULL;
	soap_default_std__vectorTemplateOfPointerTons5__ObjectType(soap, &this->ns5__SignatureType::ns5__Object);
	soap_default_xsd__ID(soap, &this->ns5__SignatureType::Id);
	/* transient soap skipped */
}

void ns5__SignatureType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__SignedInfoType(soap, &this->ns5__SignatureType::ns5__SignedInfo);
	soap_serialize_PointerTons5__SignatureValueType(soap, &this->ns5__SignatureType::ns5__SignatureValue);
	soap_serialize_PointerTons5__KeyInfoType(soap, &this->ns5__SignatureType::ns5__KeyInfo);
	soap_serialize_std__vectorTemplateOfPointerTons5__ObjectType(soap, &this->ns5__SignatureType::ns5__Object);
#endif
}

int ns5__SignatureType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__SignatureType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__SignatureType(struct soap *soap, const char *tag, int id, const ns5__SignatureType *a, const char *type)
{
	soap_set_attr(soap, "Id", soap_xsd__ID2s(soap, ((ns5__SignatureType*)a)->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__SignatureType), type))
		return soap->error;
	if (!a->ns5__SignatureType::ns5__SignedInfo)
	{	if (soap_element_empty(soap, "ns5:SignedInfo"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__SignedInfoType(soap, "ns5:SignedInfo", -1, &a->ns5__SignatureType::ns5__SignedInfo, ""))
		return soap->error;
	if (!a->ns5__SignatureType::ns5__SignatureValue)
	{	if (soap_element_empty(soap, "ns5:SignatureValue"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__SignatureValueType(soap, "ns5:SignatureValue", -1, &a->ns5__SignatureType::ns5__SignatureValue, ""))
		return soap->error;
	if (!a->ns5__SignatureType::ns5__KeyInfo)
	{	if (soap_element_empty(soap, "ns5:KeyInfo"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__KeyInfoType(soap, "ns5:KeyInfo", -1, &a->ns5__SignatureType::ns5__KeyInfo, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__ObjectType(soap, "ns5:Object", -1, &a->ns5__SignatureType::ns5__Object, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__SignatureType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__SignatureType(soap, tag, this, type);
}

SOAP_FMAC3 ns5__SignatureType * SOAP_FMAC4 soap_in_ns5__SignatureType(struct soap *soap, const char *tag, ns5__SignatureType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__SignatureType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__SignatureType, sizeof(ns5__SignatureType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__SignatureType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__SignatureType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__ID(soap, soap_attr_value(soap, "Id", 5, 1), &((ns5__SignatureType*)a)->Id))
		return NULL;
	size_t soap_flag_ns5__SignedInfo1 = 1;
	size_t soap_flag_ns5__SignatureValue1 = 1;
	size_t soap_flag_ns5__KeyInfo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__SignedInfo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__SignedInfoType(soap, "ns5:SignedInfo", &a->ns5__SignatureType::ns5__SignedInfo, "ns5:SignedInfoType"))
				{	soap_flag_ns5__SignedInfo1--;
					continue;
				}
			}
			if (soap_flag_ns5__SignatureValue1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__SignatureValueType(soap, "ns5:SignatureValue", &a->ns5__SignatureType::ns5__SignatureValue, "ns5:SignatureValueType"))
				{	soap_flag_ns5__SignatureValue1--;
					continue;
				}
			}
			if (soap_flag_ns5__KeyInfo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons5__KeyInfoType(soap, "ns5:KeyInfo", &a->ns5__SignatureType::ns5__KeyInfo, "ns5:KeyInfoType"))
				{	soap_flag_ns5__KeyInfo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons5__ObjectType(soap, "ns5:Object", &a->ns5__SignatureType::ns5__Object, "ns5:ObjectType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns5__SignatureType::ns5__SignedInfo || !a->ns5__SignatureType::ns5__SignatureValue || !a->ns5__SignatureType::ns5__KeyInfo))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns5__SignatureType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__SignatureType, SOAP_TYPE_ns5__SignatureType, sizeof(ns5__SignatureType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__SignatureType * SOAP_FMAC2 SCAP_instantiate_ns5__SignatureType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns5__SignatureType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__SignatureType *p;
	size_t k = sizeof(ns5__SignatureType);
	if (n < 0)
	{	p = SOAP_NEW(ns5__SignatureType);
		if (p)
			((ns5__SignatureType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__SignatureType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__SignatureType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__SignatureType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__SignatureType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__SignatureType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__SignatureType(soap, tag ? tag : "ns5:SignatureType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__SignatureType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__SignatureType(soap, this, tag, type);
}

SOAP_FMAC3 ns5__SignatureType * SOAP_FMAC4 soap_get_ns5__SignatureType(struct soap *soap, ns5__SignatureType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ResponseResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__ResponseResult::ResultCode);
	soap_default_std__string(soap, &this->ns2__ResponseResult::ResultMessage);
	this->ns2__ResponseResult::CitizenIDWithExtraInfo = NULL;
	/* transient soap skipped */
}

void ns2__ResponseResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns2__ResponseResult::ResultCode, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__ResponseResult::ResultCode);
	soap_embedded(soap, &this->ns2__ResponseResult::ResultMessage, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__ResponseResult::ResultMessage);
	soap_serialize_PointerTons3__PersonalDataType(soap, &this->ns2__ResponseResult::CitizenIDWithExtraInfo);
#endif
}

int ns2__ResponseResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ResponseResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ResponseResult(struct soap *soap, const char *tag, int id, const ns2__ResponseResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ResponseResult), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:ResultCode", -1, &a->ns2__ResponseResult::ResultCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:ResultMessage", -1, &a->ns2__ResponseResult::ResultMessage, ""))
		return soap->error;
	if (!a->ns2__ResponseResult::CitizenIDWithExtraInfo)
	{	if (soap_element_empty(soap, "ns2:CitizenIDWithExtraInfo"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__PersonalDataType(soap, "ns2:CitizenIDWithExtraInfo", -1, &a->ns2__ResponseResult::CitizenIDWithExtraInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ResponseResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ResponseResult(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ResponseResult * SOAP_FMAC4 soap_in_ns2__ResponseResult(struct soap *soap, const char *tag, ns2__ResponseResult *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ResponseResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ResponseResult, sizeof(ns2__ResponseResult), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ResponseResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ResponseResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultCode1 = 1;
	size_t soap_flag_ResultMessage1 = 1;
	size_t soap_flag_CitizenIDWithExtraInfo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns2:ResultCode", &a->ns2__ResponseResult::ResultCode, "xsd:string"))
				{	soap_flag_ResultCode1--;
					continue;
				}
			}
			if (soap_flag_ResultMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns2:ResultMessage", &a->ns2__ResponseResult::ResultMessage, "xsd:string"))
				{	soap_flag_ResultMessage1--;
					continue;
				}
			}
			if (soap_flag_CitizenIDWithExtraInfo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__PersonalDataType(soap, "ns2:CitizenIDWithExtraInfo", &a->ns2__ResponseResult::CitizenIDWithExtraInfo, "ns3:PersonalDataType"))
				{	soap_flag_CitizenIDWithExtraInfo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ResultCode1 > 0 || soap_flag_ResultMessage1 > 0 || !a->ns2__ResponseResult::CitizenIDWithExtraInfo))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__ResponseResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ResponseResult, SOAP_TYPE_ns2__ResponseResult, sizeof(ns2__ResponseResult), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ResponseResult * SOAP_FMAC2 SCAP_instantiate_ns2__ResponseResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns2__ResponseResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ResponseResult *p;
	size_t k = sizeof(ns2__ResponseResult);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ResponseResult);
		if (p)
			((ns2__ResponseResult*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ResponseResult, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ResponseResult*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ResponseResult location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ResponseResult, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ResponseResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__ResponseResult(soap, tag ? tag : "ns2:ResponseResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ResponseResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ResponseResult(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ResponseResult * SOAP_FMAC4 soap_get_ns2__ResponseResult(struct soap *soap, ns2__ResponseResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ResponseResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__UnsignedAttributesBasicType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__AttributeType(soap, &this->ns2__UnsignedAttributesBasicType::ns3__Attribute);
	/* transient soap skipped */
}

void ns2__UnsignedAttributesBasicType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__AttributeType(soap, &this->ns2__UnsignedAttributesBasicType::ns3__Attribute);
#endif
}

int ns2__UnsignedAttributesBasicType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__UnsignedAttributesBasicType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__UnsignedAttributesBasicType(struct soap *soap, const char *tag, int id, const ns2__UnsignedAttributesBasicType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__UnsignedAttributesBasicType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__AttributeType(soap, "ns3:Attribute", -1, &a->ns2__UnsignedAttributesBasicType::ns3__Attribute, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__UnsignedAttributesBasicType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__UnsignedAttributesBasicType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__UnsignedAttributesBasicType * SOAP_FMAC4 soap_in_ns2__UnsignedAttributesBasicType(struct soap *soap, const char *tag, ns2__UnsignedAttributesBasicType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__UnsignedAttributesBasicType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__UnsignedAttributesBasicType, sizeof(ns2__UnsignedAttributesBasicType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__UnsignedAttributesBasicType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__UnsignedAttributesBasicType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__AttributeType(soap, "ns3:Attribute", &a->ns2__UnsignedAttributesBasicType::ns3__Attribute, "ns3:AttributeType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__UnsignedAttributesBasicType::ns3__Attribute.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__UnsignedAttributesBasicType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__UnsignedAttributesBasicType, SOAP_TYPE_ns2__UnsignedAttributesBasicType, sizeof(ns2__UnsignedAttributesBasicType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__UnsignedAttributesBasicType * SOAP_FMAC2 SCAP_instantiate_ns2__UnsignedAttributesBasicType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns2__UnsignedAttributesBasicType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__UnsignedAttributesBasicType *p;
	size_t k = sizeof(ns2__UnsignedAttributesBasicType);
	if (n < 0)
	{	p = SOAP_NEW(ns2__UnsignedAttributesBasicType);
		if (p)
			((ns2__UnsignedAttributesBasicType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__UnsignedAttributesBasicType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__UnsignedAttributesBasicType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__UnsignedAttributesBasicType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__UnsignedAttributesBasicType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__UnsignedAttributesBasicType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__UnsignedAttributesBasicType(soap, tag ? tag : "ns2:UnsignedAttributesBasicType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__UnsignedAttributesBasicType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__UnsignedAttributesBasicType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__UnsignedAttributesBasicType * SOAP_FMAC4 soap_get_ns2__UnsignedAttributesBasicType(struct soap *soap, ns2__UnsignedAttributesBasicType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__UnsignedAttributesBasicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__SignedAttributesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__SignatureType(soap, &this->ns2__SignedAttributesType::ns3__SignatureAttribute);
	/* transient soap skipped */
}

void ns2__SignedAttributesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons5__SignatureType(soap, &this->ns2__SignedAttributesType::ns3__SignatureAttribute);
#endif
}

int ns2__SignedAttributesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SignedAttributesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SignedAttributesType(struct soap *soap, const char *tag, int id, const ns2__SignedAttributesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SignedAttributesType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__SignatureType(soap, "ns3:SignatureAttribute", -1, &a->ns2__SignedAttributesType::ns3__SignatureAttribute, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__SignedAttributesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SignedAttributesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SignedAttributesType * SOAP_FMAC4 soap_in_ns2__SignedAttributesType(struct soap *soap, const char *tag, ns2__SignedAttributesType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SignedAttributesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SignedAttributesType, sizeof(ns2__SignedAttributesType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__SignedAttributesType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__SignedAttributesType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons5__SignatureType(soap, "ns3:SignatureAttribute", &a->ns2__SignedAttributesType::ns3__SignatureAttribute, "ns5:SignatureType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__SignedAttributesType::ns3__SignatureAttribute.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__SignedAttributesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SignedAttributesType, SOAP_TYPE_ns2__SignedAttributesType, sizeof(ns2__SignedAttributesType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__SignedAttributesType * SOAP_FMAC2 SCAP_instantiate_ns2__SignedAttributesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns2__SignedAttributesType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__SignedAttributesType *p;
	size_t k = sizeof(ns2__SignedAttributesType);
	if (n < 0)
	{	p = SOAP_NEW(ns2__SignedAttributesType);
		if (p)
			((ns2__SignedAttributesType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__SignedAttributesType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__SignedAttributesType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__SignedAttributesType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__SignedAttributesType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__SignedAttributesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__SignedAttributesType(soap, tag ? tag : "ns2:SignedAttributesType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SignedAttributesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SignedAttributesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SignedAttributesType * SOAP_FMAC4 soap_get_ns2__SignedAttributesType(struct soap *soap, ns2__SignedAttributesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SignedAttributesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__UnsignedAttributesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__UnsignedAttributesType::ResponseResult = NULL;
	this->ns2__UnsignedAttributesType::UnsignedAttributes = NULL;
	/* transient soap skipped */
}

void ns2__UnsignedAttributesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__ResponseResult(soap, &this->ns2__UnsignedAttributesType::ResponseResult);
	soap_serialize_PointerTons2__UnsignedAttributesBasicType(soap, &this->ns2__UnsignedAttributesType::UnsignedAttributes);
#endif
}

int ns2__UnsignedAttributesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__UnsignedAttributesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__UnsignedAttributesType(struct soap *soap, const char *tag, int id, const ns2__UnsignedAttributesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__UnsignedAttributesType), type))
		return soap->error;
	if (!a->ns2__UnsignedAttributesType::ResponseResult)
	{	if (soap_element_empty(soap, "ns2:ResponseResult"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__ResponseResult(soap, "ns2:ResponseResult", -1, &a->ns2__UnsignedAttributesType::ResponseResult, ""))
		return soap->error;
	if (soap_out_PointerTons2__UnsignedAttributesBasicType(soap, "ns2:UnsignedAttributes", -1, &a->ns2__UnsignedAttributesType::UnsignedAttributes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__UnsignedAttributesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__UnsignedAttributesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__UnsignedAttributesType * SOAP_FMAC4 soap_in_ns2__UnsignedAttributesType(struct soap *soap, const char *tag, ns2__UnsignedAttributesType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__UnsignedAttributesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__UnsignedAttributesType, sizeof(ns2__UnsignedAttributesType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__UnsignedAttributesType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__UnsignedAttributesType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResponseResult1 = 1;
	size_t soap_flag_UnsignedAttributes1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResponseResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__ResponseResult(soap, "ns2:ResponseResult", &a->ns2__UnsignedAttributesType::ResponseResult, "ns2:ResponseResult"))
				{	soap_flag_ResponseResult1--;
					continue;
				}
			}
			if (soap_flag_UnsignedAttributes1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__UnsignedAttributesBasicType(soap, "ns2:UnsignedAttributes", &a->ns2__UnsignedAttributesType::UnsignedAttributes, "ns2:UnsignedAttributesBasicType"))
				{	soap_flag_UnsignedAttributes1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns2__UnsignedAttributesType::ResponseResult))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__UnsignedAttributesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__UnsignedAttributesType, SOAP_TYPE_ns2__UnsignedAttributesType, sizeof(ns2__UnsignedAttributesType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__UnsignedAttributesType * SOAP_FMAC2 SCAP_instantiate_ns2__UnsignedAttributesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns2__UnsignedAttributesType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__UnsignedAttributesType *p;
	size_t k = sizeof(ns2__UnsignedAttributesType);
	if (n < 0)
	{	p = SOAP_NEW(ns2__UnsignedAttributesType);
		if (p)
			((ns2__UnsignedAttributesType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__UnsignedAttributesType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__UnsignedAttributesType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__UnsignedAttributesType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__UnsignedAttributesType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__UnsignedAttributesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__UnsignedAttributesType(soap, tag ? tag : "ns2:UnsignedAttributesType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__UnsignedAttributesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__UnsignedAttributesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__UnsignedAttributesType * SOAP_FMAC4 soap_get_ns2__UnsignedAttributesType(struct soap *soap, ns2__UnsignedAttributesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__UnsignedAttributesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__AttributesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__AttributesType::ATTRSupplier = NULL;
	this->ns2__AttributesType::ResponseResult = NULL;
	this->ns2__AttributesType::SignedAttributes = NULL;
	/* transient soap skipped */
}

void ns2__AttributesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__AttributeSupplierType(soap, &this->ns2__AttributesType::ATTRSupplier);
	soap_serialize_PointerTons2__ResponseResult(soap, &this->ns2__AttributesType::ResponseResult);
	soap_serialize_PointerTons2__SignedAttributesType(soap, &this->ns2__AttributesType::SignedAttributes);
#endif
}

int ns2__AttributesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AttributesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AttributesType(struct soap *soap, const char *tag, int id, const ns2__AttributesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AttributesType), type))
		return soap->error;
	if (!a->ns2__AttributesType::ATTRSupplier)
	{	if (soap_element_empty(soap, "ns2:ATTRSupplier"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__AttributeSupplierType(soap, "ns2:ATTRSupplier", -1, &a->ns2__AttributesType::ATTRSupplier, ""))
		return soap->error;
	if (!a->ns2__AttributesType::ResponseResult)
	{	if (soap_element_empty(soap, "ns2:ResponseResult"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__ResponseResult(soap, "ns2:ResponseResult", -1, &a->ns2__AttributesType::ResponseResult, ""))
		return soap->error;
	if (soap_out_PointerTons2__SignedAttributesType(soap, "ns2:SignedAttributes", -1, &a->ns2__AttributesType::SignedAttributes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__AttributesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AttributesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AttributesType * SOAP_FMAC4 soap_in_ns2__AttributesType(struct soap *soap, const char *tag, ns2__AttributesType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AttributesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AttributesType, sizeof(ns2__AttributesType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__AttributesType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__AttributesType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ATTRSupplier1 = 1;
	size_t soap_flag_ResponseResult1 = 1;
	size_t soap_flag_SignedAttributes1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ATTRSupplier1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__AttributeSupplierType(soap, "ns2:ATTRSupplier", &a->ns2__AttributesType::ATTRSupplier, "ns3:AttributeSupplierType"))
				{	soap_flag_ATTRSupplier1--;
					continue;
				}
			}
			if (soap_flag_ResponseResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__ResponseResult(soap, "ns2:ResponseResult", &a->ns2__AttributesType::ResponseResult, "ns2:ResponseResult"))
				{	soap_flag_ResponseResult1--;
					continue;
				}
			}
			if (soap_flag_SignedAttributes1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__SignedAttributesType(soap, "ns2:SignedAttributes", &a->ns2__AttributesType::SignedAttributes, "ns2:SignedAttributesType"))
				{	soap_flag_SignedAttributes1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns2__AttributesType::ATTRSupplier || !a->ns2__AttributesType::ResponseResult))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__AttributesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AttributesType, SOAP_TYPE_ns2__AttributesType, sizeof(ns2__AttributesType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__AttributesType * SOAP_FMAC2 SCAP_instantiate_ns2__AttributesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns2__AttributesType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__AttributesType *p;
	size_t k = sizeof(ns2__AttributesType);
	if (n < 0)
	{	p = SOAP_NEW(ns2__AttributesType);
		if (p)
			((ns2__AttributesType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__AttributesType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__AttributesType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__AttributesType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__AttributesType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__AttributesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__AttributesType(soap, tag ? tag : "ns2:AttributesType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AttributesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AttributesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AttributesType * SOAP_FMAC4 soap_get_ns2__AttributesType(struct soap *soap, ns2__AttributesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AttributesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__UnsignedAttributeResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns4__ProcessIDType(soap, &this->ns2__UnsignedAttributeResponseType::ProcessId);
	this->ns2__UnsignedAttributeResponseType::CompanyId = NULL;
	this->ns2__UnsignedAttributeResponseType::CompanyName = NULL;
	this->ns2__UnsignedAttributeResponseType::AttributeResponseValues = NULL;
	/* transient soap skipped */
}

void ns2__UnsignedAttributeResponseType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns4__ProcessIDType(soap, &this->ns2__UnsignedAttributeResponseType::ProcessId);
	soap_serialize_PointerTons4__NIPCType(soap, &this->ns2__UnsignedAttributeResponseType::CompanyId);
	soap_serialize_PointerTons4__CompanyNameType(soap, &this->ns2__UnsignedAttributeResponseType::CompanyName);
	soap_serialize_PointerTons2__UnsignedAttributesType(soap, &this->ns2__UnsignedAttributeResponseType::AttributeResponseValues);
#endif
}

int ns2__UnsignedAttributeResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__UnsignedAttributeResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__UnsignedAttributeResponseType(struct soap *soap, const char *tag, int id, const ns2__UnsignedAttributeResponseType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__UnsignedAttributeResponseType), type))
		return soap->error;
	if (soap_out_ns4__ProcessIDType(soap, "ns2:ProcessId", -1, &a->ns2__UnsignedAttributeResponseType::ProcessId, ""))
		return soap->error;
	if (soap_out_PointerTons4__NIPCType(soap, "ns2:CompanyId", -1, &a->ns2__UnsignedAttributeResponseType::CompanyId, ""))
		return soap->error;
	if (soap_out_PointerTons4__CompanyNameType(soap, "ns2:CompanyName", -1, &a->ns2__UnsignedAttributeResponseType::CompanyName, ""))
		return soap->error;
	if (!a->ns2__UnsignedAttributeResponseType::AttributeResponseValues)
	{	if (soap_element_empty(soap, "ns2:AttributeResponseValues"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__UnsignedAttributesType(soap, "ns2:AttributeResponseValues", -1, &a->ns2__UnsignedAttributeResponseType::AttributeResponseValues, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__UnsignedAttributeResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__UnsignedAttributeResponseType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__UnsignedAttributeResponseType * SOAP_FMAC4 soap_in_ns2__UnsignedAttributeResponseType(struct soap *soap, const char *tag, ns2__UnsignedAttributeResponseType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__UnsignedAttributeResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__UnsignedAttributeResponseType, sizeof(ns2__UnsignedAttributeResponseType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__UnsignedAttributeResponseType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__UnsignedAttributeResponseType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProcessId1 = 1;
	size_t soap_flag_CompanyId1 = 1;
	size_t soap_flag_CompanyName1 = 1;
	size_t soap_flag_AttributeResponseValues1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProcessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns4__ProcessIDType(soap, "ns2:ProcessId", &a->ns2__UnsignedAttributeResponseType::ProcessId, "ns4:ProcessIDType"))
				{	soap_flag_ProcessId1--;
					continue;
				}
			}
			if (soap_flag_CompanyId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons4__NIPCType(soap, "ns2:CompanyId", &a->ns2__UnsignedAttributeResponseType::CompanyId, "ns4:NIPCType"))
				{	soap_flag_CompanyId1--;
					continue;
				}
			}
			if (soap_flag_CompanyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons4__CompanyNameType(soap, "ns2:CompanyName", &a->ns2__UnsignedAttributeResponseType::CompanyName, "ns4:CompanyNameType"))
				{	soap_flag_CompanyName1--;
					continue;
				}
			}
			if (soap_flag_AttributeResponseValues1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__UnsignedAttributesType(soap, "ns2:AttributeResponseValues", &a->ns2__UnsignedAttributeResponseType::AttributeResponseValues, "ns2:UnsignedAttributesType"))
				{	soap_flag_AttributeResponseValues1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProcessId1 > 0 || !a->ns2__UnsignedAttributeResponseType::AttributeResponseValues))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__UnsignedAttributeResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__UnsignedAttributeResponseType, SOAP_TYPE_ns2__UnsignedAttributeResponseType, sizeof(ns2__UnsignedAttributeResponseType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__UnsignedAttributeResponseType * SOAP_FMAC2 SCAP_instantiate_ns2__UnsignedAttributeResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns2__UnsignedAttributeResponseType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__UnsignedAttributeResponseType *p;
	size_t k = sizeof(ns2__UnsignedAttributeResponseType);
	if (n < 0)
	{	p = SOAP_NEW(ns2__UnsignedAttributeResponseType);
		if (p)
			((ns2__UnsignedAttributeResponseType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__UnsignedAttributeResponseType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__UnsignedAttributeResponseType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__UnsignedAttributeResponseType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__UnsignedAttributeResponseType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__UnsignedAttributeResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__UnsignedAttributeResponseType(soap, tag ? tag : "ns2:UnsignedAttributeResponseType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__UnsignedAttributeResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__UnsignedAttributeResponseType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__UnsignedAttributeResponseType * SOAP_FMAC4 soap_get_ns2__UnsignedAttributeResponseType(struct soap *soap, ns2__UnsignedAttributeResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__UnsignedAttributeResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__SingleAttributeResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns4__ProcessIDType(soap, &this->ns2__SingleAttributeResponseType::ProcessId);
	this->ns2__SingleAttributeResponseType::AttributeResponseValues = NULL;
	/* transient soap skipped */
}

void ns2__SingleAttributeResponseType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns4__ProcessIDType(soap, &this->ns2__SingleAttributeResponseType::ProcessId);
	soap_serialize_PointerTons2__AttributesType(soap, &this->ns2__SingleAttributeResponseType::AttributeResponseValues);
#endif
}

int ns2__SingleAttributeResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SingleAttributeResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SingleAttributeResponseType(struct soap *soap, const char *tag, int id, const ns2__SingleAttributeResponseType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SingleAttributeResponseType), type))
		return soap->error;
	if (soap_out_ns4__ProcessIDType(soap, "ns2:ProcessId", -1, &a->ns2__SingleAttributeResponseType::ProcessId, ""))
		return soap->error;
	if (!a->ns2__SingleAttributeResponseType::AttributeResponseValues)
	{	if (soap_element_empty(soap, "ns2:AttributeResponseValues"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__AttributesType(soap, "ns2:AttributeResponseValues", -1, &a->ns2__SingleAttributeResponseType::AttributeResponseValues, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__SingleAttributeResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SingleAttributeResponseType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SingleAttributeResponseType * SOAP_FMAC4 soap_in_ns2__SingleAttributeResponseType(struct soap *soap, const char *tag, ns2__SingleAttributeResponseType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SingleAttributeResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SingleAttributeResponseType, sizeof(ns2__SingleAttributeResponseType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__SingleAttributeResponseType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__SingleAttributeResponseType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProcessId1 = 1;
	size_t soap_flag_AttributeResponseValues1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProcessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns4__ProcessIDType(soap, "ns2:ProcessId", &a->ns2__SingleAttributeResponseType::ProcessId, "ns4:ProcessIDType"))
				{	soap_flag_ProcessId1--;
					continue;
				}
			}
			if (soap_flag_AttributeResponseValues1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__AttributesType(soap, "ns2:AttributeResponseValues", &a->ns2__SingleAttributeResponseType::AttributeResponseValues, "ns2:AttributesType"))
				{	soap_flag_AttributeResponseValues1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProcessId1 > 0 || !a->ns2__SingleAttributeResponseType::AttributeResponseValues))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__SingleAttributeResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SingleAttributeResponseType, SOAP_TYPE_ns2__SingleAttributeResponseType, sizeof(ns2__SingleAttributeResponseType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__SingleAttributeResponseType * SOAP_FMAC2 SCAP_instantiate_ns2__SingleAttributeResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns2__SingleAttributeResponseType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__SingleAttributeResponseType *p;
	size_t k = sizeof(ns2__SingleAttributeResponseType);
	if (n < 0)
	{	p = SOAP_NEW(ns2__SingleAttributeResponseType);
		if (p)
			((ns2__SingleAttributeResponseType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__SingleAttributeResponseType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__SingleAttributeResponseType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__SingleAttributeResponseType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__SingleAttributeResponseType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__SingleAttributeResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__SingleAttributeResponseType(soap, tag ? tag : "ns2:SingleAttributeResponseType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SingleAttributeResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SingleAttributeResponseType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SingleAttributeResponseType * SOAP_FMAC4 soap_get_ns2__SingleAttributeResponseType(struct soap *soap, ns2__SingleAttributeResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SingleAttributeResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__AttributeResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns4__ProcessIDType(soap, &this->ns2__AttributeResponseType::ProcessId);
	soap_default_std__vectorTemplateOfPointerTons2__AttributesType(soap, &this->ns2__AttributeResponseType::AttributeResponseValues);
	this->ns2__AttributeResponseType::ErrorMessage = NULL;
	this->ns2__AttributeResponseType::AppId = NULL;
	this->ns2__AttributeResponseType::SecretKey = NULL;
	/* transient soap skipped */
}

void ns2__AttributeResponseType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns4__ProcessIDType(soap, &this->ns2__AttributeResponseType::ProcessId);
	soap_serialize_std__vectorTemplateOfPointerTons2__AttributesType(soap, &this->ns2__AttributeResponseType::AttributeResponseValues);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AttributeResponseType::ErrorMessage);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AttributeResponseType::AppId);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AttributeResponseType::SecretKey);
#endif
}

int ns2__AttributeResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AttributeResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AttributeResponseType(struct soap *soap, const char *tag, int id, const ns2__AttributeResponseType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AttributeResponseType), type))
		return soap->error;
	soap_element_result(soap, "ns2:ProcessId");
	if (soap_out_ns4__ProcessIDType(soap, "ns2:ProcessId", -1, &a->ns2__AttributeResponseType::ProcessId, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__AttributesType(soap, "ns2:AttributeResponseValues", -1, &a->ns2__AttributeResponseType::AttributeResponseValues, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:ErrorMessage", -1, &a->ns2__AttributeResponseType::ErrorMessage, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:AppId", -1, &a->ns2__AttributeResponseType::AppId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:SecretKey", -1, &a->ns2__AttributeResponseType::SecretKey, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__AttributeResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AttributeResponseType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AttributeResponseType * SOAP_FMAC4 soap_in_ns2__AttributeResponseType(struct soap *soap, const char *tag, ns2__AttributeResponseType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AttributeResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AttributeResponseType, sizeof(ns2__AttributeResponseType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__AttributeResponseType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__AttributeResponseType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProcessId1 = 1;
	size_t soap_flag_ErrorMessage1 = 1;
	size_t soap_flag_AppId1 = 1;
	size_t soap_flag_SecretKey1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProcessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns4__ProcessIDType(soap, "ns2:ProcessId", &a->ns2__AttributeResponseType::ProcessId, "ns4:ProcessIDType"))
				{	soap_flag_ProcessId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons2__AttributesType(soap, "ns2:AttributeResponseValues", &a->ns2__AttributeResponseType::AttributeResponseValues, "ns2:AttributesType"))
					continue;
			}
			if (soap_flag_ErrorMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns2:ErrorMessage", &a->ns2__AttributeResponseType::ErrorMessage, "xsd:string"))
				{	soap_flag_ErrorMessage1--;
					continue;
				}
			}
			if (soap_flag_AppId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns2:AppId", &a->ns2__AttributeResponseType::AppId, "xsd:string"))
				{	soap_flag_AppId1--;
					continue;
				}
			}
			if (soap_flag_SecretKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns2:SecretKey", &a->ns2__AttributeResponseType::SecretKey, "xsd:string"))
				{	soap_flag_SecretKey1--;
					continue;
				}
			}
			soap_check_result(soap, "ns2:ProcessId");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProcessId1 > 0 || a->ns2__AttributeResponseType::AttributeResponseValues.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__AttributeResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AttributeResponseType, SOAP_TYPE_ns2__AttributeResponseType, sizeof(ns2__AttributeResponseType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__AttributeResponseType * SOAP_FMAC2 SCAP_instantiate_ns2__AttributeResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns2__AttributeResponseType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__AttributeResponseType *p;
	size_t k = sizeof(ns2__AttributeResponseType);
	if (n < 0)
	{	p = SOAP_NEW(ns2__AttributeResponseType);
		if (p)
			((ns2__AttributeResponseType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__AttributeResponseType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__AttributeResponseType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__AttributeResponseType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__AttributeResponseType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__AttributeResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__AttributeResponseType(soap, tag ? tag : "ns2:AttributeResponseType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AttributeResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AttributeResponseType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AttributeResponseType * SOAP_FMAC4 soap_get_ns2__AttributeResponseType(struct soap *soap, ns2__AttributeResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AttributeResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__AttributeSupplierListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__AttributeSupplierType(soap, &this->ns2__AttributeSupplierListType::AttributeSupplier);
	/* transient soap skipped */
}

void ns2__AttributeSupplierListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__AttributeSupplierType(soap, &this->ns2__AttributeSupplierListType::AttributeSupplier);
#endif
}

int ns2__AttributeSupplierListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AttributeSupplierListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AttributeSupplierListType(struct soap *soap, const char *tag, int id, const ns2__AttributeSupplierListType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AttributeSupplierListType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__AttributeSupplierType(soap, "ns2:AttributeSupplier", -1, &a->ns2__AttributeSupplierListType::AttributeSupplier, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__AttributeSupplierListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AttributeSupplierListType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AttributeSupplierListType * SOAP_FMAC4 soap_in_ns2__AttributeSupplierListType(struct soap *soap, const char *tag, ns2__AttributeSupplierListType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AttributeSupplierListType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AttributeSupplierListType, sizeof(ns2__AttributeSupplierListType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__AttributeSupplierListType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__AttributeSupplierListType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__AttributeSupplierType(soap, "ns2:AttributeSupplier", &a->ns2__AttributeSupplierListType::AttributeSupplier, "ns3:AttributeSupplierType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__AttributeSupplierListType::AttributeSupplier.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__AttributeSupplierListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AttributeSupplierListType, SOAP_TYPE_ns2__AttributeSupplierListType, sizeof(ns2__AttributeSupplierListType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__AttributeSupplierListType * SOAP_FMAC2 SCAP_instantiate_ns2__AttributeSupplierListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns2__AttributeSupplierListType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__AttributeSupplierListType *p;
	size_t k = sizeof(ns2__AttributeSupplierListType);
	if (n < 0)
	{	p = SOAP_NEW(ns2__AttributeSupplierListType);
		if (p)
			((ns2__AttributeSupplierListType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__AttributeSupplierListType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__AttributeSupplierListType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__AttributeSupplierListType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__AttributeSupplierListType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__AttributeSupplierListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__AttributeSupplierListType(soap, tag ? tag : "ns2:AttributeSupplierListType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AttributeSupplierListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AttributeSupplierListType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AttributeSupplierListType * SOAP_FMAC4 soap_get_ns2__AttributeSupplierListType(struct soap *soap, ns2__AttributeSupplierListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AttributeSupplierListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PSAAttributeRequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns4__ProcessIDType(soap, &this->ns2__PSAAttributeRequestType::ProcessId);
	this->ns2__PSAAttributeRequestType::Citizen = NULL;
	this->ns2__PSAAttributeRequestType::CompanyId = NULL;
	this->ns2__PSAAttributeRequestType::CompanyName = NULL;
	/* transient soap skipped */
}

void ns2__PSAAttributeRequestType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns4__ProcessIDType(soap, &this->ns2__PSAAttributeRequestType::ProcessId);
	soap_serialize_PointerTons3__PersonalDataType(soap, &this->ns2__PSAAttributeRequestType::Citizen);
	soap_serialize_PointerTons4__NIPCType(soap, &this->ns2__PSAAttributeRequestType::CompanyId);
	soap_serialize_PointerTons4__CompanyNameType(soap, &this->ns2__PSAAttributeRequestType::CompanyName);
#endif
}

int ns2__PSAAttributeRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PSAAttributeRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PSAAttributeRequestType(struct soap *soap, const char *tag, int id, const ns2__PSAAttributeRequestType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PSAAttributeRequestType), type))
		return soap->error;
	if (soap_out_ns4__ProcessIDType(soap, "ns2:ProcessId", -1, &a->ns2__PSAAttributeRequestType::ProcessId, ""))
		return soap->error;
	if (!a->ns2__PSAAttributeRequestType::Citizen)
	{	if (soap_element_empty(soap, "ns2:Citizen"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__PersonalDataType(soap, "ns2:Citizen", -1, &a->ns2__PSAAttributeRequestType::Citizen, ""))
		return soap->error;
	if (soap_out_PointerTons4__NIPCType(soap, "ns2:CompanyId", -1, &a->ns2__PSAAttributeRequestType::CompanyId, ""))
		return soap->error;
	if (soap_out_PointerTons4__CompanyNameType(soap, "ns2:CompanyName", -1, &a->ns2__PSAAttributeRequestType::CompanyName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PSAAttributeRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PSAAttributeRequestType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PSAAttributeRequestType * SOAP_FMAC4 soap_in_ns2__PSAAttributeRequestType(struct soap *soap, const char *tag, ns2__PSAAttributeRequestType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PSAAttributeRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PSAAttributeRequestType, sizeof(ns2__PSAAttributeRequestType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PSAAttributeRequestType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PSAAttributeRequestType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProcessId1 = 1;
	size_t soap_flag_Citizen1 = 1;
	size_t soap_flag_CompanyId1 = 1;
	size_t soap_flag_CompanyName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProcessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns4__ProcessIDType(soap, "ns2:ProcessId", &a->ns2__PSAAttributeRequestType::ProcessId, "ns4:ProcessIDType"))
				{	soap_flag_ProcessId1--;
					continue;
				}
			}
			if (soap_flag_Citizen1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__PersonalDataType(soap, "ns2:Citizen", &a->ns2__PSAAttributeRequestType::Citizen, "ns3:PersonalDataType"))
				{	soap_flag_Citizen1--;
					continue;
				}
			}
			if (soap_flag_CompanyId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons4__NIPCType(soap, "ns2:CompanyId", &a->ns2__PSAAttributeRequestType::CompanyId, "ns4:NIPCType"))
				{	soap_flag_CompanyId1--;
					continue;
				}
			}
			if (soap_flag_CompanyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTons4__CompanyNameType(soap, "ns2:CompanyName", &a->ns2__PSAAttributeRequestType::CompanyName, "ns4:CompanyNameType"))
				{	soap_flag_CompanyName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProcessId1 > 0 || !a->ns2__PSAAttributeRequestType::Citizen))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PSAAttributeRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PSAAttributeRequestType, SOAP_TYPE_ns2__PSAAttributeRequestType, sizeof(ns2__PSAAttributeRequestType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PSAAttributeRequestType * SOAP_FMAC2 SCAP_instantiate_ns2__PSAAttributeRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns2__PSAAttributeRequestType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PSAAttributeRequestType *p;
	size_t k = sizeof(ns2__PSAAttributeRequestType);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PSAAttributeRequestType);
		if (p)
			((ns2__PSAAttributeRequestType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PSAAttributeRequestType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PSAAttributeRequestType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PSAAttributeRequestType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PSAAttributeRequestType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PSAAttributeRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__PSAAttributeRequestType(soap, tag ? tag : "ns2:PSAAttributeRequestType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PSAAttributeRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PSAAttributeRequestType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PSAAttributeRequestType * SOAP_FMAC4 soap_get_ns2__PSAAttributeRequestType(struct soap *soap, ns2__PSAAttributeRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PSAAttributeRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__SingleAttributeRequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns4__ProcessIDType(soap, &this->ns2__SingleAttributeRequestType::ProcessId);
	this->ns2__SingleAttributeRequestType::Citizen = NULL;
	this->ns2__SingleAttributeRequestType::AttributeSuppliers = NULL;
	/* transient soap skipped */
}

void ns2__SingleAttributeRequestType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns4__ProcessIDType(soap, &this->ns2__SingleAttributeRequestType::ProcessId);
	soap_serialize_PointerTons3__PersonalDataType(soap, &this->ns2__SingleAttributeRequestType::Citizen);
	soap_serialize_PointerTons3__AttributeSupplierType(soap, &this->ns2__SingleAttributeRequestType::AttributeSuppliers);
#endif
}

int ns2__SingleAttributeRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SingleAttributeRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SingleAttributeRequestType(struct soap *soap, const char *tag, int id, const ns2__SingleAttributeRequestType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SingleAttributeRequestType), type))
		return soap->error;
	if (soap_out_ns4__ProcessIDType(soap, "ns2:ProcessId", -1, &a->ns2__SingleAttributeRequestType::ProcessId, ""))
		return soap->error;
	if (!a->ns2__SingleAttributeRequestType::Citizen)
	{	if (soap_element_empty(soap, "ns2:Citizen"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__PersonalDataType(soap, "ns2:Citizen", -1, &a->ns2__SingleAttributeRequestType::Citizen, ""))
		return soap->error;
	if (!a->ns2__SingleAttributeRequestType::AttributeSuppliers)
	{	if (soap_element_empty(soap, "ns2:AttributeSuppliers"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__AttributeSupplierType(soap, "ns2:AttributeSuppliers", -1, &a->ns2__SingleAttributeRequestType::AttributeSuppliers, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__SingleAttributeRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SingleAttributeRequestType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SingleAttributeRequestType * SOAP_FMAC4 soap_in_ns2__SingleAttributeRequestType(struct soap *soap, const char *tag, ns2__SingleAttributeRequestType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SingleAttributeRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SingleAttributeRequestType, sizeof(ns2__SingleAttributeRequestType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__SingleAttributeRequestType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__SingleAttributeRequestType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProcessId1 = 1;
	size_t soap_flag_Citizen1 = 1;
	size_t soap_flag_AttributeSuppliers1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProcessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns4__ProcessIDType(soap, "ns2:ProcessId", &a->ns2__SingleAttributeRequestType::ProcessId, "ns4:ProcessIDType"))
				{	soap_flag_ProcessId1--;
					continue;
				}
			}
			if (soap_flag_Citizen1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__PersonalDataType(soap, "ns2:Citizen", &a->ns2__SingleAttributeRequestType::Citizen, "ns3:PersonalDataType"))
				{	soap_flag_Citizen1--;
					continue;
				}
			}
			if (soap_flag_AttributeSuppliers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__AttributeSupplierType(soap, "ns2:AttributeSuppliers", &a->ns2__SingleAttributeRequestType::AttributeSuppliers, "ns3:AttributeSupplierType"))
				{	soap_flag_AttributeSuppliers1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProcessId1 > 0 || !a->ns2__SingleAttributeRequestType::Citizen || !a->ns2__SingleAttributeRequestType::AttributeSuppliers))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__SingleAttributeRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SingleAttributeRequestType, SOAP_TYPE_ns2__SingleAttributeRequestType, sizeof(ns2__SingleAttributeRequestType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__SingleAttributeRequestType * SOAP_FMAC2 SCAP_instantiate_ns2__SingleAttributeRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns2__SingleAttributeRequestType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__SingleAttributeRequestType *p;
	size_t k = sizeof(ns2__SingleAttributeRequestType);
	if (n < 0)
	{	p = SOAP_NEW(ns2__SingleAttributeRequestType);
		if (p)
			((ns2__SingleAttributeRequestType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__SingleAttributeRequestType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__SingleAttributeRequestType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__SingleAttributeRequestType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__SingleAttributeRequestType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__SingleAttributeRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__SingleAttributeRequestType(soap, tag ? tag : "ns2:SingleAttributeRequestType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SingleAttributeRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SingleAttributeRequestType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SingleAttributeRequestType * SOAP_FMAC4 soap_get_ns2__SingleAttributeRequestType(struct soap *soap, ns2__SingleAttributeRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SingleAttributeRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__AttributeRequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns4__ProcessIDType(soap, &this->ns2__AttributeRequestType::ProcessId);
	this->ns2__AttributeRequestType::Citizen = NULL;
	this->ns2__AttributeRequestType::AttributeSuppliers = NULL;
	this->ns2__AttributeRequestType::AllEnterprises = NULL;
	this->ns2__AttributeRequestType::AppId = NULL;
	this->ns2__AttributeRequestType::AppName = NULL;
	this->ns2__AttributeRequestType::SecretKey = NULL;
	/* transient soap skipped */
}

void ns2__AttributeRequestType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns4__ProcessIDType(soap, &this->ns2__AttributeRequestType::ProcessId);
	soap_serialize_PointerTons3__PersonalDataType(soap, &this->ns2__AttributeRequestType::Citizen);
	soap_serialize_PointerTons2__AttributeSupplierListType(soap, &this->ns2__AttributeRequestType::AttributeSuppliers);
	soap_serialize_PointerTobool(soap, &this->ns2__AttributeRequestType::AllEnterprises);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AttributeRequestType::AppId);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AttributeRequestType::AppName);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AttributeRequestType::SecretKey);
#endif
}

int ns2__AttributeRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AttributeRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AttributeRequestType(struct soap *soap, const char *tag, int id, const ns2__AttributeRequestType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AttributeRequestType), type))
		return soap->error;
	if (soap_out_ns4__ProcessIDType(soap, "ns2:ProcessId", -1, &a->ns2__AttributeRequestType::ProcessId, ""))
		return soap->error;
	if (!a->ns2__AttributeRequestType::Citizen)
	{	if (soap_element_empty(soap, "ns2:Citizen"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__PersonalDataType(soap, "ns2:Citizen", -1, &a->ns2__AttributeRequestType::Citizen, ""))
		return soap->error;
	if (!a->ns2__AttributeRequestType::AttributeSuppliers)
	{	if (soap_element_empty(soap, "ns2:AttributeSuppliers"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__AttributeSupplierListType(soap, "ns2:AttributeSuppliers", -1, &a->ns2__AttributeRequestType::AttributeSuppliers, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns2:AllEnterprises", -1, &a->ns2__AttributeRequestType::AllEnterprises, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:AppId", -1, &a->ns2__AttributeRequestType::AppId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:AppName", -1, &a->ns2__AttributeRequestType::AppName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:SecretKey", -1, &a->ns2__AttributeRequestType::SecretKey, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__AttributeRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AttributeRequestType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AttributeRequestType * SOAP_FMAC4 soap_in_ns2__AttributeRequestType(struct soap *soap, const char *tag, ns2__AttributeRequestType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AttributeRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AttributeRequestType, sizeof(ns2__AttributeRequestType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__AttributeRequestType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__AttributeRequestType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProcessId1 = 1;
	size_t soap_flag_Citizen1 = 1;
	size_t soap_flag_AttributeSuppliers1 = 1;
	size_t soap_flag_AllEnterprises1 = 1;
	size_t soap_flag_AppId1 = 1;
	size_t soap_flag_AppName1 = 1;
	size_t soap_flag_SecretKey1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProcessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_ns4__ProcessIDType(soap, "ns2:ProcessId", &a->ns2__AttributeRequestType::ProcessId, "ns4:ProcessIDType"))
				{	soap_flag_ProcessId1--;
					continue;
				}
			}
			if (soap_flag_Citizen1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__PersonalDataType(soap, "ns2:Citizen", &a->ns2__AttributeRequestType::Citizen, "ns3:PersonalDataType"))
				{	soap_flag_Citizen1--;
					continue;
				}
			}
			if (soap_flag_AttributeSuppliers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__AttributeSupplierListType(soap, "ns2:AttributeSuppliers", &a->ns2__AttributeRequestType::AttributeSuppliers, "ns2:AttributeSupplierListType"))
				{	soap_flag_AttributeSuppliers1--;
					continue;
				}
			}
			if (soap_flag_AllEnterprises1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns2:AllEnterprises", &a->ns2__AttributeRequestType::AllEnterprises, "xsd:boolean"))
				{	soap_flag_AllEnterprises1--;
					continue;
				}
			}
			if (soap_flag_AppId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns2:AppId", &a->ns2__AttributeRequestType::AppId, "xsd:string"))
				{	soap_flag_AppId1--;
					continue;
				}
			}
			if (soap_flag_AppName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns2:AppName", &a->ns2__AttributeRequestType::AppName, "xsd:string"))
				{	soap_flag_AppName1--;
					continue;
				}
			}
			if (soap_flag_SecretKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns2:SecretKey", &a->ns2__AttributeRequestType::SecretKey, "xsd:string"))
				{	soap_flag_SecretKey1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProcessId1 > 0 || !a->ns2__AttributeRequestType::Citizen || !a->ns2__AttributeRequestType::AttributeSuppliers))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__AttributeRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AttributeRequestType, SOAP_TYPE_ns2__AttributeRequestType, sizeof(ns2__AttributeRequestType), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__AttributeRequestType * SOAP_FMAC2 SCAP_instantiate_ns2__AttributeRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_ns2__AttributeRequestType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__AttributeRequestType *p;
	size_t k = sizeof(ns2__AttributeRequestType);
	if (n < 0)
	{	p = SOAP_NEW(ns2__AttributeRequestType);
		if (p)
			((ns2__AttributeRequestType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__AttributeRequestType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__AttributeRequestType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__AttributeRequestType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__AttributeRequestType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__AttributeRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__AttributeRequestType(soap, tag ? tag : "ns2:AttributeRequestType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AttributeRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AttributeRequestType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AttributeRequestType * SOAP_FMAC4 soap_get_ns2__AttributeRequestType(struct soap *soap, ns2__AttributeRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AttributeRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__integer(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__integer), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__integer(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[-+]?\\d+")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase), 0, SOAP_TYPE_xsd__integer, SOAP_TYPE_xsd__integer, sizeof(std::string), 0, SCAP_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__integer(soap, tag ? tag : "xsd:integer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__date(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__date(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__date), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__date(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__date, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[-+]?\\d{4,}-\\d{2}-\\d{2}(Z|[-+]\\d{2}:\\d{2})?")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__date, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase), 0, SOAP_TYPE_xsd__date, SOAP_TYPE_xsd__date, sizeof(std::string), 0, SCAP_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__date(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__date(soap, tag ? tag : "xsd:date", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__date(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anyURI), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 4, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase), 0, SOAP_TYPE_xsd__anyURI, SOAP_TYPE_xsd__anyURI, sizeof(std::string), 0, SCAP_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__ID(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__ID(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__ID), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__ID(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__ID, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[\\i-[:]][\\c-[:]]*")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__ID, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase), 0, SOAP_TYPE_xsd__ID, SOAP_TYPE_xsd__ID, sizeof(std::string), 0, SCAP_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__ID(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__ID(soap, tag ? tag : "xsd:ID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__ID(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, SCAP_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 SCAP_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	if (n < 0)
	{	p = SOAP_NEW(std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__string, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr)
		(void)soap_attachment_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_xsd__base64Binary, this->id, this->type);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__base64Binary2s(struct soap *soap, xsd__base64Binary a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_xsd__base64Binary, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__base64Binary(struct soap *soap, const char *s, xsd__base64Binary *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0, SCAP_finsert, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 SCAP_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_xsd__base64Binary(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__base64Binary *p;
	size_t k = sizeof(xsd__base64Binary);
	if (n < 0)
	{	p = SOAP_NEW(xsd__base64Binary);
		if (p)
			((xsd__base64Binary*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(xsd__base64Binary, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((xsd__base64Binary*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__base64Binary location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xsd__base64Binary, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__base64Binary(soap, tag ? tag : "xsd:base64Binary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns8__AttributeSuppliers(struct soap *soap, struct __ns8__AttributeSuppliers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns8__AttributeSuppliers(struct soap *soap, const struct __ns8__AttributeSuppliers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns8__AttributeSuppliers(struct soap *soap, const char *tag, int id, const struct __ns8__AttributeSuppliers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__AttributeSuppliers * SOAP_FMAC4 soap_in___ns8__AttributeSuppliers(struct soap *soap, const char *tag, struct __ns8__AttributeSuppliers *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns8__AttributeSuppliers *)soap_id_enter(soap, "", a, SOAP_TYPE___ns8__AttributeSuppliers, sizeof(struct __ns8__AttributeSuppliers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns8__AttributeSuppliers(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __ns8__AttributeSuppliers * SOAP_FMAC2 SCAP_instantiate___ns8__AttributeSuppliers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate___ns8__AttributeSuppliers(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns8__AttributeSuppliers *p;
	size_t k = sizeof(struct __ns8__AttributeSuppliers);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns8__AttributeSuppliers);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns8__AttributeSuppliers, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns8__AttributeSuppliers location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns8__AttributeSuppliers, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns8__AttributeSuppliers(struct soap *soap, const struct __ns8__AttributeSuppliers *a, const char *tag, const char *type)
{
	if (soap_out___ns8__AttributeSuppliers(soap, tag ? tag : "-ns8:AttributeSuppliers", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns8__AttributeSuppliers * SOAP_FMAC4 soap_get___ns8__AttributeSuppliers(struct soap *soap, struct __ns8__AttributeSuppliers *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns8__AttributeSuppliers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__Signature(struct soap *soap, struct __ns3__Signature *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SignatureRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__Signature(struct soap *soap, const struct __ns3__Signature *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SignatureRequest(soap, &a->ns1__SignatureRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__Signature(struct soap *soap, const char *tag, int id, const struct __ns3__Signature *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SignatureRequest(soap, "ns1:SignatureRequest", -1, &a->ns1__SignatureRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__Signature * SOAP_FMAC4 soap_in___ns3__Signature(struct soap *soap, const char *tag, struct __ns3__Signature *a, const char *type)
{
	size_t soap_flag_ns1__SignatureRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__Signature *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__Signature, sizeof(struct __ns3__Signature), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__Signature(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SignatureRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SignatureRequest(soap, "ns1:SignatureRequest", &a->ns1__SignatureRequest, ""))
				{	soap_flag_ns1__SignatureRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__Signature * SOAP_FMAC2 SCAP_instantiate___ns3__Signature(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate___ns3__Signature(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__Signature *p;
	size_t k = sizeof(struct __ns3__Signature);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns3__Signature);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns3__Signature, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__Signature location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns3__Signature, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__Signature(struct soap *soap, const struct __ns3__Signature *a, const char *tag, const char *type)
{
	if (soap_out___ns3__Signature(soap, tag ? tag : "-ns3:Signature", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__Signature * SOAP_FMAC4 soap_get___ns3__Signature(struct soap *soap, struct __ns3__Signature *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__Signature(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__Authorization(struct soap *soap, struct __ns2__Authorization *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AuthorizationRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__Authorization(struct soap *soap, const struct __ns2__Authorization *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__AuthorizationRequest(soap, &a->ns1__AuthorizationRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__Authorization(struct soap *soap, const char *tag, int id, const struct __ns2__Authorization *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__AuthorizationRequest(soap, "ns1:AuthorizationRequest", -1, &a->ns1__AuthorizationRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__Authorization * SOAP_FMAC4 soap_in___ns2__Authorization(struct soap *soap, const char *tag, struct __ns2__Authorization *a, const char *type)
{
	size_t soap_flag_ns1__AuthorizationRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns2__Authorization *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__Authorization, sizeof(struct __ns2__Authorization), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__Authorization(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AuthorizationRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__AuthorizationRequest(soap, "ns1:AuthorizationRequest", &a->ns1__AuthorizationRequest, ""))
				{	soap_flag_ns1__AuthorizationRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns2__Authorization * SOAP_FMAC2 SCAP_instantiate___ns2__Authorization(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate___ns2__Authorization(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns2__Authorization *p;
	size_t k = sizeof(struct __ns2__Authorization);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns2__Authorization);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns2__Authorization, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns2__Authorization location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns2__Authorization, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__Authorization(struct soap *soap, const struct __ns2__Authorization *a, const char *tag, const char *type)
{
	if (soap_out___ns2__Authorization(soap, tag ? tag : "-ns2:Authorization", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__Authorization * SOAP_FMAC4 soap_get___ns2__Authorization(struct soap *soap, struct __ns2__Authorization *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__Authorization(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Attributes(struct soap *soap, struct __ns1__Attributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__AttributeRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Attributes(struct soap *soap, const struct __ns1__Attributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__AttributeRequestType(soap, &a->ns2__AttributeRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Attributes(struct soap *soap, const char *tag, int id, const struct __ns1__Attributes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__AttributeRequestType(soap, "ns2:AttributeRequest", -1, &a->ns2__AttributeRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Attributes * SOAP_FMAC4 soap_in___ns1__Attributes(struct soap *soap, const char *tag, struct __ns1__Attributes *a, const char *type)
{
	size_t soap_flag_ns2__AttributeRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Attributes *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Attributes, sizeof(struct __ns1__Attributes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Attributes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__AttributeRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__AttributeRequestType(soap, "ns2:AttributeRequest", &a->ns2__AttributeRequest, "ns2:AttributeRequestType"))
				{	soap_flag_ns2__AttributeRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Attributes * SOAP_FMAC2 SCAP_instantiate___ns1__Attributes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate___ns1__Attributes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Attributes *p;
	size_t k = sizeof(struct __ns1__Attributes);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Attributes);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Attributes, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Attributes location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__Attributes, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Attributes(struct soap *soap, const struct __ns1__Attributes *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Attributes(soap, tag ? tag : "-ns1:Attributes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Attributes * SOAP_FMAC4 soap_get___ns1__Attributes(struct soap *soap, struct __ns1__Attributes *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Attributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, SCAP_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 SCAP_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Fault, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, SCAP_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 SCAP_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Reason, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, SCAP_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 SCAP_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Code, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, SCAP_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 SCAP_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Detail, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__MessageID(soap, &a->wsa__MessageID);
	a->wsa__RelatesTo = NULL;
	a->wsa__From = NULL;
	a->wsa__ReplyTo = NULL;
	a->wsa__FaultTo = NULL;
	soap_default__wsa__To(soap, &a->wsa__To);
	soap_default__wsa__Action(soap, &a->wsa__Action);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa__MessageID(soap, (char*const*)&a->wsa__MessageID);
	soap_serialize_PointerTo_wsa__RelatesTo(soap, &a->wsa__RelatesTo);
	soap_serialize_PointerTo_wsa__From(soap, &a->wsa__From);
	soap_serialize_PointerTo_wsa__ReplyTo(soap, &a->wsa__ReplyTo);
	soap_serialize_PointerTo_wsa__FaultTo(soap, &a->wsa__FaultTo);
	soap_serialize__wsa__To(soap, (char*const*)&a->wsa__To);
	soap_serialize__wsa__Action(soap, (char*const*)&a->wsa__Action);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	if (soap_out__wsa__MessageID(soap, "wsa:MessageID", -1, (char*const*)&a->wsa__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa__RelatesTo(soap, "wsa:RelatesTo", -1, &a->wsa__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa__From(soap, "wsa:From", -1, &a->wsa__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa__ReplyTo(soap, "wsa:ReplyTo", -1, &a->wsa__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa__FaultTo(soap, "wsa:FaultTo", -1, &a->wsa__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa__To(soap, "wsa:To", -1, (char*const*)&a->wsa__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa__Action(soap, "wsa:Action", -1, (char*const*)&a->wsa__Action, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsa__MessageID = 1;
	size_t soap_flag_wsa__RelatesTo = 1;
	size_t soap_flag_wsa__From = 1;
	size_t soap_flag_wsa__ReplyTo = 1;
	size_t soap_flag_wsa__FaultTo = 1;
	size_t soap_flag_wsa__To = 1;
	size_t soap_flag_wsa__Action = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa__MessageID(soap, "wsa:MessageID", (char**)&a->wsa__MessageID, ""))
				{	soap_flag_wsa__MessageID--;
					continue;
				}
			}
			if (soap_flag_wsa__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa__RelatesTo(soap, "wsa:RelatesTo", &a->wsa__RelatesTo, ""))
				{	soap_flag_wsa__RelatesTo--;
					continue;
				}
			}
			if (soap_flag_wsa__From && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa__From(soap, "wsa:From", &a->wsa__From, ""))
				{	soap_flag_wsa__From--;
					continue;
				}
			}
			if (soap_flag_wsa__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa__ReplyTo(soap, "wsa:ReplyTo", &a->wsa__ReplyTo, ""))
				{	soap_flag_wsa__ReplyTo--;
					continue;
				}
			}
			if (soap_flag_wsa__FaultTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa__FaultTo(soap, "wsa:FaultTo", &a->wsa__FaultTo, ""))
				{	soap_flag_wsa__FaultTo--;
					continue;
				}
			}
			if (soap_flag_wsa__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa__To(soap, "wsa:To", (char**)&a->wsa__To, ""))
				{	soap_flag_wsa__To--;
					continue;
				}
			}
			if (soap_flag_wsa__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa__Action(soap, "wsa:Action", (char**)&a->wsa__Action, ""))
				{	soap_flag_wsa__Action--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, SCAP_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 SCAP_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Header, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__Relationship(struct soap *soap, struct wsa__Relationship *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__QName(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__Relationship(struct soap *soap, const struct wsa__Relationship *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__Relationship(struct soap *soap, const char *tag, int id, const struct wsa__Relationship *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", soap__QName2s(soap, a->RelationshipType), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct wsa__Relationship * SOAP_FMAC4 soap_in_wsa__Relationship(struct soap *soap, const char *tag, struct wsa__Relationship *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__Relationship *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__Relationship, sizeof(struct wsa__Relationship), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__Relationship(soap, a);
	if (soap_s2_QName(soap, soap_attr_value(soap, "RelationshipType", 2, 0), &a->RelationshipType))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "wsa:Relationship"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct wsa__Relationship * SOAP_FMAC2 SCAP_instantiate_wsa__Relationship(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_wsa__Relationship(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa__Relationship *p;
	size_t k = sizeof(struct wsa__Relationship);
	if (n < 0)
	{	p = SOAP_NEW(struct wsa__Relationship);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct wsa__Relationship, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa__Relationship location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsa__Relationship, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__Relationship(struct soap *soap, const struct wsa__Relationship *a, const char *tag, const char *type)
{
	if (soap_out_wsa__Relationship(soap, tag ? tag : "wsa:Relationship", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__Relationship * SOAP_FMAC4 soap_get_wsa__Relationship(struct soap *soap, struct wsa__Relationship *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__Relationship(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->__item);
	soap_default_string(soap, &a->PortName);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ServiceNameType(struct soap *soap, const struct wsa__ServiceNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ServiceNameType(struct soap *soap, const char *tag, int id, const struct wsa__ServiceNameType *a, const char *type)
{
	const char *soap_tmp___item = soap_QName2s(soap, a->__item);
	if (a->PortName)
		soap_set_attr(soap, "PortName", soap_string2s(soap, a->PortName), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out__QName(soap, tag, id, (char*const*)(void*)&soap_tmp___item, "");
}

SOAP_FMAC3 struct wsa__ServiceNameType * SOAP_FMAC4 soap_in_wsa__ServiceNameType(struct soap *soap, const char *tag, struct wsa__ServiceNameType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__ServiceNameType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ServiceNameType, sizeof(struct wsa__ServiceNameType), soap->type, soap->arrayType, SCAP_instantiate, SCAP_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__ServiceNameType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PortName", 1, 0), &a->PortName))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (!soap_in__QName(soap, tag, (char**)&a->__item, "wsa:ServiceNameType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct wsa__ServiceNameType * SOAP_FMAC2 SCAP_instantiate_wsa__ServiceNameType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_wsa__ServiceNameType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa__ServiceNameType *p;
	size_t k = sizeof(struct wsa__ServiceNameType);
	if (n < 0)
	{	p = SOAP_NEW(struct wsa__ServiceNameType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct wsa__ServiceNameType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa__ServiceNameType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsa__ServiceNameType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ServiceNameType(struct soap *soap, const struct wsa__ServiceNameType *a, const char *tag, const char *type)
{
	if (soap_out_wsa__ServiceNameType(soap, tag ? tag : "wsa:ServiceNameType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ServiceNameType * SOAP_FMAC4 soap_get_wsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ServiceNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ReferenceParametersType(struct soap *soap, const struct wsa__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa__ReferenceParametersType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ReferenceParametersType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa__ReferenceParametersType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__ReferenceParametersType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__ReferenceParametersType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferenceParametersType, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), 0, SCAP_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa__ReferenceParametersType * SOAP_FMAC2 SCAP_instantiate_wsa__ReferenceParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_wsa__ReferenceParametersType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa__ReferenceParametersType *p;
	size_t k = sizeof(struct wsa__ReferenceParametersType);
	if (n < 0)
	{	p = SOAP_NEW(struct wsa__ReferenceParametersType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct wsa__ReferenceParametersType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa__ReferenceParametersType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsa__ReferenceParametersType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ReferenceParametersType(struct soap *soap, const struct wsa__ReferenceParametersType *a, const char *tag, const char *type)
{
	if (soap_out_wsa__ReferenceParametersType(soap, tag ? tag : "wsa:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ReferencePropertiesType(struct soap *soap, const struct wsa__ReferencePropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ReferencePropertiesType(struct soap *soap, const char *tag, int id, const struct wsa__ReferencePropertiesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ReferencePropertiesType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType * SOAP_FMAC4 soap_in_wsa__ReferencePropertiesType(struct soap *soap, const char *tag, struct wsa__ReferencePropertiesType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__ReferencePropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(struct wsa__ReferencePropertiesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__ReferencePropertiesType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferencePropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferencePropertiesType, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(struct wsa__ReferencePropertiesType), 0, SCAP_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa__ReferencePropertiesType * SOAP_FMAC2 SCAP_instantiate_wsa__ReferencePropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_wsa__ReferencePropertiesType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa__ReferencePropertiesType *p;
	size_t k = sizeof(struct wsa__ReferencePropertiesType);
	if (n < 0)
	{	p = SOAP_NEW(struct wsa__ReferencePropertiesType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct wsa__ReferencePropertiesType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa__ReferencePropertiesType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsa__ReferencePropertiesType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ReferencePropertiesType(struct soap *soap, const struct wsa__ReferencePropertiesType *a, const char *tag, const char *type)
{
	if (soap_out_wsa__ReferencePropertiesType(soap, tag ? tag : "wsa:ReferencePropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType * SOAP_FMAC4 soap_get_wsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ReferencePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceProperties = NULL;
	a->ReferenceParameters = NULL;
	a->PortType = NULL;
	a->ServiceName = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__EndpointReferenceType(struct soap *soap, const struct wsa__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Address);
	soap_serialize_PointerTowsa__ReferencePropertiesType(soap, &a->ReferenceProperties);
	soap_serialize_PointerTowsa__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTo_QName(soap, &a->PortType);
	soap_serialize_PointerTowsa__ServiceNameType(soap, &a->ServiceName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa__EndpointReferenceType *a, const char *type)
{
	const char *soap_tmp_PortType = a->PortType ? soap_QName2s(soap, *a->PortType) : NULL;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__EndpointReferenceType), type))
		return soap->error;
	if (!a->Address)
	{	if (soap_element_empty(soap, "wsa:Address"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "wsa:Address", -1, (char*const*)&a->Address, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ReferencePropertiesType(soap, "wsa:ReferenceProperties", -1, &a->ReferenceProperties, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out__QName(soap, "wsa:PortType", -1, (char*const*)(void*)&soap_tmp_PortType, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ServiceNameType(soap, "wsa:ServiceName", -1, &a->ServiceName, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceProperties = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_PortType = 1;
	size_t soap_flag_ServiceName = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(struct wsa__EndpointReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__EndpointReferenceType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa:Address", (char**)&a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			}
			if (soap_flag_ReferenceProperties && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa__ReferencePropertiesType(soap, "wsa:ReferenceProperties", &a->ReferenceProperties, "wsa:ReferencePropertiesType"))
				{	soap_flag_ReferenceProperties--;
					continue;
				}
			}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", &a->ReferenceParameters, "wsa:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			}
			if (soap_flag_PortType && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_QName(soap, "wsa:PortType", &a->PortType, ""))
				{	soap_flag_PortType--;
					continue;
				}
			}
			if (soap_flag_ServiceName && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa__ServiceNameType(soap, "wsa:ServiceName", &a->ServiceName, "wsa:ServiceNameType"))
				{	soap_flag_ServiceName--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Address))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__EndpointReferenceType, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(struct wsa__EndpointReferenceType), 0, SCAP_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa__EndpointReferenceType * SOAP_FMAC2 SCAP_instantiate_wsa__EndpointReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_wsa__EndpointReferenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa__EndpointReferenceType *p;
	size_t k = sizeof(struct wsa__EndpointReferenceType);
	if (n < 0)
	{	p = SOAP_NEW(struct wsa__EndpointReferenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct wsa__EndpointReferenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa__EndpointReferenceType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsa__EndpointReferenceType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__EndpointReferenceType(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_wsa__EndpointReferenceType(soap, tag ? tag : "wsa:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__union_ObjectType(struct soap *soap, int choice, const union _ns5__union_ObjectType *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns5__union_ObjectType_ns6__QualifyingProperties:
		soap_serialize_PointerTons6__QualifyingPropertiesType(soap, &a->ns6__QualifyingProperties);
		break;
	case SOAP_UNION__ns5__union_ObjectType_ns7__SVGList:
		soap_serialize_PointerTons7__SVGListType(soap, &a->ns7__SVGList);
		break;
	case SOAP_UNION__ns5__union_ObjectType_ns3__Attribute:
		soap_serialize_PointerTons3__AttributeType(soap, &a->ns3__Attribute);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__union_ObjectType(struct soap *soap, int choice, const union _ns5__union_ObjectType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns5__union_ObjectType_ns6__QualifyingProperties:
		return soap_out_PointerTons6__QualifyingPropertiesType(soap, "ns6:QualifyingProperties", -1, &a->ns6__QualifyingProperties, "");
	case SOAP_UNION__ns5__union_ObjectType_ns7__SVGList:
		return soap_out_PointerTons7__SVGListType(soap, "ns7:SVGList", -1, &a->ns7__SVGList, "");
	case SOAP_UNION__ns5__union_ObjectType_ns3__Attribute:
		return soap_out_PointerTons3__AttributeType(soap, "ns3:Attribute", -1, &a->ns3__Attribute, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns5__union_ObjectType * SOAP_FMAC4 soap_in__ns5__union_ObjectType(struct soap *soap, int *choice, union _ns5__union_ObjectType *a)
{
	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
	a->ns6__QualifyingProperties = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons6__QualifyingPropertiesType(soap, "ns6:QualifyingProperties", &a->ns6__QualifyingProperties, "ns6:QualifyingPropertiesType"))
	{	*choice = SOAP_UNION__ns5__union_ObjectType_ns6__QualifyingProperties;
		return a;
	}
	a->ns7__SVGList = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons7__SVGListType(soap, "ns7:SVGList", &a->ns7__SVGList, "ns7:SVGListType"))
	{	*choice = SOAP_UNION__ns5__union_ObjectType_ns7__SVGList;
		return a;
	}
	a->ns3__Attribute = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons3__AttributeType(soap, "ns3:Attribute", &a->ns3__Attribute, "ns3:AttributeType"))
	{	*choice = SOAP_UNION__ns5__union_ObjectType_ns3__Attribute;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SignatureRequest(struct soap *soap, _ns1__SignatureRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SignatureRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SignatureRequest(struct soap *soap, const char *tag, int id, _ns1__SignatureRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SignatureRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SignatureRequest ? type : NULL);
}

SOAP_FMAC3 _ns1__SignatureRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__SignatureRequest(struct soap *soap, const char *tag, _ns1__SignatureRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SignatureRequest **)soap_malloc(soap, sizeof(_ns1__SignatureRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SignatureRequest *)SCAP_instantiate__ns1__SignatureRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SignatureRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SignatureRequest, sizeof(_ns1__SignatureRequest), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SignatureRequest(struct soap *soap, _ns1__SignatureRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SignatureRequest(soap, tag ? tag : "ns1:SignatureRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SignatureRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__SignatureRequest(struct soap *soap, _ns1__SignatureRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SignatureRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AuthorizationRequest(struct soap *soap, _ns1__AuthorizationRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AuthorizationRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AuthorizationRequest(struct soap *soap, const char *tag, int id, _ns1__AuthorizationRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AuthorizationRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__AuthorizationRequest ? type : NULL);
}

SOAP_FMAC3 _ns1__AuthorizationRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__AuthorizationRequest(struct soap *soap, const char *tag, _ns1__AuthorizationRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AuthorizationRequest **)soap_malloc(soap, sizeof(_ns1__AuthorizationRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AuthorizationRequest *)SCAP_instantiate__ns1__AuthorizationRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__AuthorizationRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AuthorizationRequest, sizeof(_ns1__AuthorizationRequest), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AuthorizationRequest(struct soap *soap, _ns1__AuthorizationRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__AuthorizationRequest(soap, tag ? tag : "ns1:AuthorizationRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AuthorizationRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__AuthorizationRequest(struct soap *soap, _ns1__AuthorizationRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AuthorizationRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AttributeRequestType(struct soap *soap, ns2__AttributeRequestType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AttributeRequestType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AttributeRequestType(struct soap *soap, const char *tag, int id, ns2__AttributeRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AttributeRequestType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__AttributeRequestType ? type : NULL);
}

SOAP_FMAC3 ns2__AttributeRequestType ** SOAP_FMAC4 soap_in_PointerTons2__AttributeRequestType(struct soap *soap, const char *tag, ns2__AttributeRequestType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AttributeRequestType **)soap_malloc(soap, sizeof(ns2__AttributeRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AttributeRequestType *)SCAP_instantiate_ns2__AttributeRequestType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__AttributeRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AttributeRequestType, sizeof(ns2__AttributeRequestType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AttributeRequestType(struct soap *soap, ns2__AttributeRequestType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__AttributeRequestType(soap, tag ? tag : "ns2:AttributeRequestType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AttributeRequestType ** SOAP_FMAC4 soap_get_PointerTons2__AttributeRequestType(struct soap *soap, ns2__AttributeRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AttributeRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__FaultTo))
		soap_serialize__wsa__FaultTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__FaultTo(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__FaultTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa__FaultTo(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa__FaultTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__FaultTo, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa__FaultTo(soap, tag ? tag : "wsa:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__ReplyTo))
		soap_serialize__wsa__ReplyTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__ReplyTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa__ReplyTo(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa__ReplyTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__ReplyTo, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa__ReplyTo(soap, tag ? tag : "wsa:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__From(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__From))
		soap_serialize__wsa__From(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__From(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__From, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa__From(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa__From(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__From, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__From(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa__From(soap, tag ? tag : "wsa:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa__From(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__RelatesTo(struct soap *soap, struct wsa__Relationship *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__RelatesTo))
		soap_serialize__wsa__RelatesTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa__Relationship *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__RelatesTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__Relationship ** SOAP_FMAC4 soap_in_PointerTo_wsa__RelatesTo(struct soap *soap, const char *tag, struct wsa__Relationship **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__Relationship **)soap_malloc(soap, sizeof(struct wsa__Relationship *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa__RelatesTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__Relationship **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__RelatesTo, sizeof(struct wsa__Relationship), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__RelatesTo(struct soap *soap, struct wsa__Relationship *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa__RelatesTo(soap, tag ? tag : "wsa:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__Relationship ** SOAP_FMAC4 soap_get_PointerTo_wsa__RelatesTo(struct soap *soap, struct wsa__Relationship **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__ServiceNameType))
		soap_serialize_wsa__ServiceNameType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__ServiceNameType(struct soap *soap, const char *tag, int id, struct wsa__ServiceNameType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__ServiceNameType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__ServiceNameType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__ServiceNameType ** SOAP_FMAC4 soap_in_PointerTowsa__ServiceNameType(struct soap *soap, const char *tag, struct wsa__ServiceNameType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__ServiceNameType **)soap_malloc(soap, sizeof(struct wsa__ServiceNameType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa__ServiceNameType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__ServiceNameType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ServiceNameType, sizeof(struct wsa__ServiceNameType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa__ServiceNameType(soap, tag ? tag : "wsa:ServiceNameType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ServiceNameType ** SOAP_FMAC4 soap_get_PointerTowsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__ServiceNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_QName(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__QName))
		soap_serialize__QName(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_QName(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__QName, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__QName(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTo_QName(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__QName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__QName, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_QName(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTo_QName(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__ReferenceParametersType))
		soap_serialize_wsa__ReferenceParametersType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__ReferenceParametersType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa__ReferenceParametersType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa__ReferenceParametersType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa__ReferenceParametersType(soap, tag ? tag : "wsa:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__ReferencePropertiesType))
		soap_serialize_wsa__ReferencePropertiesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__ReferencePropertiesType(struct soap *soap, const char *tag, int id, struct wsa__ReferencePropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__ReferencePropertiesType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__ReferencePropertiesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType ** SOAP_FMAC4 soap_in_PointerTowsa__ReferencePropertiesType(struct soap *soap, const char *tag, struct wsa__ReferencePropertiesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__ReferencePropertiesType **)soap_malloc(soap, sizeof(struct wsa__ReferencePropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa__ReferencePropertiesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferencePropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(struct wsa__ReferencePropertiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa__ReferencePropertiesType(soap, tag ? tag : "wsa:ReferencePropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType ** SOAP_FMAC4 soap_get_PointerTowsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__ReferencePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__ID(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__ID))
		soap_serialize_xsd__ID(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__ID(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__ID, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__ID(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__ID(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__ID(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__ID, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__ID(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__ID(soap, tag ? tag : "xsd:ID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__ID(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap *soap, const char *tag, int id, xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_xsd__base64Binary, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xsd__base64Binary ? type : NULL);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__base64Binary **)soap_malloc(soap, sizeof(xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__base64Binary *)SCAP_instantiate_xsd__base64Binary(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__base64Binary(soap, tag ? tag : "xsd:base64Binary", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TransactionTypeList(struct soap *soap, ns1__TransactionTypeList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TransactionTypeList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TransactionTypeList(struct soap *soap, const char *tag, int id, ns1__TransactionTypeList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TransactionTypeList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__TransactionTypeList ? type : NULL);
}

SOAP_FMAC3 ns1__TransactionTypeList ** SOAP_FMAC4 soap_in_PointerTons1__TransactionTypeList(struct soap *soap, const char *tag, ns1__TransactionTypeList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TransactionTypeList **)soap_malloc(soap, sizeof(ns1__TransactionTypeList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TransactionTypeList *)SCAP_instantiate_ns1__TransactionTypeList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__TransactionTypeList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TransactionTypeList, sizeof(ns1__TransactionTypeList), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TransactionTypeList(struct soap *soap, ns1__TransactionTypeList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__TransactionTypeList(soap, tag ? tag : "ns1:TransactionTypeList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TransactionTypeList ** SOAP_FMAC4 soap_get_PointerTons1__TransactionTypeList(struct soap *soap, ns1__TransactionTypeList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TransactionTypeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Status(struct soap *soap, ns1__Status *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Status))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Status(struct soap *soap, const char *tag, int id, ns1__Status *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Status, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Status ? type : NULL);
}

SOAP_FMAC3 ns1__Status ** SOAP_FMAC4 soap_in_PointerTons1__Status(struct soap *soap, const char *tag, ns1__Status **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Status **)soap_malloc(soap, sizeof(ns1__Status *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Status *)SCAP_instantiate_ns1__Status(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Status **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Status, sizeof(ns1__Status), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Status(struct soap *soap, ns1__Status *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Status(soap, tag ? tag : "ns1:Status", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Status ** SOAP_FMAC4 soap_get_PointerTons1__Status(struct soap *soap, ns1__Status **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AttributeListType(struct soap *soap, ns1__AttributeListType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AttributeListType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AttributeListType(struct soap *soap, const char *tag, int id, ns1__AttributeListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AttributeListType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__AttributeListType ? type : NULL);
}

SOAP_FMAC3 ns1__AttributeListType ** SOAP_FMAC4 soap_in_PointerTons1__AttributeListType(struct soap *soap, const char *tag, ns1__AttributeListType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AttributeListType **)soap_malloc(soap, sizeof(ns1__AttributeListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AttributeListType *)SCAP_instantiate_ns1__AttributeListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__AttributeListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AttributeListType, sizeof(ns1__AttributeListType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AttributeListType(struct soap *soap, ns1__AttributeListType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__AttributeListType(soap, tag ? tag : "ns1:AttributeListType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AttributeListType ** SOAP_FMAC4 soap_get_PointerTons1__AttributeListType(struct soap *soap, ns1__AttributeListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AttributeListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PersonalData(struct soap *soap, ns1__PersonalData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PersonalData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PersonalData(struct soap *soap, const char *tag, int id, ns1__PersonalData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PersonalData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__PersonalData ? type : NULL);
}

SOAP_FMAC3 ns1__PersonalData ** SOAP_FMAC4 soap_in_PointerTons1__PersonalData(struct soap *soap, const char *tag, ns1__PersonalData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PersonalData **)soap_malloc(soap, sizeof(ns1__PersonalData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PersonalData *)SCAP_instantiate_ns1__PersonalData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__PersonalData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PersonalData, sizeof(ns1__PersonalData), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PersonalData(struct soap *soap, ns1__PersonalData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__PersonalData(soap, tag ? tag : "ns1:PersonalData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PersonalData ** SOAP_FMAC4 soap_get_PointerTons1__PersonalData(struct soap *soap, ns1__PersonalData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PersonalData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TransactionType(struct soap *soap, ns1__TransactionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TransactionType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TransactionType(struct soap *soap, const char *tag, int id, ns1__TransactionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TransactionType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__TransactionType ? type : NULL);
}

SOAP_FMAC3 ns1__TransactionType ** SOAP_FMAC4 soap_in_PointerTons1__TransactionType(struct soap *soap, const char *tag, ns1__TransactionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TransactionType **)soap_malloc(soap, sizeof(ns1__TransactionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TransactionType *)SCAP_instantiate_ns1__TransactionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__TransactionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TransactionType, sizeof(ns1__TransactionType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TransactionType(struct soap *soap, ns1__TransactionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__TransactionType(soap, tag ? tag : "ns1:TransactionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TransactionType ** SOAP_FMAC4 soap_get_PointerTons1__TransactionType(struct soap *soap, ns1__TransactionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TransactionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SubAttributeType(struct soap *soap, ns1__SubAttributeType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SubAttributeType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SubAttributeType(struct soap *soap, const char *tag, int id, ns1__SubAttributeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SubAttributeType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__SubAttributeType ? type : NULL);
}

SOAP_FMAC3 ns1__SubAttributeType ** SOAP_FMAC4 soap_in_PointerTons1__SubAttributeType(struct soap *soap, const char *tag, ns1__SubAttributeType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SubAttributeType **)soap_malloc(soap, sizeof(ns1__SubAttributeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SubAttributeType *)SCAP_instantiate_ns1__SubAttributeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SubAttributeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SubAttributeType, sizeof(ns1__SubAttributeType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SubAttributeType(struct soap *soap, ns1__SubAttributeType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SubAttributeType(soap, tag ? tag : "ns1:SubAttributeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SubAttributeType ** SOAP_FMAC4 soap_get_PointerTons1__SubAttributeType(struct soap *soap, ns1__SubAttributeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SubAttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SubAttributeListType(struct soap *soap, ns1__SubAttributeListType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SubAttributeListType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SubAttributeListType(struct soap *soap, const char *tag, int id, ns1__SubAttributeListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SubAttributeListType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__SubAttributeListType ? type : NULL);
}

SOAP_FMAC3 ns1__SubAttributeListType ** SOAP_FMAC4 soap_in_PointerTons1__SubAttributeListType(struct soap *soap, const char *tag, ns1__SubAttributeListType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SubAttributeListType **)soap_malloc(soap, sizeof(ns1__SubAttributeListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SubAttributeListType *)SCAP_instantiate_ns1__SubAttributeListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SubAttributeListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SubAttributeListType, sizeof(ns1__SubAttributeListType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SubAttributeListType(struct soap *soap, ns1__SubAttributeListType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SubAttributeListType(soap, tag ? tag : "ns1:SubAttributeListType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SubAttributeListType ** SOAP_FMAC4 soap_get_PointerTons1__SubAttributeListType(struct soap *soap, ns1__SubAttributeListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SubAttributeListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__LegalActListType(struct soap *soap, ns1__LegalActListType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__LegalActListType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__LegalActListType(struct soap *soap, const char *tag, int id, ns1__LegalActListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__LegalActListType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__LegalActListType ? type : NULL);
}

SOAP_FMAC3 ns1__LegalActListType ** SOAP_FMAC4 soap_in_PointerTons1__LegalActListType(struct soap *soap, const char *tag, ns1__LegalActListType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__LegalActListType **)soap_malloc(soap, sizeof(ns1__LegalActListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__LegalActListType *)SCAP_instantiate_ns1__LegalActListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__LegalActListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__LegalActListType, sizeof(ns1__LegalActListType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__LegalActListType(struct soap *soap, ns1__LegalActListType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__LegalActListType(soap, tag ? tag : "ns1:LegalActListType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__LegalActListType ** SOAP_FMAC4 soap_get_PointerTons1__LegalActListType(struct soap *soap, ns1__LegalActListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__LegalActListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MainAttributeType(struct soap *soap, ns1__MainAttributeType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MainAttributeType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MainAttributeType(struct soap *soap, const char *tag, int id, ns1__MainAttributeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MainAttributeType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__MainAttributeType ? type : NULL);
}

SOAP_FMAC3 ns1__MainAttributeType ** SOAP_FMAC4 soap_in_PointerTons1__MainAttributeType(struct soap *soap, const char *tag, ns1__MainAttributeType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MainAttributeType **)soap_malloc(soap, sizeof(ns1__MainAttributeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MainAttributeType *)SCAP_instantiate_ns1__MainAttributeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__MainAttributeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MainAttributeType, sizeof(ns1__MainAttributeType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MainAttributeType(struct soap *soap, ns1__MainAttributeType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__MainAttributeType(soap, tag ? tag : "ns1:MainAttributeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__MainAttributeType ** SOAP_FMAC4 soap_get_PointerTons1__MainAttributeType(struct soap *soap, ns1__MainAttributeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MainAttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AttributeSupplierType(struct soap *soap, ns1__AttributeSupplierType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AttributeSupplierType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AttributeSupplierType(struct soap *soap, const char *tag, int id, ns1__AttributeSupplierType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AttributeSupplierType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__AttributeSupplierType ? type : NULL);
}

SOAP_FMAC3 ns1__AttributeSupplierType ** SOAP_FMAC4 soap_in_PointerTons1__AttributeSupplierType(struct soap *soap, const char *tag, ns1__AttributeSupplierType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AttributeSupplierType **)soap_malloc(soap, sizeof(ns1__AttributeSupplierType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AttributeSupplierType *)SCAP_instantiate_ns1__AttributeSupplierType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__AttributeSupplierType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AttributeSupplierType, sizeof(ns1__AttributeSupplierType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AttributeSupplierType(struct soap *soap, ns1__AttributeSupplierType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__AttributeSupplierType(soap, tag ? tag : "ns1:AttributeSupplierType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AttributeSupplierType ** SOAP_FMAC4 soap_get_PointerTons1__AttributeSupplierType(struct soap *soap, ns1__AttributeSupplierType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AttributeSupplierType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AttributeType(struct soap *soap, ns1__AttributeType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AttributeType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AttributeType(struct soap *soap, const char *tag, int id, ns1__AttributeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AttributeType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__AttributeType ? type : NULL);
}

SOAP_FMAC3 ns1__AttributeType ** SOAP_FMAC4 soap_in_PointerTons1__AttributeType(struct soap *soap, const char *tag, ns1__AttributeType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AttributeType **)soap_malloc(soap, sizeof(ns1__AttributeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AttributeType *)SCAP_instantiate_ns1__AttributeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__AttributeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AttributeType, sizeof(ns1__AttributeType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AttributeType(struct soap *soap, ns1__AttributeType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__AttributeType(soap, tag ? tag : "ns1:AttributeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AttributeType ** SOAP_FMAC4 soap_get_PointerTons1__AttributeType(struct soap *soap, ns1__AttributeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__EncapsulatedOCSPValueType(struct soap *soap, ns6__EncapsulatedOCSPValueType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__EncapsulatedOCSPValueType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__EncapsulatedOCSPValueType(struct soap *soap, const char *tag, int id, ns6__EncapsulatedOCSPValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__EncapsulatedOCSPValueType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__EncapsulatedOCSPValueType ? type : NULL);
}

SOAP_FMAC3 ns6__EncapsulatedOCSPValueType ** SOAP_FMAC4 soap_in_PointerTons6__EncapsulatedOCSPValueType(struct soap *soap, const char *tag, ns6__EncapsulatedOCSPValueType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__EncapsulatedOCSPValueType **)soap_malloc(soap, sizeof(ns6__EncapsulatedOCSPValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__EncapsulatedOCSPValueType *)SCAP_instantiate_ns6__EncapsulatedOCSPValueType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__EncapsulatedOCSPValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__EncapsulatedOCSPValueType, sizeof(ns6__EncapsulatedOCSPValueType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__EncapsulatedOCSPValueType(struct soap *soap, ns6__EncapsulatedOCSPValueType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__EncapsulatedOCSPValueType(soap, tag ? tag : "ns6:EncapsulatedOCSPValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__EncapsulatedOCSPValueType ** SOAP_FMAC4 soap_get_PointerTons6__EncapsulatedOCSPValueType(struct soap *soap, ns6__EncapsulatedOCSPValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__EncapsulatedOCSPValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__EncapsulatedCRLValueType(struct soap *soap, ns6__EncapsulatedCRLValueType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__EncapsulatedCRLValueType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__EncapsulatedCRLValueType(struct soap *soap, const char *tag, int id, ns6__EncapsulatedCRLValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__EncapsulatedCRLValueType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__EncapsulatedCRLValueType ? type : NULL);
}

SOAP_FMAC3 ns6__EncapsulatedCRLValueType ** SOAP_FMAC4 soap_in_PointerTons6__EncapsulatedCRLValueType(struct soap *soap, const char *tag, ns6__EncapsulatedCRLValueType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__EncapsulatedCRLValueType **)soap_malloc(soap, sizeof(ns6__EncapsulatedCRLValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__EncapsulatedCRLValueType *)SCAP_instantiate_ns6__EncapsulatedCRLValueType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__EncapsulatedCRLValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__EncapsulatedCRLValueType, sizeof(ns6__EncapsulatedCRLValueType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__EncapsulatedCRLValueType(struct soap *soap, ns6__EncapsulatedCRLValueType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__EncapsulatedCRLValueType(soap, tag ? tag : "ns6:EncapsulatedCRLValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__EncapsulatedCRLValueType ** SOAP_FMAC4 soap_get_PointerTons6__EncapsulatedCRLValueType(struct soap *soap, ns6__EncapsulatedCRLValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__EncapsulatedCRLValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__OCSPValuesType(struct soap *soap, ns6__OCSPValuesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__OCSPValuesType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__OCSPValuesType(struct soap *soap, const char *tag, int id, ns6__OCSPValuesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__OCSPValuesType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__OCSPValuesType ? type : NULL);
}

SOAP_FMAC3 ns6__OCSPValuesType ** SOAP_FMAC4 soap_in_PointerTons6__OCSPValuesType(struct soap *soap, const char *tag, ns6__OCSPValuesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__OCSPValuesType **)soap_malloc(soap, sizeof(ns6__OCSPValuesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__OCSPValuesType *)SCAP_instantiate_ns6__OCSPValuesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__OCSPValuesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__OCSPValuesType, sizeof(ns6__OCSPValuesType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__OCSPValuesType(struct soap *soap, ns6__OCSPValuesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__OCSPValuesType(soap, tag ? tag : "ns6:OCSPValuesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__OCSPValuesType ** SOAP_FMAC4 soap_get_PointerTons6__OCSPValuesType(struct soap *soap, ns6__OCSPValuesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__OCSPValuesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__CRLValuesType(struct soap *soap, ns6__CRLValuesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__CRLValuesType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__CRLValuesType(struct soap *soap, const char *tag, int id, ns6__CRLValuesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__CRLValuesType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__CRLValuesType ? type : NULL);
}

SOAP_FMAC3 ns6__CRLValuesType ** SOAP_FMAC4 soap_in_PointerTons6__CRLValuesType(struct soap *soap, const char *tag, ns6__CRLValuesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__CRLValuesType **)soap_malloc(soap, sizeof(ns6__CRLValuesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__CRLValuesType *)SCAP_instantiate_ns6__CRLValuesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__CRLValuesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__CRLValuesType, sizeof(ns6__CRLValuesType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__CRLValuesType(struct soap *soap, ns6__CRLValuesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__CRLValuesType(soap, tag ? tag : "ns6:CRLValuesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__CRLValuesType ** SOAP_FMAC4 soap_get_PointerTons6__CRLValuesType(struct soap *soap, ns6__CRLValuesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__CRLValuesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__EncapsulatedX509CertificateType(struct soap *soap, ns6__EncapsulatedX509CertificateType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__EncapsulatedX509CertificateType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__EncapsulatedX509CertificateType(struct soap *soap, const char *tag, int id, ns6__EncapsulatedX509CertificateType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__EncapsulatedX509CertificateType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__EncapsulatedX509CertificateType ? type : NULL);
}

SOAP_FMAC3 ns6__EncapsulatedX509CertificateType ** SOAP_FMAC4 soap_in_PointerTons6__EncapsulatedX509CertificateType(struct soap *soap, const char *tag, ns6__EncapsulatedX509CertificateType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__EncapsulatedX509CertificateType **)soap_malloc(soap, sizeof(ns6__EncapsulatedX509CertificateType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__EncapsulatedX509CertificateType *)SCAP_instantiate_ns6__EncapsulatedX509CertificateType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__EncapsulatedX509CertificateType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__EncapsulatedX509CertificateType, sizeof(ns6__EncapsulatedX509CertificateType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__EncapsulatedX509CertificateType(struct soap *soap, ns6__EncapsulatedX509CertificateType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__EncapsulatedX509CertificateType(soap, tag ? tag : "ns6:EncapsulatedX509CertificateType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__EncapsulatedX509CertificateType ** SOAP_FMAC4 soap_get_PointerTons6__EncapsulatedX509CertificateType(struct soap *soap, ns6__EncapsulatedX509CertificateType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__EncapsulatedX509CertificateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ResponderIDType(struct soap *soap, ns6__ResponderIDType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__ResponderIDType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__ResponderIDType(struct soap *soap, const char *tag, int id, ns6__ResponderIDType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ResponderIDType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__ResponderIDType ? type : NULL);
}

SOAP_FMAC3 ns6__ResponderIDType ** SOAP_FMAC4 soap_in_PointerTons6__ResponderIDType(struct soap *soap, const char *tag, ns6__ResponderIDType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__ResponderIDType **)soap_malloc(soap, sizeof(ns6__ResponderIDType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__ResponderIDType *)SCAP_instantiate_ns6__ResponderIDType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__ResponderIDType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ResponderIDType, sizeof(ns6__ResponderIDType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ResponderIDType(struct soap *soap, ns6__ResponderIDType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__ResponderIDType(soap, tag ? tag : "ns6:ResponderIDType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__ResponderIDType ** SOAP_FMAC4 soap_get_PointerTons6__ResponderIDType(struct soap *soap, ns6__ResponderIDType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__ResponderIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__OCSPIdentifierType(struct soap *soap, ns6__OCSPIdentifierType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__OCSPIdentifierType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__OCSPIdentifierType(struct soap *soap, const char *tag, int id, ns6__OCSPIdentifierType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__OCSPIdentifierType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__OCSPIdentifierType ? type : NULL);
}

SOAP_FMAC3 ns6__OCSPIdentifierType ** SOAP_FMAC4 soap_in_PointerTons6__OCSPIdentifierType(struct soap *soap, const char *tag, ns6__OCSPIdentifierType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__OCSPIdentifierType **)soap_malloc(soap, sizeof(ns6__OCSPIdentifierType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__OCSPIdentifierType *)SCAP_instantiate_ns6__OCSPIdentifierType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__OCSPIdentifierType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__OCSPIdentifierType, sizeof(ns6__OCSPIdentifierType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__OCSPIdentifierType(struct soap *soap, ns6__OCSPIdentifierType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__OCSPIdentifierType(soap, tag ? tag : "ns6:OCSPIdentifierType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__OCSPIdentifierType ** SOAP_FMAC4 soap_get_PointerTons6__OCSPIdentifierType(struct soap *soap, ns6__OCSPIdentifierType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__OCSPIdentifierType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__OCSPRefType(struct soap *soap, ns6__OCSPRefType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__OCSPRefType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__OCSPRefType(struct soap *soap, const char *tag, int id, ns6__OCSPRefType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__OCSPRefType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__OCSPRefType ? type : NULL);
}

SOAP_FMAC3 ns6__OCSPRefType ** SOAP_FMAC4 soap_in_PointerTons6__OCSPRefType(struct soap *soap, const char *tag, ns6__OCSPRefType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__OCSPRefType **)soap_malloc(soap, sizeof(ns6__OCSPRefType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__OCSPRefType *)SCAP_instantiate_ns6__OCSPRefType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__OCSPRefType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__OCSPRefType, sizeof(ns6__OCSPRefType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__OCSPRefType(struct soap *soap, ns6__OCSPRefType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__OCSPRefType(soap, tag ? tag : "ns6:OCSPRefType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__OCSPRefType ** SOAP_FMAC4 soap_get_PointerTons6__OCSPRefType(struct soap *soap, ns6__OCSPRefType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__OCSPRefType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__CRLIdentifierType(struct soap *soap, ns6__CRLIdentifierType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__CRLIdentifierType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__CRLIdentifierType(struct soap *soap, const char *tag, int id, ns6__CRLIdentifierType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__CRLIdentifierType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__CRLIdentifierType ? type : NULL);
}

SOAP_FMAC3 ns6__CRLIdentifierType ** SOAP_FMAC4 soap_in_PointerTons6__CRLIdentifierType(struct soap *soap, const char *tag, ns6__CRLIdentifierType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__CRLIdentifierType **)soap_malloc(soap, sizeof(ns6__CRLIdentifierType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__CRLIdentifierType *)SCAP_instantiate_ns6__CRLIdentifierType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__CRLIdentifierType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__CRLIdentifierType, sizeof(ns6__CRLIdentifierType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__CRLIdentifierType(struct soap *soap, ns6__CRLIdentifierType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__CRLIdentifierType(soap, tag ? tag : "ns6:CRLIdentifierType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__CRLIdentifierType ** SOAP_FMAC4 soap_get_PointerTons6__CRLIdentifierType(struct soap *soap, ns6__CRLIdentifierType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__CRLIdentifierType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__DigestAlgAndValueType(struct soap *soap, ns6__DigestAlgAndValueType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__DigestAlgAndValueType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__DigestAlgAndValueType(struct soap *soap, const char *tag, int id, ns6__DigestAlgAndValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__DigestAlgAndValueType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__DigestAlgAndValueType ? type : NULL);
}

SOAP_FMAC3 ns6__DigestAlgAndValueType ** SOAP_FMAC4 soap_in_PointerTons6__DigestAlgAndValueType(struct soap *soap, const char *tag, ns6__DigestAlgAndValueType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__DigestAlgAndValueType **)soap_malloc(soap, sizeof(ns6__DigestAlgAndValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__DigestAlgAndValueType *)SCAP_instantiate_ns6__DigestAlgAndValueType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__DigestAlgAndValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__DigestAlgAndValueType, sizeof(ns6__DigestAlgAndValueType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__DigestAlgAndValueType(struct soap *soap, ns6__DigestAlgAndValueType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__DigestAlgAndValueType(soap, tag ? tag : "ns6:DigestAlgAndValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__DigestAlgAndValueType ** SOAP_FMAC4 soap_get_PointerTons6__DigestAlgAndValueType(struct soap *soap, ns6__DigestAlgAndValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__DigestAlgAndValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__CRLRefType(struct soap *soap, ns6__CRLRefType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__CRLRefType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__CRLRefType(struct soap *soap, const char *tag, int id, ns6__CRLRefType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__CRLRefType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__CRLRefType ? type : NULL);
}

SOAP_FMAC3 ns6__CRLRefType ** SOAP_FMAC4 soap_in_PointerTons6__CRLRefType(struct soap *soap, const char *tag, ns6__CRLRefType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__CRLRefType **)soap_malloc(soap, sizeof(ns6__CRLRefType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__CRLRefType *)SCAP_instantiate_ns6__CRLRefType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__CRLRefType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__CRLRefType, sizeof(ns6__CRLRefType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__CRLRefType(struct soap *soap, ns6__CRLRefType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__CRLRefType(soap, tag ? tag : "ns6:CRLRefType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__CRLRefType ** SOAP_FMAC4 soap_get_PointerTons6__CRLRefType(struct soap *soap, ns6__CRLRefType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__CRLRefType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__OCSPRefsType(struct soap *soap, ns6__OCSPRefsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__OCSPRefsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__OCSPRefsType(struct soap *soap, const char *tag, int id, ns6__OCSPRefsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__OCSPRefsType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__OCSPRefsType ? type : NULL);
}

SOAP_FMAC3 ns6__OCSPRefsType ** SOAP_FMAC4 soap_in_PointerTons6__OCSPRefsType(struct soap *soap, const char *tag, ns6__OCSPRefsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__OCSPRefsType **)soap_malloc(soap, sizeof(ns6__OCSPRefsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__OCSPRefsType *)SCAP_instantiate_ns6__OCSPRefsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__OCSPRefsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__OCSPRefsType, sizeof(ns6__OCSPRefsType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__OCSPRefsType(struct soap *soap, ns6__OCSPRefsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__OCSPRefsType(soap, tag ? tag : "ns6:OCSPRefsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__OCSPRefsType ** SOAP_FMAC4 soap_get_PointerTons6__OCSPRefsType(struct soap *soap, ns6__OCSPRefsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__OCSPRefsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__CRLRefsType(struct soap *soap, ns6__CRLRefsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__CRLRefsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__CRLRefsType(struct soap *soap, const char *tag, int id, ns6__CRLRefsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__CRLRefsType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__CRLRefsType ? type : NULL);
}

SOAP_FMAC3 ns6__CRLRefsType ** SOAP_FMAC4 soap_in_PointerTons6__CRLRefsType(struct soap *soap, const char *tag, ns6__CRLRefsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__CRLRefsType **)soap_malloc(soap, sizeof(ns6__CRLRefsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__CRLRefsType *)SCAP_instantiate_ns6__CRLRefsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__CRLRefsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__CRLRefsType, sizeof(ns6__CRLRefsType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__CRLRefsType(struct soap *soap, ns6__CRLRefsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__CRLRefsType(soap, tag ? tag : "ns6:CRLRefsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__CRLRefsType ** SOAP_FMAC4 soap_get_PointerTons6__CRLRefsType(struct soap *soap, ns6__CRLRefsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__CRLRefsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__CertRefsType(struct soap *soap, ns6__CertRefsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__CertRefsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__CertRefsType(struct soap *soap, const char *tag, int id, ns6__CertRefsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__CertRefsType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__CertRefsType ? type : NULL);
}

SOAP_FMAC3 ns6__CertRefsType ** SOAP_FMAC4 soap_in_PointerTons6__CertRefsType(struct soap *soap, const char *tag, ns6__CertRefsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__CertRefsType **)soap_malloc(soap, sizeof(ns6__CertRefsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__CertRefsType *)SCAP_instantiate_ns6__CertRefsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__CertRefsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__CertRefsType, sizeof(ns6__CertRefsType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__CertRefsType(struct soap *soap, ns6__CertRefsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__CertRefsType(soap, tag ? tag : "ns6:CertRefsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__CertRefsType ** SOAP_FMAC4 soap_get_PointerTons6__CertRefsType(struct soap *soap, ns6__CertRefsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__CertRefsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ArchiveTimeStampType(struct soap *soap, ns6__ArchiveTimeStampType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__ArchiveTimeStampType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__ArchiveTimeStampType(struct soap *soap, const char *tag, int id, ns6__ArchiveTimeStampType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ArchiveTimeStampType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__ArchiveTimeStampType ? type : NULL);
}

SOAP_FMAC3 ns6__ArchiveTimeStampType ** SOAP_FMAC4 soap_in_PointerTons6__ArchiveTimeStampType(struct soap *soap, const char *tag, ns6__ArchiveTimeStampType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__ArchiveTimeStampType **)soap_malloc(soap, sizeof(ns6__ArchiveTimeStampType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__ArchiveTimeStampType *)SCAP_instantiate_ns6__ArchiveTimeStampType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__ArchiveTimeStampType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ArchiveTimeStampType, sizeof(ns6__ArchiveTimeStampType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ArchiveTimeStampType(struct soap *soap, ns6__ArchiveTimeStampType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__ArchiveTimeStampType(soap, tag ? tag : "ns6:ArchiveTimeStampType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__ArchiveTimeStampType ** SOAP_FMAC4 soap_get_PointerTons6__ArchiveTimeStampType(struct soap *soap, ns6__ArchiveTimeStampType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__ArchiveTimeStampType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__RevocationValuesType(struct soap *soap, ns6__RevocationValuesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__RevocationValuesType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__RevocationValuesType(struct soap *soap, const char *tag, int id, ns6__RevocationValuesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__RevocationValuesType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__RevocationValuesType ? type : NULL);
}

SOAP_FMAC3 ns6__RevocationValuesType ** SOAP_FMAC4 soap_in_PointerTons6__RevocationValuesType(struct soap *soap, const char *tag, ns6__RevocationValuesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__RevocationValuesType **)soap_malloc(soap, sizeof(ns6__RevocationValuesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__RevocationValuesType *)SCAP_instantiate_ns6__RevocationValuesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__RevocationValuesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__RevocationValuesType, sizeof(ns6__RevocationValuesType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__RevocationValuesType(struct soap *soap, ns6__RevocationValuesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__RevocationValuesType(soap, tag ? tag : "ns6:RevocationValuesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__RevocationValuesType ** SOAP_FMAC4 soap_get_PointerTons6__RevocationValuesType(struct soap *soap, ns6__RevocationValuesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__RevocationValuesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__CertificateValuesType(struct soap *soap, ns6__CertificateValuesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__CertificateValuesType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__CertificateValuesType(struct soap *soap, const char *tag, int id, ns6__CertificateValuesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__CertificateValuesType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__CertificateValuesType ? type : NULL);
}

SOAP_FMAC3 ns6__CertificateValuesType ** SOAP_FMAC4 soap_in_PointerTons6__CertificateValuesType(struct soap *soap, const char *tag, ns6__CertificateValuesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__CertificateValuesType **)soap_malloc(soap, sizeof(ns6__CertificateValuesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__CertificateValuesType *)SCAP_instantiate_ns6__CertificateValuesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__CertificateValuesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__CertificateValuesType, sizeof(ns6__CertificateValuesType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__CertificateValuesType(struct soap *soap, ns6__CertificateValuesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__CertificateValuesType(soap, tag ? tag : "ns6:CertificateValuesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__CertificateValuesType ** SOAP_FMAC4 soap_get_PointerTons6__CertificateValuesType(struct soap *soap, ns6__CertificateValuesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__CertificateValuesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__SigAndRefsTimeStampType(struct soap *soap, ns6__SigAndRefsTimeStampType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__SigAndRefsTimeStampType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__SigAndRefsTimeStampType(struct soap *soap, const char *tag, int id, ns6__SigAndRefsTimeStampType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__SigAndRefsTimeStampType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__SigAndRefsTimeStampType ? type : NULL);
}

SOAP_FMAC3 ns6__SigAndRefsTimeStampType ** SOAP_FMAC4 soap_in_PointerTons6__SigAndRefsTimeStampType(struct soap *soap, const char *tag, ns6__SigAndRefsTimeStampType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__SigAndRefsTimeStampType **)soap_malloc(soap, sizeof(ns6__SigAndRefsTimeStampType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__SigAndRefsTimeStampType *)SCAP_instantiate_ns6__SigAndRefsTimeStampType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__SigAndRefsTimeStampType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__SigAndRefsTimeStampType, sizeof(ns6__SigAndRefsTimeStampType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__SigAndRefsTimeStampType(struct soap *soap, ns6__SigAndRefsTimeStampType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__SigAndRefsTimeStampType(soap, tag ? tag : "ns6:SigAndRefsTimeStampType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__SigAndRefsTimeStampType ** SOAP_FMAC4 soap_get_PointerTons6__SigAndRefsTimeStampType(struct soap *soap, ns6__SigAndRefsTimeStampType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__SigAndRefsTimeStampType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__CompleteRevocationRefsType(struct soap *soap, ns6__CompleteRevocationRefsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__CompleteRevocationRefsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__CompleteRevocationRefsType(struct soap *soap, const char *tag, int id, ns6__CompleteRevocationRefsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__CompleteRevocationRefsType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__CompleteRevocationRefsType ? type : NULL);
}

SOAP_FMAC3 ns6__CompleteRevocationRefsType ** SOAP_FMAC4 soap_in_PointerTons6__CompleteRevocationRefsType(struct soap *soap, const char *tag, ns6__CompleteRevocationRefsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__CompleteRevocationRefsType **)soap_malloc(soap, sizeof(ns6__CompleteRevocationRefsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__CompleteRevocationRefsType *)SCAP_instantiate_ns6__CompleteRevocationRefsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__CompleteRevocationRefsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__CompleteRevocationRefsType, sizeof(ns6__CompleteRevocationRefsType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__CompleteRevocationRefsType(struct soap *soap, ns6__CompleteRevocationRefsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__CompleteRevocationRefsType(soap, tag ? tag : "ns6:CompleteRevocationRefsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__CompleteRevocationRefsType ** SOAP_FMAC4 soap_get_PointerTons6__CompleteRevocationRefsType(struct soap *soap, ns6__CompleteRevocationRefsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__CompleteRevocationRefsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__CompleteCertificateRefsType(struct soap *soap, ns6__CompleteCertificateRefsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__CompleteCertificateRefsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__CompleteCertificateRefsType(struct soap *soap, const char *tag, int id, ns6__CompleteCertificateRefsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__CompleteCertificateRefsType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__CompleteCertificateRefsType ? type : NULL);
}

SOAP_FMAC3 ns6__CompleteCertificateRefsType ** SOAP_FMAC4 soap_in_PointerTons6__CompleteCertificateRefsType(struct soap *soap, const char *tag, ns6__CompleteCertificateRefsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__CompleteCertificateRefsType **)soap_malloc(soap, sizeof(ns6__CompleteCertificateRefsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__CompleteCertificateRefsType *)SCAP_instantiate_ns6__CompleteCertificateRefsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__CompleteCertificateRefsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__CompleteCertificateRefsType, sizeof(ns6__CompleteCertificateRefsType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__CompleteCertificateRefsType(struct soap *soap, ns6__CompleteCertificateRefsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__CompleteCertificateRefsType(soap, tag ? tag : "ns6:CompleteCertificateRefsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__CompleteCertificateRefsType ** SOAP_FMAC4 soap_get_PointerTons6__CompleteCertificateRefsType(struct soap *soap, ns6__CompleteCertificateRefsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__CompleteCertificateRefsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__SignatureTimeStampType(struct soap *soap, ns6__SignatureTimeStampType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__SignatureTimeStampType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__SignatureTimeStampType(struct soap *soap, const char *tag, int id, ns6__SignatureTimeStampType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__SignatureTimeStampType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__SignatureTimeStampType ? type : NULL);
}

SOAP_FMAC3 ns6__SignatureTimeStampType ** SOAP_FMAC4 soap_in_PointerTons6__SignatureTimeStampType(struct soap *soap, const char *tag, ns6__SignatureTimeStampType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__SignatureTimeStampType **)soap_malloc(soap, sizeof(ns6__SignatureTimeStampType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__SignatureTimeStampType *)SCAP_instantiate_ns6__SignatureTimeStampType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__SignatureTimeStampType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__SignatureTimeStampType, sizeof(ns6__SignatureTimeStampType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__SignatureTimeStampType(struct soap *soap, ns6__SignatureTimeStampType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__SignatureTimeStampType(soap, tag ? tag : "ns6:SignatureTimeStampType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__SignatureTimeStampType ** SOAP_FMAC4 soap_get_PointerTons6__SignatureTimeStampType(struct soap *soap, ns6__SignatureTimeStampType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__SignatureTimeStampType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__CounterSignatureType(struct soap *soap, ns6__CounterSignatureType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__CounterSignatureType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__CounterSignatureType(struct soap *soap, const char *tag, int id, ns6__CounterSignatureType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__CounterSignatureType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__CounterSignatureType ? type : NULL);
}

SOAP_FMAC3 ns6__CounterSignatureType ** SOAP_FMAC4 soap_in_PointerTons6__CounterSignatureType(struct soap *soap, const char *tag, ns6__CounterSignatureType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__CounterSignatureType **)soap_malloc(soap, sizeof(ns6__CounterSignatureType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__CounterSignatureType *)SCAP_instantiate_ns6__CounterSignatureType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__CounterSignatureType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__CounterSignatureType, sizeof(ns6__CounterSignatureType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__CounterSignatureType(struct soap *soap, ns6__CounterSignatureType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__CounterSignatureType(soap, tag ? tag : "ns6:CounterSignatureType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__CounterSignatureType ** SOAP_FMAC4 soap_get_PointerTons6__CounterSignatureType(struct soap *soap, ns6__CounterSignatureType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__CounterSignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__UnsignedSignaturePropertiesType(struct soap *soap, ns6__UnsignedSignaturePropertiesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__UnsignedSignaturePropertiesType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__UnsignedSignaturePropertiesType(struct soap *soap, const char *tag, int id, ns6__UnsignedSignaturePropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__UnsignedSignaturePropertiesType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__UnsignedSignaturePropertiesType ? type : NULL);
}

SOAP_FMAC3 ns6__UnsignedSignaturePropertiesType ** SOAP_FMAC4 soap_in_PointerTons6__UnsignedSignaturePropertiesType(struct soap *soap, const char *tag, ns6__UnsignedSignaturePropertiesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__UnsignedSignaturePropertiesType **)soap_malloc(soap, sizeof(ns6__UnsignedSignaturePropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__UnsignedSignaturePropertiesType *)SCAP_instantiate_ns6__UnsignedSignaturePropertiesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__UnsignedSignaturePropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__UnsignedSignaturePropertiesType, sizeof(ns6__UnsignedSignaturePropertiesType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__UnsignedSignaturePropertiesType(struct soap *soap, ns6__UnsignedSignaturePropertiesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__UnsignedSignaturePropertiesType(soap, tag ? tag : "ns6:UnsignedSignaturePropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__UnsignedSignaturePropertiesType ** SOAP_FMAC4 soap_get_PointerTons6__UnsignedSignaturePropertiesType(struct soap *soap, ns6__UnsignedSignaturePropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__UnsignedSignaturePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ClaimedRoleType(struct soap *soap, ns6__ClaimedRoleType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__ClaimedRoleType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__ClaimedRoleType(struct soap *soap, const char *tag, int id, ns6__ClaimedRoleType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ClaimedRoleType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__ClaimedRoleType ? type : NULL);
}

SOAP_FMAC3 ns6__ClaimedRoleType ** SOAP_FMAC4 soap_in_PointerTons6__ClaimedRoleType(struct soap *soap, const char *tag, ns6__ClaimedRoleType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__ClaimedRoleType **)soap_malloc(soap, sizeof(ns6__ClaimedRoleType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__ClaimedRoleType *)SCAP_instantiate_ns6__ClaimedRoleType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__ClaimedRoleType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ClaimedRoleType, sizeof(ns6__ClaimedRoleType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ClaimedRoleType(struct soap *soap, ns6__ClaimedRoleType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__ClaimedRoleType(soap, tag ? tag : "ns6:ClaimedRoleType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__ClaimedRoleType ** SOAP_FMAC4 soap_get_PointerTons6__ClaimedRoleType(struct soap *soap, ns6__ClaimedRoleType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__ClaimedRoleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ClaimedRolesListType(struct soap *soap, ns6__ClaimedRolesListType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__ClaimedRolesListType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__ClaimedRolesListType(struct soap *soap, const char *tag, int id, ns6__ClaimedRolesListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ClaimedRolesListType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__ClaimedRolesListType ? type : NULL);
}

SOAP_FMAC3 ns6__ClaimedRolesListType ** SOAP_FMAC4 soap_in_PointerTons6__ClaimedRolesListType(struct soap *soap, const char *tag, ns6__ClaimedRolesListType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__ClaimedRolesListType **)soap_malloc(soap, sizeof(ns6__ClaimedRolesListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__ClaimedRolesListType *)SCAP_instantiate_ns6__ClaimedRolesListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__ClaimedRolesListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ClaimedRolesListType, sizeof(ns6__ClaimedRolesListType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ClaimedRolesListType(struct soap *soap, ns6__ClaimedRolesListType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__ClaimedRolesListType(soap, tag ? tag : "ns6:ClaimedRolesListType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__ClaimedRolesListType ** SOAP_FMAC4 soap_get_PointerTons6__ClaimedRolesListType(struct soap *soap, ns6__ClaimedRolesListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__ClaimedRolesListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__IssuerSerialType(struct soap *soap, ns6__IssuerSerialType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__IssuerSerialType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__IssuerSerialType(struct soap *soap, const char *tag, int id, ns6__IssuerSerialType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__IssuerSerialType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__IssuerSerialType ? type : NULL);
}

SOAP_FMAC3 ns6__IssuerSerialType ** SOAP_FMAC4 soap_in_PointerTons6__IssuerSerialType(struct soap *soap, const char *tag, ns6__IssuerSerialType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__IssuerSerialType **)soap_malloc(soap, sizeof(ns6__IssuerSerialType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__IssuerSerialType *)SCAP_instantiate_ns6__IssuerSerialType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__IssuerSerialType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__IssuerSerialType, sizeof(ns6__IssuerSerialType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__IssuerSerialType(struct soap *soap, ns6__IssuerSerialType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__IssuerSerialType(soap, tag ? tag : "ns6:IssuerSerialType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__IssuerSerialType ** SOAP_FMAC4 soap_get_PointerTons6__IssuerSerialType(struct soap *soap, ns6__IssuerSerialType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__CertDigestType(struct soap *soap, ns6__CertDigestType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__CertDigestType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__CertDigestType(struct soap *soap, const char *tag, int id, ns6__CertDigestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__CertDigestType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__CertDigestType ? type : NULL);
}

SOAP_FMAC3 ns6__CertDigestType ** SOAP_FMAC4 soap_in_PointerTons6__CertDigestType(struct soap *soap, const char *tag, ns6__CertDigestType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__CertDigestType **)soap_malloc(soap, sizeof(ns6__CertDigestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__CertDigestType *)SCAP_instantiate_ns6__CertDigestType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__CertDigestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__CertDigestType, sizeof(ns6__CertDigestType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__CertDigestType(struct soap *soap, ns6__CertDigestType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__CertDigestType(soap, tag ? tag : "ns6:CertDigestType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__CertDigestType ** SOAP_FMAC4 soap_get_PointerTons6__CertDigestType(struct soap *soap, ns6__CertDigestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__CertDigestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__CertType(struct soap *soap, ns6__CertType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__CertType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__CertType(struct soap *soap, const char *tag, int id, ns6__CertType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__CertType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__CertType ? type : NULL);
}

SOAP_FMAC3 ns6__CertType ** SOAP_FMAC4 soap_in_PointerTons6__CertType(struct soap *soap, const char *tag, ns6__CertType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__CertType **)soap_malloc(soap, sizeof(ns6__CertType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__CertType *)SCAP_instantiate_ns6__CertType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__CertType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__CertType, sizeof(ns6__CertType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__CertType(struct soap *soap, ns6__CertType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__CertType(soap, tag ? tag : "ns6:CertType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__CertType ** SOAP_FMAC4 soap_get_PointerTons6__CertType(struct soap *soap, ns6__CertType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__CertType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__SignerRoleType(struct soap *soap, ns6__SignerRoleType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__SignerRoleType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__SignerRoleType(struct soap *soap, const char *tag, int id, ns6__SignerRoleType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__SignerRoleType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__SignerRoleType ? type : NULL);
}

SOAP_FMAC3 ns6__SignerRoleType ** SOAP_FMAC4 soap_in_PointerTons6__SignerRoleType(struct soap *soap, const char *tag, ns6__SignerRoleType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__SignerRoleType **)soap_malloc(soap, sizeof(ns6__SignerRoleType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__SignerRoleType *)SCAP_instantiate_ns6__SignerRoleType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__SignerRoleType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__SignerRoleType, sizeof(ns6__SignerRoleType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__SignerRoleType(struct soap *soap, ns6__SignerRoleType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__SignerRoleType(soap, tag ? tag : "ns6:SignerRoleType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__SignerRoleType ** SOAP_FMAC4 soap_get_PointerTons6__SignerRoleType(struct soap *soap, ns6__SignerRoleType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__SignerRoleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__SigningCertificateType(struct soap *soap, ns6__SigningCertificateType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__SigningCertificateType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__SigningCertificateType(struct soap *soap, const char *tag, int id, ns6__SigningCertificateType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__SigningCertificateType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__SigningCertificateType ? type : NULL);
}

SOAP_FMAC3 ns6__SigningCertificateType ** SOAP_FMAC4 soap_in_PointerTons6__SigningCertificateType(struct soap *soap, const char *tag, ns6__SigningCertificateType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__SigningCertificateType **)soap_malloc(soap, sizeof(ns6__SigningCertificateType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__SigningCertificateType *)SCAP_instantiate_ns6__SigningCertificateType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__SigningCertificateType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__SigningCertificateType, sizeof(ns6__SigningCertificateType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__SigningCertificateType(struct soap *soap, ns6__SigningCertificateType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__SigningCertificateType(soap, tag ? tag : "ns6:SigningCertificateType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__SigningCertificateType ** SOAP_FMAC4 soap_get_PointerTons6__SigningCertificateType(struct soap *soap, ns6__SigningCertificateType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__SigningCertificateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__SignedSignaturePropertiesType(struct soap *soap, ns6__SignedSignaturePropertiesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__SignedSignaturePropertiesType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__SignedSignaturePropertiesType(struct soap *soap, const char *tag, int id, ns6__SignedSignaturePropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__SignedSignaturePropertiesType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__SignedSignaturePropertiesType ? type : NULL);
}

SOAP_FMAC3 ns6__SignedSignaturePropertiesType ** SOAP_FMAC4 soap_in_PointerTons6__SignedSignaturePropertiesType(struct soap *soap, const char *tag, ns6__SignedSignaturePropertiesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__SignedSignaturePropertiesType **)soap_malloc(soap, sizeof(ns6__SignedSignaturePropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__SignedSignaturePropertiesType *)SCAP_instantiate_ns6__SignedSignaturePropertiesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__SignedSignaturePropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__SignedSignaturePropertiesType, sizeof(ns6__SignedSignaturePropertiesType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__SignedSignaturePropertiesType(struct soap *soap, ns6__SignedSignaturePropertiesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__SignedSignaturePropertiesType(soap, tag ? tag : "ns6:SignedSignaturePropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__SignedSignaturePropertiesType ** SOAP_FMAC4 soap_get_PointerTons6__SignedSignaturePropertiesType(struct soap *soap, ns6__SignedSignaturePropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__SignedSignaturePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__UnsignedPropertiesType(struct soap *soap, ns6__UnsignedPropertiesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__UnsignedPropertiesType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__UnsignedPropertiesType(struct soap *soap, const char *tag, int id, ns6__UnsignedPropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__UnsignedPropertiesType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__UnsignedPropertiesType ? type : NULL);
}

SOAP_FMAC3 ns6__UnsignedPropertiesType ** SOAP_FMAC4 soap_in_PointerTons6__UnsignedPropertiesType(struct soap *soap, const char *tag, ns6__UnsignedPropertiesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__UnsignedPropertiesType **)soap_malloc(soap, sizeof(ns6__UnsignedPropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__UnsignedPropertiesType *)SCAP_instantiate_ns6__UnsignedPropertiesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__UnsignedPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__UnsignedPropertiesType, sizeof(ns6__UnsignedPropertiesType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__UnsignedPropertiesType(struct soap *soap, ns6__UnsignedPropertiesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__UnsignedPropertiesType(soap, tag ? tag : "ns6:UnsignedPropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__UnsignedPropertiesType ** SOAP_FMAC4 soap_get_PointerTons6__UnsignedPropertiesType(struct soap *soap, ns6__UnsignedPropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__UnsignedPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__SignedPropertiesType(struct soap *soap, ns6__SignedPropertiesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__SignedPropertiesType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__SignedPropertiesType(struct soap *soap, const char *tag, int id, ns6__SignedPropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__SignedPropertiesType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__SignedPropertiesType ? type : NULL);
}

SOAP_FMAC3 ns6__SignedPropertiesType ** SOAP_FMAC4 soap_in_PointerTons6__SignedPropertiesType(struct soap *soap, const char *tag, ns6__SignedPropertiesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__SignedPropertiesType **)soap_malloc(soap, sizeof(ns6__SignedPropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__SignedPropertiesType *)SCAP_instantiate_ns6__SignedPropertiesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__SignedPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__SignedPropertiesType, sizeof(ns6__SignedPropertiesType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__SignedPropertiesType(struct soap *soap, ns6__SignedPropertiesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__SignedPropertiesType(soap, tag ? tag : "ns6:SignedPropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__SignedPropertiesType ** SOAP_FMAC4 soap_get_PointerTons6__SignedPropertiesType(struct soap *soap, ns6__SignedPropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__SignedPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ResponseCodeMessage(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ResponseCodeMessage))
		soap_serialize_ns4__ResponseCodeMessage(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ResponseCodeMessage(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ResponseCodeMessage, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__ResponseCodeMessage(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons4__ResponseCodeMessage(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__ResponseCodeMessage(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ResponseCodeMessage, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ResponseCodeMessage(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons4__ResponseCodeMessage(soap, tag ? tag : "ns4:ResponseCodeMessage", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons4__ResponseCodeMessage(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ResponseCodeMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__SubAttributeValueType(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__SubAttributeValueType))
		soap_serialize_ns4__SubAttributeValueType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__SubAttributeValueType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__SubAttributeValueType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__SubAttributeValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons4__SubAttributeValueType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__SubAttributeValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__SubAttributeValueType, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__SubAttributeValueType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons4__SubAttributeValueType(soap, tag ? tag : "ns4:SubAttributeValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons4__SubAttributeValueType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__SubAttributeValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__SubAttributeType(struct soap *soap, ns3__SubAttributeType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__SubAttributeType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__SubAttributeType(struct soap *soap, const char *tag, int id, ns3__SubAttributeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__SubAttributeType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__SubAttributeType ? type : NULL);
}

SOAP_FMAC3 ns3__SubAttributeType ** SOAP_FMAC4 soap_in_PointerTons3__SubAttributeType(struct soap *soap, const char *tag, ns3__SubAttributeType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__SubAttributeType **)soap_malloc(soap, sizeof(ns3__SubAttributeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__SubAttributeType *)SCAP_instantiate_ns3__SubAttributeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__SubAttributeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__SubAttributeType, sizeof(ns3__SubAttributeType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__SubAttributeType(struct soap *soap, ns3__SubAttributeType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__SubAttributeType(soap, tag ? tag : "ns3:SubAttributeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__SubAttributeType ** SOAP_FMAC4 soap_get_PointerTons3__SubAttributeType(struct soap *soap, ns3__SubAttributeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__SubAttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__SubAttributeListType(struct soap *soap, ns3__SubAttributeListType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__SubAttributeListType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__SubAttributeListType(struct soap *soap, const char *tag, int id, ns3__SubAttributeListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__SubAttributeListType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__SubAttributeListType ? type : NULL);
}

SOAP_FMAC3 ns3__SubAttributeListType ** SOAP_FMAC4 soap_in_PointerTons3__SubAttributeListType(struct soap *soap, const char *tag, ns3__SubAttributeListType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__SubAttributeListType **)soap_malloc(soap, sizeof(ns3__SubAttributeListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__SubAttributeListType *)SCAP_instantiate_ns3__SubAttributeListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__SubAttributeListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__SubAttributeListType, sizeof(ns3__SubAttributeListType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__SubAttributeListType(struct soap *soap, ns3__SubAttributeListType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__SubAttributeListType(soap, tag ? tag : "ns3:SubAttributeListType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__SubAttributeListType ** SOAP_FMAC4 soap_get_PointerTons3__SubAttributeListType(struct soap *soap, ns3__SubAttributeListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__SubAttributeListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__LegalActListType(struct soap *soap, ns3__LegalActListType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__LegalActListType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__LegalActListType(struct soap *soap, const char *tag, int id, ns3__LegalActListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__LegalActListType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__LegalActListType ? type : NULL);
}

SOAP_FMAC3 ns3__LegalActListType ** SOAP_FMAC4 soap_in_PointerTons3__LegalActListType(struct soap *soap, const char *tag, ns3__LegalActListType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__LegalActListType **)soap_malloc(soap, sizeof(ns3__LegalActListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__LegalActListType *)SCAP_instantiate_ns3__LegalActListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__LegalActListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__LegalActListType, sizeof(ns3__LegalActListType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__LegalActListType(struct soap *soap, ns3__LegalActListType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__LegalActListType(soap, tag ? tag : "ns3:LegalActListType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__LegalActListType ** SOAP_FMAC4 soap_get_PointerTons3__LegalActListType(struct soap *soap, ns3__LegalActListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__LegalActListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__DescriptionType(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__DescriptionType))
		soap_serialize_ns4__DescriptionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__DescriptionType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__DescriptionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__DescriptionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons4__DescriptionType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__DescriptionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__DescriptionType, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__DescriptionType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons4__DescriptionType(soap, tag ? tag : "ns4:DescriptionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons4__DescriptionType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__DescriptionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ExtraIDType(struct soap *soap, ns3__ExtraIDType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__ExtraIDType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ExtraIDType(struct soap *soap, const char *tag, int id, ns3__ExtraIDType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ExtraIDType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__ExtraIDType ? type : NULL);
}

SOAP_FMAC3 ns3__ExtraIDType ** SOAP_FMAC4 soap_in_PointerTons3__ExtraIDType(struct soap *soap, const char *tag, ns3__ExtraIDType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ExtraIDType **)soap_malloc(soap, sizeof(ns3__ExtraIDType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ExtraIDType *)SCAP_instantiate_ns3__ExtraIDType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ExtraIDType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ExtraIDType, sizeof(ns3__ExtraIDType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ExtraIDType(struct soap *soap, ns3__ExtraIDType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ExtraIDType(soap, tag ? tag : "ns3:ExtraIDType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ExtraIDType ** SOAP_FMAC4 soap_get_PointerTons3__ExtraIDType(struct soap *soap, ns3__ExtraIDType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ExtraIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ExtraIDListType(struct soap *soap, ns3__ExtraIDListType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__ExtraIDListType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ExtraIDListType(struct soap *soap, const char *tag, int id, ns3__ExtraIDListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ExtraIDListType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__ExtraIDListType ? type : NULL);
}

SOAP_FMAC3 ns3__ExtraIDListType ** SOAP_FMAC4 soap_in_PointerTons3__ExtraIDListType(struct soap *soap, const char *tag, ns3__ExtraIDListType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ExtraIDListType **)soap_malloc(soap, sizeof(ns3__ExtraIDListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ExtraIDListType *)SCAP_instantiate_ns3__ExtraIDListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ExtraIDListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ExtraIDListType, sizeof(ns3__ExtraIDListType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ExtraIDListType(struct soap *soap, ns3__ExtraIDListType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ExtraIDListType(soap, tag ? tag : "ns3:ExtraIDListType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ExtraIDListType ** SOAP_FMAC4 soap_get_PointerTons3__ExtraIDListType(struct soap *soap, ns3__ExtraIDListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ExtraIDListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__MainAttributeType(struct soap *soap, ns3__MainAttributeType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__MainAttributeType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__MainAttributeType(struct soap *soap, const char *tag, int id, ns3__MainAttributeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__MainAttributeType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__MainAttributeType ? type : NULL);
}

SOAP_FMAC3 ns3__MainAttributeType ** SOAP_FMAC4 soap_in_PointerTons3__MainAttributeType(struct soap *soap, const char *tag, ns3__MainAttributeType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__MainAttributeType **)soap_malloc(soap, sizeof(ns3__MainAttributeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__MainAttributeType *)SCAP_instantiate_ns3__MainAttributeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__MainAttributeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__MainAttributeType, sizeof(ns3__MainAttributeType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__MainAttributeType(struct soap *soap, ns3__MainAttributeType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__MainAttributeType(soap, tag ? tag : "ns3:MainAttributeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__MainAttributeType ** SOAP_FMAC4 soap_get_PointerTons3__MainAttributeType(struct soap *soap, ns3__MainAttributeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__MainAttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SVGListType(struct soap *soap, ns7__SVGListType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SVGListType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SVGListType(struct soap *soap, const char *tag, int id, ns7__SVGListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SVGListType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__SVGListType ? type : NULL);
}

SOAP_FMAC3 ns7__SVGListType ** SOAP_FMAC4 soap_in_PointerTons7__SVGListType(struct soap *soap, const char *tag, ns7__SVGListType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__SVGListType **)soap_malloc(soap, sizeof(ns7__SVGListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__SVGListType *)SCAP_instantiate_ns7__SVGListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__SVGListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SVGListType, sizeof(ns7__SVGListType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SVGListType(struct soap *soap, ns7__SVGListType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SVGListType(soap, tag ? tag : "ns7:SVGListType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__SVGListType ** SOAP_FMAC4 soap_get_PointerTons7__SVGListType(struct soap *soap, ns7__SVGListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SVGListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__QualifyingPropertiesType(struct soap *soap, ns6__QualifyingPropertiesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__QualifyingPropertiesType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__QualifyingPropertiesType(struct soap *soap, const char *tag, int id, ns6__QualifyingPropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__QualifyingPropertiesType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns6__QualifyingPropertiesType ? type : NULL);
}

SOAP_FMAC3 ns6__QualifyingPropertiesType ** SOAP_FMAC4 soap_in_PointerTons6__QualifyingPropertiesType(struct soap *soap, const char *tag, ns6__QualifyingPropertiesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__QualifyingPropertiesType **)soap_malloc(soap, sizeof(ns6__QualifyingPropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__QualifyingPropertiesType *)SCAP_instantiate_ns6__QualifyingPropertiesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns6__QualifyingPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__QualifyingPropertiesType, sizeof(ns6__QualifyingPropertiesType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__QualifyingPropertiesType(struct soap *soap, ns6__QualifyingPropertiesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__QualifyingPropertiesType(soap, tag ? tag : "ns6:QualifyingPropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__QualifyingPropertiesType ** SOAP_FMAC4 soap_get_PointerTons6__QualifyingPropertiesType(struct soap *soap, ns6__QualifyingPropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__QualifyingPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__X509CertificateType(struct soap *soap, ns5__X509CertificateType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__X509CertificateType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__X509CertificateType(struct soap *soap, const char *tag, int id, ns5__X509CertificateType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__X509CertificateType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__X509CertificateType ? type : NULL);
}

SOAP_FMAC3 ns5__X509CertificateType ** SOAP_FMAC4 soap_in_PointerTons5__X509CertificateType(struct soap *soap, const char *tag, ns5__X509CertificateType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__X509CertificateType **)soap_malloc(soap, sizeof(ns5__X509CertificateType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__X509CertificateType *)SCAP_instantiate_ns5__X509CertificateType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__X509CertificateType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__X509CertificateType, sizeof(ns5__X509CertificateType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__X509CertificateType(struct soap *soap, ns5__X509CertificateType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__X509CertificateType(soap, tag ? tag : "ns5:X509CertificateType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__X509CertificateType ** SOAP_FMAC4 soap_get_PointerTons5__X509CertificateType(struct soap *soap, ns5__X509CertificateType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__X509CertificateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__X509DataType(struct soap *soap, ns5__X509DataType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__X509DataType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__X509DataType(struct soap *soap, const char *tag, int id, ns5__X509DataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__X509DataType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__X509DataType ? type : NULL);
}

SOAP_FMAC3 ns5__X509DataType ** SOAP_FMAC4 soap_in_PointerTons5__X509DataType(struct soap *soap, const char *tag, ns5__X509DataType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__X509DataType **)soap_malloc(soap, sizeof(ns5__X509DataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__X509DataType *)SCAP_instantiate_ns5__X509DataType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__X509DataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__X509DataType, sizeof(ns5__X509DataType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__X509DataType(struct soap *soap, ns5__X509DataType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__X509DataType(soap, tag ? tag : "ns5:X509DataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__X509DataType ** SOAP_FMAC4 soap_get_PointerTons5__X509DataType(struct soap *soap, ns5__X509DataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__TransformType(struct soap *soap, ns5__TransformType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__TransformType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__TransformType(struct soap *soap, const char *tag, int id, ns5__TransformType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__TransformType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__TransformType ? type : NULL);
}

SOAP_FMAC3 ns5__TransformType ** SOAP_FMAC4 soap_in_PointerTons5__TransformType(struct soap *soap, const char *tag, ns5__TransformType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__TransformType **)soap_malloc(soap, sizeof(ns5__TransformType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__TransformType *)SCAP_instantiate_ns5__TransformType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__TransformType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__TransformType, sizeof(ns5__TransformType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__TransformType(struct soap *soap, ns5__TransformType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__TransformType(soap, tag ? tag : "ns5:TransformType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__TransformType ** SOAP_FMAC4 soap_get_PointerTons5__TransformType(struct soap *soap, ns5__TransformType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__DigestValueType(struct soap *soap, ns5__DigestValueType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__DigestValueType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__DigestValueType(struct soap *soap, const char *tag, int id, ns5__DigestValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__DigestValueType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__DigestValueType ? type : NULL);
}

SOAP_FMAC3 ns5__DigestValueType ** SOAP_FMAC4 soap_in_PointerTons5__DigestValueType(struct soap *soap, const char *tag, ns5__DigestValueType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__DigestValueType **)soap_malloc(soap, sizeof(ns5__DigestValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__DigestValueType *)SCAP_instantiate_ns5__DigestValueType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__DigestValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__DigestValueType, sizeof(ns5__DigestValueType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__DigestValueType(struct soap *soap, ns5__DigestValueType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__DigestValueType(soap, tag ? tag : "ns5:DigestValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__DigestValueType ** SOAP_FMAC4 soap_get_PointerTons5__DigestValueType(struct soap *soap, ns5__DigestValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__DigestValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__DigestMethodType(struct soap *soap, ns5__DigestMethodType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__DigestMethodType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__DigestMethodType(struct soap *soap, const char *tag, int id, ns5__DigestMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__DigestMethodType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__DigestMethodType ? type : NULL);
}

SOAP_FMAC3 ns5__DigestMethodType ** SOAP_FMAC4 soap_in_PointerTons5__DigestMethodType(struct soap *soap, const char *tag, ns5__DigestMethodType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__DigestMethodType **)soap_malloc(soap, sizeof(ns5__DigestMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__DigestMethodType *)SCAP_instantiate_ns5__DigestMethodType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__DigestMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__DigestMethodType, sizeof(ns5__DigestMethodType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__DigestMethodType(struct soap *soap, ns5__DigestMethodType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__DigestMethodType(soap, tag ? tag : "ns5:DigestMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__DigestMethodType ** SOAP_FMAC4 soap_get_PointerTons5__DigestMethodType(struct soap *soap, ns5__DigestMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__TransformsType(struct soap *soap, ns5__TransformsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__TransformsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__TransformsType(struct soap *soap, const char *tag, int id, ns5__TransformsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__TransformsType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__TransformsType ? type : NULL);
}

SOAP_FMAC3 ns5__TransformsType ** SOAP_FMAC4 soap_in_PointerTons5__TransformsType(struct soap *soap, const char *tag, ns5__TransformsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__TransformsType **)soap_malloc(soap, sizeof(ns5__TransformsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__TransformsType *)SCAP_instantiate_ns5__TransformsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__TransformsType, sizeof(ns5__TransformsType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__TransformsType(struct soap *soap, ns5__TransformsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__TransformsType(soap, tag ? tag : "ns5:TransformsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__TransformsType ** SOAP_FMAC4 soap_get_PointerTons5__TransformsType(struct soap *soap, ns5__TransformsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ReferenceType(struct soap *soap, ns5__ReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__ReferenceType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__ReferenceType(struct soap *soap, const char *tag, int id, ns5__ReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__ReferenceType ? type : NULL);
}

SOAP_FMAC3 ns5__ReferenceType ** SOAP_FMAC4 soap_in_PointerTons5__ReferenceType(struct soap *soap, const char *tag, ns5__ReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__ReferenceType **)soap_malloc(soap, sizeof(ns5__ReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__ReferenceType *)SCAP_instantiate_ns5__ReferenceType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ReferenceType, sizeof(ns5__ReferenceType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ReferenceType(struct soap *soap, ns5__ReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__ReferenceType(soap, tag ? tag : "ns5:ReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ReferenceType ** SOAP_FMAC4 soap_get_PointerTons5__ReferenceType(struct soap *soap, ns5__ReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__SignatureMethodType(struct soap *soap, ns5__SignatureMethodType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__SignatureMethodType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__SignatureMethodType(struct soap *soap, const char *tag, int id, ns5__SignatureMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__SignatureMethodType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__SignatureMethodType ? type : NULL);
}

SOAP_FMAC3 ns5__SignatureMethodType ** SOAP_FMAC4 soap_in_PointerTons5__SignatureMethodType(struct soap *soap, const char *tag, ns5__SignatureMethodType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__SignatureMethodType **)soap_malloc(soap, sizeof(ns5__SignatureMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__SignatureMethodType *)SCAP_instantiate_ns5__SignatureMethodType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__SignatureMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__SignatureMethodType, sizeof(ns5__SignatureMethodType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__SignatureMethodType(struct soap *soap, ns5__SignatureMethodType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__SignatureMethodType(soap, tag ? tag : "ns5:SignatureMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__SignatureMethodType ** SOAP_FMAC4 soap_get_PointerTons5__SignatureMethodType(struct soap *soap, ns5__SignatureMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__CanonicalizationMethodType(struct soap *soap, ns5__CanonicalizationMethodType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__CanonicalizationMethodType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, ns5__CanonicalizationMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__CanonicalizationMethodType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__CanonicalizationMethodType ? type : NULL);
}

SOAP_FMAC3 ns5__CanonicalizationMethodType ** SOAP_FMAC4 soap_in_PointerTons5__CanonicalizationMethodType(struct soap *soap, const char *tag, ns5__CanonicalizationMethodType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__CanonicalizationMethodType **)soap_malloc(soap, sizeof(ns5__CanonicalizationMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__CanonicalizationMethodType *)SCAP_instantiate_ns5__CanonicalizationMethodType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__CanonicalizationMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CanonicalizationMethodType, sizeof(ns5__CanonicalizationMethodType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__CanonicalizationMethodType(struct soap *soap, ns5__CanonicalizationMethodType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__CanonicalizationMethodType(soap, tag ? tag : "ns5:CanonicalizationMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__CanonicalizationMethodType ** SOAP_FMAC4 soap_get_PointerTons5__CanonicalizationMethodType(struct soap *soap, ns5__CanonicalizationMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ObjectType(struct soap *soap, ns5__ObjectType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__ObjectType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__ObjectType(struct soap *soap, const char *tag, int id, ns5__ObjectType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ObjectType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__ObjectType ? type : NULL);
}

SOAP_FMAC3 ns5__ObjectType ** SOAP_FMAC4 soap_in_PointerTons5__ObjectType(struct soap *soap, const char *tag, ns5__ObjectType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__ObjectType **)soap_malloc(soap, sizeof(ns5__ObjectType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__ObjectType *)SCAP_instantiate_ns5__ObjectType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__ObjectType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ObjectType, sizeof(ns5__ObjectType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ObjectType(struct soap *soap, ns5__ObjectType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__ObjectType(soap, tag ? tag : "ns5:ObjectType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ObjectType ** SOAP_FMAC4 soap_get_PointerTons5__ObjectType(struct soap *soap, ns5__ObjectType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__ObjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__KeyInfoType(struct soap *soap, ns5__KeyInfoType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__KeyInfoType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__KeyInfoType(struct soap *soap, const char *tag, int id, ns5__KeyInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__KeyInfoType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__KeyInfoType ? type : NULL);
}

SOAP_FMAC3 ns5__KeyInfoType ** SOAP_FMAC4 soap_in_PointerTons5__KeyInfoType(struct soap *soap, const char *tag, ns5__KeyInfoType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__KeyInfoType **)soap_malloc(soap, sizeof(ns5__KeyInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__KeyInfoType *)SCAP_instantiate_ns5__KeyInfoType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__KeyInfoType, sizeof(ns5__KeyInfoType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__KeyInfoType(struct soap *soap, ns5__KeyInfoType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__KeyInfoType(soap, tag ? tag : "ns5:KeyInfoType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__KeyInfoType ** SOAP_FMAC4 soap_get_PointerTons5__KeyInfoType(struct soap *soap, ns5__KeyInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__SignatureValueType(struct soap *soap, ns5__SignatureValueType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__SignatureValueType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__SignatureValueType(struct soap *soap, const char *tag, int id, ns5__SignatureValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__SignatureValueType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__SignatureValueType ? type : NULL);
}

SOAP_FMAC3 ns5__SignatureValueType ** SOAP_FMAC4 soap_in_PointerTons5__SignatureValueType(struct soap *soap, const char *tag, ns5__SignatureValueType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__SignatureValueType **)soap_malloc(soap, sizeof(ns5__SignatureValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__SignatureValueType *)SCAP_instantiate_ns5__SignatureValueType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__SignatureValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__SignatureValueType, sizeof(ns5__SignatureValueType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__SignatureValueType(struct soap *soap, ns5__SignatureValueType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__SignatureValueType(soap, tag ? tag : "ns5:SignatureValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__SignatureValueType ** SOAP_FMAC4 soap_get_PointerTons5__SignatureValueType(struct soap *soap, ns5__SignatureValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__SignatureValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__SignedInfoType(struct soap *soap, ns5__SignedInfoType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__SignedInfoType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__SignedInfoType(struct soap *soap, const char *tag, int id, ns5__SignedInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__SignedInfoType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__SignedInfoType ? type : NULL);
}

SOAP_FMAC3 ns5__SignedInfoType ** SOAP_FMAC4 soap_in_PointerTons5__SignedInfoType(struct soap *soap, const char *tag, ns5__SignedInfoType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__SignedInfoType **)soap_malloc(soap, sizeof(ns5__SignedInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__SignedInfoType *)SCAP_instantiate_ns5__SignedInfoType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__SignedInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__SignedInfoType, sizeof(ns5__SignedInfoType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__SignedInfoType(struct soap *soap, ns5__SignedInfoType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__SignedInfoType(soap, tag ? tag : "ns5:SignedInfoType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__SignedInfoType ** SOAP_FMAC4 soap_get_PointerTons5__SignedInfoType(struct soap *soap, ns5__SignedInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__AttributeType(struct soap *soap, ns3__AttributeType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__AttributeType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__AttributeType(struct soap *soap, const char *tag, int id, ns3__AttributeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__AttributeType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__AttributeType ? type : NULL);
}

SOAP_FMAC3 ns3__AttributeType ** SOAP_FMAC4 soap_in_PointerTons3__AttributeType(struct soap *soap, const char *tag, ns3__AttributeType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__AttributeType **)soap_malloc(soap, sizeof(ns3__AttributeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__AttributeType *)SCAP_instantiate_ns3__AttributeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__AttributeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__AttributeType, sizeof(ns3__AttributeType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__AttributeType(struct soap *soap, ns3__AttributeType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__AttributeType(soap, tag ? tag : "ns3:AttributeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__AttributeType ** SOAP_FMAC4 soap_get_PointerTons3__AttributeType(struct soap *soap, ns3__AttributeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__AttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__SignatureType(struct soap *soap, ns5__SignatureType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__SignatureType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__SignatureType(struct soap *soap, const char *tag, int id, ns5__SignatureType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__SignatureType, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns5__SignatureType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns5__SignatureType ** SOAP_FMAC4 soap_in_PointerTons5__SignatureType(struct soap *soap, const char *tag, ns5__SignatureType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__SignatureType **)soap_malloc(soap, sizeof(ns5__SignatureType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__SignatureType *)SCAP_instantiate_ns5__SignatureType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns5__SignatureType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__SignatureType, sizeof(ns5__SignatureType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__SignatureType(struct soap *soap, ns5__SignatureType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__SignatureType(soap, tag ? tag : "ns5:SignatureType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__SignatureType ** SOAP_FMAC4 soap_get_PointerTons5__SignatureType(struct soap *soap, ns5__SignatureType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__UnsignedAttributesBasicType(struct soap *soap, ns2__UnsignedAttributesBasicType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__UnsignedAttributesBasicType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__UnsignedAttributesBasicType(struct soap *soap, const char *tag, int id, ns2__UnsignedAttributesBasicType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__UnsignedAttributesBasicType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__UnsignedAttributesBasicType ? type : NULL);
}

SOAP_FMAC3 ns2__UnsignedAttributesBasicType ** SOAP_FMAC4 soap_in_PointerTons2__UnsignedAttributesBasicType(struct soap *soap, const char *tag, ns2__UnsignedAttributesBasicType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__UnsignedAttributesBasicType **)soap_malloc(soap, sizeof(ns2__UnsignedAttributesBasicType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__UnsignedAttributesBasicType *)SCAP_instantiate_ns2__UnsignedAttributesBasicType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__UnsignedAttributesBasicType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__UnsignedAttributesBasicType, sizeof(ns2__UnsignedAttributesBasicType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__UnsignedAttributesBasicType(struct soap *soap, ns2__UnsignedAttributesBasicType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__UnsignedAttributesBasicType(soap, tag ? tag : "ns2:UnsignedAttributesBasicType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__UnsignedAttributesBasicType ** SOAP_FMAC4 soap_get_PointerTons2__UnsignedAttributesBasicType(struct soap *soap, ns2__UnsignedAttributesBasicType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__UnsignedAttributesBasicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SignedAttributesType(struct soap *soap, ns2__SignedAttributesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SignedAttributesType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SignedAttributesType(struct soap *soap, const char *tag, int id, ns2__SignedAttributesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SignedAttributesType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__SignedAttributesType ? type : NULL);
}

SOAP_FMAC3 ns2__SignedAttributesType ** SOAP_FMAC4 soap_in_PointerTons2__SignedAttributesType(struct soap *soap, const char *tag, ns2__SignedAttributesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__SignedAttributesType **)soap_malloc(soap, sizeof(ns2__SignedAttributesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__SignedAttributesType *)SCAP_instantiate_ns2__SignedAttributesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__SignedAttributesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SignedAttributesType, sizeof(ns2__SignedAttributesType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SignedAttributesType(struct soap *soap, ns2__SignedAttributesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__SignedAttributesType(soap, tag ? tag : "ns2:SignedAttributesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__SignedAttributesType ** SOAP_FMAC4 soap_get_PointerTons2__SignedAttributesType(struct soap *soap, ns2__SignedAttributesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SignedAttributesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ResponseResult(struct soap *soap, ns2__ResponseResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ResponseResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ResponseResult(struct soap *soap, const char *tag, int id, ns2__ResponseResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ResponseResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__ResponseResult ? type : NULL);
}

SOAP_FMAC3 ns2__ResponseResult ** SOAP_FMAC4 soap_in_PointerTons2__ResponseResult(struct soap *soap, const char *tag, ns2__ResponseResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ResponseResult **)soap_malloc(soap, sizeof(ns2__ResponseResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ResponseResult *)SCAP_instantiate_ns2__ResponseResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ResponseResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ResponseResult, sizeof(ns2__ResponseResult), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ResponseResult(struct soap *soap, ns2__ResponseResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ResponseResult(soap, tag ? tag : "ns2:ResponseResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ResponseResult ** SOAP_FMAC4 soap_get_PointerTons2__ResponseResult(struct soap *soap, ns2__ResponseResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ResponseResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__UnsignedAttributesType(struct soap *soap, ns2__UnsignedAttributesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__UnsignedAttributesType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__UnsignedAttributesType(struct soap *soap, const char *tag, int id, ns2__UnsignedAttributesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__UnsignedAttributesType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__UnsignedAttributesType ? type : NULL);
}

SOAP_FMAC3 ns2__UnsignedAttributesType ** SOAP_FMAC4 soap_in_PointerTons2__UnsignedAttributesType(struct soap *soap, const char *tag, ns2__UnsignedAttributesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__UnsignedAttributesType **)soap_malloc(soap, sizeof(ns2__UnsignedAttributesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__UnsignedAttributesType *)SCAP_instantiate_ns2__UnsignedAttributesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__UnsignedAttributesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__UnsignedAttributesType, sizeof(ns2__UnsignedAttributesType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__UnsignedAttributesType(struct soap *soap, ns2__UnsignedAttributesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__UnsignedAttributesType(soap, tag ? tag : "ns2:UnsignedAttributesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__UnsignedAttributesType ** SOAP_FMAC4 soap_get_PointerTons2__UnsignedAttributesType(struct soap *soap, ns2__UnsignedAttributesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__UnsignedAttributesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AttributesType(struct soap *soap, ns2__AttributesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AttributesType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AttributesType(struct soap *soap, const char *tag, int id, ns2__AttributesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AttributesType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__AttributesType ? type : NULL);
}

SOAP_FMAC3 ns2__AttributesType ** SOAP_FMAC4 soap_in_PointerTons2__AttributesType(struct soap *soap, const char *tag, ns2__AttributesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AttributesType **)soap_malloc(soap, sizeof(ns2__AttributesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AttributesType *)SCAP_instantiate_ns2__AttributesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__AttributesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AttributesType, sizeof(ns2__AttributesType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AttributesType(struct soap *soap, ns2__AttributesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__AttributesType(soap, tag ? tag : "ns2:AttributesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AttributesType ** SOAP_FMAC4 soap_get_PointerTons2__AttributesType(struct soap *soap, ns2__AttributesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AttributesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__CompanyNameType(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__CompanyNameType))
		soap_serialize_ns4__CompanyNameType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__CompanyNameType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__CompanyNameType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__CompanyNameType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons4__CompanyNameType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__CompanyNameType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__CompanyNameType, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__CompanyNameType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons4__CompanyNameType(soap, tag ? tag : "ns4:CompanyNameType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons4__CompanyNameType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__CompanyNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__NIPCType(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__NIPCType))
		soap_serialize_ns4__NIPCType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__NIPCType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__NIPCType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__NIPCType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons4__NIPCType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__NIPCType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__NIPCType, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__NIPCType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons4__NIPCType(soap, tag ? tag : "ns4:NIPCType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons4__NIPCType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__NIPCType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__AttributeSupplierType(struct soap *soap, ns3__AttributeSupplierType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__AttributeSupplierType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__AttributeSupplierType(struct soap *soap, const char *tag, int id, ns3__AttributeSupplierType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__AttributeSupplierType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__AttributeSupplierType ? type : NULL);
}

SOAP_FMAC3 ns3__AttributeSupplierType ** SOAP_FMAC4 soap_in_PointerTons3__AttributeSupplierType(struct soap *soap, const char *tag, ns3__AttributeSupplierType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__AttributeSupplierType **)soap_malloc(soap, sizeof(ns3__AttributeSupplierType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__AttributeSupplierType *)SCAP_instantiate_ns3__AttributeSupplierType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__AttributeSupplierType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__AttributeSupplierType, sizeof(ns3__AttributeSupplierType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__AttributeSupplierType(struct soap *soap, ns3__AttributeSupplierType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__AttributeSupplierType(soap, tag ? tag : "ns3:AttributeSupplierType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__AttributeSupplierType ** SOAP_FMAC4 soap_get_PointerTons3__AttributeSupplierType(struct soap *soap, ns3__AttributeSupplierType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__AttributeSupplierType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTobool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AttributeSupplierListType(struct soap *soap, ns2__AttributeSupplierListType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AttributeSupplierListType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AttributeSupplierListType(struct soap *soap, const char *tag, int id, ns2__AttributeSupplierListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AttributeSupplierListType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__AttributeSupplierListType ? type : NULL);
}

SOAP_FMAC3 ns2__AttributeSupplierListType ** SOAP_FMAC4 soap_in_PointerTons2__AttributeSupplierListType(struct soap *soap, const char *tag, ns2__AttributeSupplierListType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AttributeSupplierListType **)soap_malloc(soap, sizeof(ns2__AttributeSupplierListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AttributeSupplierListType *)SCAP_instantiate_ns2__AttributeSupplierListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__AttributeSupplierListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AttributeSupplierListType, sizeof(ns2__AttributeSupplierListType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AttributeSupplierListType(struct soap *soap, ns2__AttributeSupplierListType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__AttributeSupplierListType(soap, tag ? tag : "ns2:AttributeSupplierListType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AttributeSupplierListType ** SOAP_FMAC4 soap_get_PointerTons2__AttributeSupplierListType(struct soap *soap, ns2__AttributeSupplierListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AttributeSupplierListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__PersonalDataType(struct soap *soap, ns3__PersonalDataType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__PersonalDataType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__PersonalDataType(struct soap *soap, const char *tag, int id, ns3__PersonalDataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__PersonalDataType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__PersonalDataType ? type : NULL);
}

SOAP_FMAC3 ns3__PersonalDataType ** SOAP_FMAC4 soap_in_PointerTons3__PersonalDataType(struct soap *soap, const char *tag, ns3__PersonalDataType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__PersonalDataType **)soap_malloc(soap, sizeof(ns3__PersonalDataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__PersonalDataType *)SCAP_instantiate_ns3__PersonalDataType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__PersonalDataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__PersonalDataType, sizeof(ns3__PersonalDataType), 0, SCAP_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__PersonalDataType(struct soap *soap, ns3__PersonalDataType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__PersonalDataType(soap, tag ? tag : "ns3:PersonalDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__PersonalDataType ** SOAP_FMAC4 soap_get_PointerTons3__PersonalDataType(struct soap *soap, ns3__PersonalDataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__PersonalDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTounsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__TransactionType(struct soap *soap, std::vector<ns1__TransactionType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__TransactionType(struct soap *soap, const std::vector<ns1__TransactionType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__TransactionType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__TransactionType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__TransactionType(struct soap *soap, const char *tag, int id, const std::vector<ns1__TransactionType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__TransactionType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__TransactionType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__TransactionType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__TransactionType(struct soap *soap, const char *tag, std::vector<ns1__TransactionType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__TransactionType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__TransactionType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__TransactionType, SOAP_TYPE_std__vectorTemplateOfPointerTons1__TransactionType, sizeof(ns1__TransactionType), 1, SCAP_finsert, SCAP_fbase))
				break;
			if (!soap_in_PointerTons1__TransactionType(soap, tag, NULL, "ns1:TransactionType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__TransactionType(soap, tag, &n, "ns1:TransactionType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__TransactionType *>  * SOAP_FMAC2 SCAP_instantiate_std__vectorTemplateOfPointerTons1__TransactionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_std__vectorTemplateOfPointerTons1__TransactionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__TransactionType *> *p;
	size_t k = sizeof(std::vector<ns1__TransactionType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__TransactionType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__TransactionType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__TransactionType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons1__TransactionType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SubAttributeType(struct soap *soap, std::vector<ns1__SubAttributeType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SubAttributeType(struct soap *soap, const std::vector<ns1__SubAttributeType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__SubAttributeType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__SubAttributeType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SubAttributeType(struct soap *soap, const char *tag, int id, const std::vector<ns1__SubAttributeType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__SubAttributeType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__SubAttributeType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__SubAttributeType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SubAttributeType(struct soap *soap, const char *tag, std::vector<ns1__SubAttributeType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__SubAttributeType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__SubAttributeType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__SubAttributeType, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubAttributeType, sizeof(ns1__SubAttributeType), 1, SCAP_finsert, SCAP_fbase))
				break;
			if (!soap_in_PointerTons1__SubAttributeType(soap, tag, NULL, "ns1:SubAttributeType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__SubAttributeType(soap, tag, &n, "ns1:SubAttributeType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__SubAttributeType *>  * SOAP_FMAC2 SCAP_instantiate_std__vectorTemplateOfPointerTons1__SubAttributeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_std__vectorTemplateOfPointerTons1__SubAttributeType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__SubAttributeType *> *p;
	size_t k = sizeof(std::vector<ns1__SubAttributeType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__SubAttributeType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__SubAttributeType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__SubAttributeType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubAttributeType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_std__string(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0, SCAP_finsert, SCAP_fbase))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{	if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 SCAP_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_std__vectorTemplateOfstd__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfstd__string, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__AttributeType(struct soap *soap, std::vector<ns1__AttributeType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__AttributeType(struct soap *soap, const std::vector<ns1__AttributeType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__AttributeType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__AttributeType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__AttributeType(struct soap *soap, const char *tag, int id, const std::vector<ns1__AttributeType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__AttributeType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__AttributeType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__AttributeType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__AttributeType(struct soap *soap, const char *tag, std::vector<ns1__AttributeType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__AttributeType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__AttributeType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__AttributeType, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AttributeType, sizeof(ns1__AttributeType), 1, SCAP_finsert, SCAP_fbase))
				break;
			if (!soap_in_PointerTons1__AttributeType(soap, tag, NULL, "ns1:AttributeType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__AttributeType(soap, tag, &n, "ns1:AttributeType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__AttributeType *>  * SOAP_FMAC2 SCAP_instantiate_std__vectorTemplateOfPointerTons1__AttributeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_std__vectorTemplateOfPointerTons1__AttributeType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__AttributeType *> *p;
	size_t k = sizeof(std::vector<ns1__AttributeType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__AttributeType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__AttributeType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__AttributeType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AttributeType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns7__SVGType(struct soap *soap, std::vector<xsd__base64Binary> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns7__SVGType(struct soap *soap, const std::vector<xsd__base64Binary> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<xsd__base64Binary> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_ns7__SVGType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns7__SVGType(struct soap *soap, const char *tag, int id, const std::vector<xsd__base64Binary> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<xsd__base64Binary> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ns7__SVGType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<xsd__base64Binary> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns7__SVGType(struct soap *soap, const char *tag, std::vector<xsd__base64Binary> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns7__SVGType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		xsd__base64Binary n;
		soap_default_ns7__SVGType(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns7__SVGType, SOAP_TYPE_std__vectorTemplateOfns7__SVGType, sizeof(xsd__base64Binary), 0, SCAP_finsert, SCAP_fbase))
				break;
			if (!soap_in_ns7__SVGType(soap, tag, NULL, "ns7:SVGType"))
				break;
		}
		else
		{	if (!soap_in_ns7__SVGType(soap, tag, &n, "ns7:SVGType"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xsd__base64Binary));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(xsd__base64Binary));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xsd__base64Binary));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<xsd__base64Binary>  * SOAP_FMAC2 SCAP_instantiate_std__vectorTemplateOfns7__SVGType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_std__vectorTemplateOfns7__SVGType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<xsd__base64Binary> *p;
	size_t k = sizeof(std::vector<xsd__base64Binary> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<xsd__base64Binary> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<xsd__base64Binary> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<xsd__base64Binary>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfns7__SVGType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons6__EncapsulatedOCSPValueType(struct soap *soap, std::vector<ns6__EncapsulatedOCSPValueType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons6__EncapsulatedOCSPValueType(struct soap *soap, const std::vector<ns6__EncapsulatedOCSPValueType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns6__EncapsulatedOCSPValueType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons6__EncapsulatedOCSPValueType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons6__EncapsulatedOCSPValueType(struct soap *soap, const char *tag, int id, const std::vector<ns6__EncapsulatedOCSPValueType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns6__EncapsulatedOCSPValueType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons6__EncapsulatedOCSPValueType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns6__EncapsulatedOCSPValueType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons6__EncapsulatedOCSPValueType(struct soap *soap, const char *tag, std::vector<ns6__EncapsulatedOCSPValueType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons6__EncapsulatedOCSPValueType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns6__EncapsulatedOCSPValueType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns6__EncapsulatedOCSPValueType, SOAP_TYPE_std__vectorTemplateOfPointerTons6__EncapsulatedOCSPValueType, sizeof(ns6__EncapsulatedOCSPValueType), 1, SCAP_finsert, SCAP_fbase))
				break;
			if (!soap_in_PointerTons6__EncapsulatedOCSPValueType(soap, tag, NULL, "ns6:EncapsulatedOCSPValueType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons6__EncapsulatedOCSPValueType(soap, tag, &n, "ns6:EncapsulatedOCSPValueType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns6__EncapsulatedOCSPValueType *>  * SOAP_FMAC2 SCAP_instantiate_std__vectorTemplateOfPointerTons6__EncapsulatedOCSPValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_std__vectorTemplateOfPointerTons6__EncapsulatedOCSPValueType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns6__EncapsulatedOCSPValueType *> *p;
	size_t k = sizeof(std::vector<ns6__EncapsulatedOCSPValueType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns6__EncapsulatedOCSPValueType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns6__EncapsulatedOCSPValueType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns6__EncapsulatedOCSPValueType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons6__EncapsulatedOCSPValueType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons6__EncapsulatedCRLValueType(struct soap *soap, std::vector<ns6__EncapsulatedCRLValueType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons6__EncapsulatedCRLValueType(struct soap *soap, const std::vector<ns6__EncapsulatedCRLValueType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns6__EncapsulatedCRLValueType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons6__EncapsulatedCRLValueType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons6__EncapsulatedCRLValueType(struct soap *soap, const char *tag, int id, const std::vector<ns6__EncapsulatedCRLValueType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns6__EncapsulatedCRLValueType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons6__EncapsulatedCRLValueType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns6__EncapsulatedCRLValueType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons6__EncapsulatedCRLValueType(struct soap *soap, const char *tag, std::vector<ns6__EncapsulatedCRLValueType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons6__EncapsulatedCRLValueType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns6__EncapsulatedCRLValueType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns6__EncapsulatedCRLValueType, SOAP_TYPE_std__vectorTemplateOfPointerTons6__EncapsulatedCRLValueType, sizeof(ns6__EncapsulatedCRLValueType), 1, SCAP_finsert, SCAP_fbase))
				break;
			if (!soap_in_PointerTons6__EncapsulatedCRLValueType(soap, tag, NULL, "ns6:EncapsulatedCRLValueType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons6__EncapsulatedCRLValueType(soap, tag, &n, "ns6:EncapsulatedCRLValueType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns6__EncapsulatedCRLValueType *>  * SOAP_FMAC2 SCAP_instantiate_std__vectorTemplateOfPointerTons6__EncapsulatedCRLValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_std__vectorTemplateOfPointerTons6__EncapsulatedCRLValueType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns6__EncapsulatedCRLValueType *> *p;
	size_t k = sizeof(std::vector<ns6__EncapsulatedCRLValueType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns6__EncapsulatedCRLValueType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns6__EncapsulatedCRLValueType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns6__EncapsulatedCRLValueType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons6__EncapsulatedCRLValueType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons6__EncapsulatedX509CertificateType(struct soap *soap, std::vector<ns6__EncapsulatedX509CertificateType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons6__EncapsulatedX509CertificateType(struct soap *soap, const std::vector<ns6__EncapsulatedX509CertificateType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns6__EncapsulatedX509CertificateType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons6__EncapsulatedX509CertificateType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons6__EncapsulatedX509CertificateType(struct soap *soap, const char *tag, int id, const std::vector<ns6__EncapsulatedX509CertificateType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns6__EncapsulatedX509CertificateType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons6__EncapsulatedX509CertificateType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns6__EncapsulatedX509CertificateType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons6__EncapsulatedX509CertificateType(struct soap *soap, const char *tag, std::vector<ns6__EncapsulatedX509CertificateType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons6__EncapsulatedX509CertificateType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns6__EncapsulatedX509CertificateType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns6__EncapsulatedX509CertificateType, SOAP_TYPE_std__vectorTemplateOfPointerTons6__EncapsulatedX509CertificateType, sizeof(ns6__EncapsulatedX509CertificateType), 1, SCAP_finsert, SCAP_fbase))
				break;
			if (!soap_in_PointerTons6__EncapsulatedX509CertificateType(soap, tag, NULL, "ns6:EncapsulatedX509CertificateType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons6__EncapsulatedX509CertificateType(soap, tag, &n, "ns6:EncapsulatedX509CertificateType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns6__EncapsulatedX509CertificateType *>  * SOAP_FMAC2 SCAP_instantiate_std__vectorTemplateOfPointerTons6__EncapsulatedX509CertificateType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_std__vectorTemplateOfPointerTons6__EncapsulatedX509CertificateType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns6__EncapsulatedX509CertificateType *> *p;
	size_t k = sizeof(std::vector<ns6__EncapsulatedX509CertificateType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns6__EncapsulatedX509CertificateType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns6__EncapsulatedX509CertificateType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns6__EncapsulatedX509CertificateType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons6__EncapsulatedX509CertificateType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons6__OCSPRefType(struct soap *soap, std::vector<ns6__OCSPRefType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons6__OCSPRefType(struct soap *soap, const std::vector<ns6__OCSPRefType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns6__OCSPRefType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons6__OCSPRefType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons6__OCSPRefType(struct soap *soap, const char *tag, int id, const std::vector<ns6__OCSPRefType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns6__OCSPRefType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons6__OCSPRefType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns6__OCSPRefType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons6__OCSPRefType(struct soap *soap, const char *tag, std::vector<ns6__OCSPRefType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons6__OCSPRefType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns6__OCSPRefType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns6__OCSPRefType, SOAP_TYPE_std__vectorTemplateOfPointerTons6__OCSPRefType, sizeof(ns6__OCSPRefType), 1, SCAP_finsert, SCAP_fbase))
				break;
			if (!soap_in_PointerTons6__OCSPRefType(soap, tag, NULL, "ns6:OCSPRefType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons6__OCSPRefType(soap, tag, &n, "ns6:OCSPRefType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns6__OCSPRefType *>  * SOAP_FMAC2 SCAP_instantiate_std__vectorTemplateOfPointerTons6__OCSPRefType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_std__vectorTemplateOfPointerTons6__OCSPRefType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns6__OCSPRefType *> *p;
	size_t k = sizeof(std::vector<ns6__OCSPRefType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns6__OCSPRefType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns6__OCSPRefType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns6__OCSPRefType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons6__OCSPRefType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons6__CRLRefType(struct soap *soap, std::vector<ns6__CRLRefType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons6__CRLRefType(struct soap *soap, const std::vector<ns6__CRLRefType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns6__CRLRefType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons6__CRLRefType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons6__CRLRefType(struct soap *soap, const char *tag, int id, const std::vector<ns6__CRLRefType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns6__CRLRefType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons6__CRLRefType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns6__CRLRefType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons6__CRLRefType(struct soap *soap, const char *tag, std::vector<ns6__CRLRefType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons6__CRLRefType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns6__CRLRefType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns6__CRLRefType, SOAP_TYPE_std__vectorTemplateOfPointerTons6__CRLRefType, sizeof(ns6__CRLRefType), 1, SCAP_finsert, SCAP_fbase))
				break;
			if (!soap_in_PointerTons6__CRLRefType(soap, tag, NULL, "ns6:CRLRefType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons6__CRLRefType(soap, tag, &n, "ns6:CRLRefType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns6__CRLRefType *>  * SOAP_FMAC2 SCAP_instantiate_std__vectorTemplateOfPointerTons6__CRLRefType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_std__vectorTemplateOfPointerTons6__CRLRefType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns6__CRLRefType *> *p;
	size_t k = sizeof(std::vector<ns6__CRLRefType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns6__CRLRefType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns6__CRLRefType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns6__CRLRefType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons6__CRLRefType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons6__CertType(struct soap *soap, std::vector<ns6__CertType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons6__CertType(struct soap *soap, const std::vector<ns6__CertType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns6__CertType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons6__CertType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons6__CertType(struct soap *soap, const char *tag, int id, const std::vector<ns6__CertType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns6__CertType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons6__CertType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns6__CertType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons6__CertType(struct soap *soap, const char *tag, std::vector<ns6__CertType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons6__CertType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns6__CertType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns6__CertType, SOAP_TYPE_std__vectorTemplateOfPointerTons6__CertType, sizeof(ns6__CertType), 1, SCAP_finsert, SCAP_fbase))
				break;
			if (!soap_in_PointerTons6__CertType(soap, tag, NULL, "ns6:CertType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons6__CertType(soap, tag, &n, "ns6:CertType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns6__CertType *>  * SOAP_FMAC2 SCAP_instantiate_std__vectorTemplateOfPointerTons6__CertType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_std__vectorTemplateOfPointerTons6__CertType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns6__CertType *> *p;
	size_t k = sizeof(std::vector<ns6__CertType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns6__CertType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns6__CertType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns6__CertType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons6__CertType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons6__ClaimedRoleType(struct soap *soap, std::vector<ns6__ClaimedRoleType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons6__ClaimedRoleType(struct soap *soap, const std::vector<ns6__ClaimedRoleType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns6__ClaimedRoleType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons6__ClaimedRoleType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons6__ClaimedRoleType(struct soap *soap, const char *tag, int id, const std::vector<ns6__ClaimedRoleType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns6__ClaimedRoleType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons6__ClaimedRoleType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns6__ClaimedRoleType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons6__ClaimedRoleType(struct soap *soap, const char *tag, std::vector<ns6__ClaimedRoleType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons6__ClaimedRoleType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns6__ClaimedRoleType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns6__ClaimedRoleType, SOAP_TYPE_std__vectorTemplateOfPointerTons6__ClaimedRoleType, sizeof(ns6__ClaimedRoleType), 1, SCAP_finsert, SCAP_fbase))
				break;
			if (!soap_in_PointerTons6__ClaimedRoleType(soap, tag, NULL, "ns6:ClaimedRoleType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons6__ClaimedRoleType(soap, tag, &n, "ns6:ClaimedRoleType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns6__ClaimedRoleType *>  * SOAP_FMAC2 SCAP_instantiate_std__vectorTemplateOfPointerTons6__ClaimedRoleType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_std__vectorTemplateOfPointerTons6__ClaimedRoleType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns6__ClaimedRoleType *> *p;
	size_t k = sizeof(std::vector<ns6__ClaimedRoleType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns6__ClaimedRoleType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns6__ClaimedRoleType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns6__ClaimedRoleType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons6__ClaimedRoleType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__SubAttributeType(struct soap *soap, std::vector<ns3__SubAttributeType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__SubAttributeType(struct soap *soap, const std::vector<ns3__SubAttributeType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__SubAttributeType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__SubAttributeType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__SubAttributeType(struct soap *soap, const char *tag, int id, const std::vector<ns3__SubAttributeType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__SubAttributeType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__SubAttributeType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__SubAttributeType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__SubAttributeType(struct soap *soap, const char *tag, std::vector<ns3__SubAttributeType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__SubAttributeType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__SubAttributeType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns3__SubAttributeType, SOAP_TYPE_std__vectorTemplateOfPointerTons3__SubAttributeType, sizeof(ns3__SubAttributeType), 1, SCAP_finsert, SCAP_fbase))
				break;
			if (!soap_in_PointerTons3__SubAttributeType(soap, tag, NULL, "ns3:SubAttributeType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__SubAttributeType(soap, tag, &n, "ns3:SubAttributeType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__SubAttributeType *>  * SOAP_FMAC2 SCAP_instantiate_std__vectorTemplateOfPointerTons3__SubAttributeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_std__vectorTemplateOfPointerTons3__SubAttributeType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__SubAttributeType *> *p;
	size_t k = sizeof(std::vector<ns3__SubAttributeType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns3__SubAttributeType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns3__SubAttributeType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__SubAttributeType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons3__SubAttributeType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns4__LegalActType(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns4__LegalActType(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_ns4__LegalActType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns4__LegalActType(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ns4__LegalActType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns4__LegalActType(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns4__LegalActType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_ns4__LegalActType(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns4__LegalActType, SOAP_TYPE_std__vectorTemplateOfns4__LegalActType, sizeof(std::string), 0, SCAP_finsert, SCAP_fbase))
				break;
			if (!soap_in_ns4__LegalActType(soap, tag, NULL, "ns4:LegalActType"))
				break;
		}
		else
		{	if (!soap_in_ns4__LegalActType(soap, tag, &n, "ns4:LegalActType"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 SCAP_instantiate_std__vectorTemplateOfns4__LegalActType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_std__vectorTemplateOfns4__LegalActType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfns4__LegalActType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__ExtraIDType(struct soap *soap, std::vector<ns3__ExtraIDType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__ExtraIDType(struct soap *soap, const std::vector<ns3__ExtraIDType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__ExtraIDType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__ExtraIDType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__ExtraIDType(struct soap *soap, const char *tag, int id, const std::vector<ns3__ExtraIDType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__ExtraIDType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__ExtraIDType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__ExtraIDType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__ExtraIDType(struct soap *soap, const char *tag, std::vector<ns3__ExtraIDType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__ExtraIDType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__ExtraIDType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns3__ExtraIDType, SOAP_TYPE_std__vectorTemplateOfPointerTons3__ExtraIDType, sizeof(ns3__ExtraIDType), 1, SCAP_finsert, SCAP_fbase))
				break;
			if (!soap_in_PointerTons3__ExtraIDType(soap, tag, NULL, "ns3:ExtraIDType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__ExtraIDType(soap, tag, &n, "ns3:ExtraIDType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__ExtraIDType *>  * SOAP_FMAC2 SCAP_instantiate_std__vectorTemplateOfPointerTons3__ExtraIDType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_std__vectorTemplateOfPointerTons3__ExtraIDType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__ExtraIDType *> *p;
	size_t k = sizeof(std::vector<ns3__ExtraIDType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns3__ExtraIDType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns3__ExtraIDType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__ExtraIDType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons3__ExtraIDType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__X509CertificateType(struct soap *soap, std::vector<ns5__X509CertificateType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__X509CertificateType(struct soap *soap, const std::vector<ns5__X509CertificateType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns5__X509CertificateType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__X509CertificateType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__X509CertificateType(struct soap *soap, const char *tag, int id, const std::vector<ns5__X509CertificateType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns5__X509CertificateType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__X509CertificateType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__X509CertificateType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__X509CertificateType(struct soap *soap, const char *tag, std::vector<ns5__X509CertificateType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__X509CertificateType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns5__X509CertificateType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns5__X509CertificateType, SOAP_TYPE_std__vectorTemplateOfPointerTons5__X509CertificateType, sizeof(ns5__X509CertificateType), 1, SCAP_finsert, SCAP_fbase))
				break;
			if (!soap_in_PointerTons5__X509CertificateType(soap, tag, NULL, "ns5:X509CertificateType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons5__X509CertificateType(soap, tag, &n, "ns5:X509CertificateType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__X509CertificateType *>  * SOAP_FMAC2 SCAP_instantiate_std__vectorTemplateOfPointerTons5__X509CertificateType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_std__vectorTemplateOfPointerTons5__X509CertificateType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns5__X509CertificateType *> *p;
	size_t k = sizeof(std::vector<ns5__X509CertificateType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns5__X509CertificateType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns5__X509CertificateType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns5__X509CertificateType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons5__X509CertificateType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__TransformType(struct soap *soap, std::vector<ns5__TransformType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__TransformType(struct soap *soap, const std::vector<ns5__TransformType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns5__TransformType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__TransformType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__TransformType(struct soap *soap, const char *tag, int id, const std::vector<ns5__TransformType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns5__TransformType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__TransformType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__TransformType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__TransformType(struct soap *soap, const char *tag, std::vector<ns5__TransformType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__TransformType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns5__TransformType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns5__TransformType, SOAP_TYPE_std__vectorTemplateOfPointerTons5__TransformType, sizeof(ns5__TransformType), 1, SCAP_finsert, SCAP_fbase))
				break;
			if (!soap_in_PointerTons5__TransformType(soap, tag, NULL, "ns5:TransformType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons5__TransformType(soap, tag, &n, "ns5:TransformType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__TransformType *>  * SOAP_FMAC2 SCAP_instantiate_std__vectorTemplateOfPointerTons5__TransformType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_std__vectorTemplateOfPointerTons5__TransformType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns5__TransformType *> *p;
	size_t k = sizeof(std::vector<ns5__TransformType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns5__TransformType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns5__TransformType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns5__TransformType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons5__TransformType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__ReferenceType(struct soap *soap, std::vector<ns5__ReferenceType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__ReferenceType(struct soap *soap, const std::vector<ns5__ReferenceType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns5__ReferenceType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__ReferenceType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__ReferenceType(struct soap *soap, const char *tag, int id, const std::vector<ns5__ReferenceType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns5__ReferenceType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__ReferenceType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__ReferenceType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__ReferenceType(struct soap *soap, const char *tag, std::vector<ns5__ReferenceType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__ReferenceType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns5__ReferenceType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns5__ReferenceType, SOAP_TYPE_std__vectorTemplateOfPointerTons5__ReferenceType, sizeof(ns5__ReferenceType), 1, SCAP_finsert, SCAP_fbase))
				break;
			if (!soap_in_PointerTons5__ReferenceType(soap, tag, NULL, "ns5:ReferenceType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons5__ReferenceType(soap, tag, &n, "ns5:ReferenceType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__ReferenceType *>  * SOAP_FMAC2 SCAP_instantiate_std__vectorTemplateOfPointerTons5__ReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_std__vectorTemplateOfPointerTons5__ReferenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns5__ReferenceType *> *p;
	size_t k = sizeof(std::vector<ns5__ReferenceType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns5__ReferenceType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns5__ReferenceType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns5__ReferenceType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons5__ReferenceType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__ObjectType(struct soap *soap, std::vector<ns5__ObjectType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__ObjectType(struct soap *soap, const std::vector<ns5__ObjectType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns5__ObjectType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__ObjectType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__ObjectType(struct soap *soap, const char *tag, int id, const std::vector<ns5__ObjectType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns5__ObjectType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__ObjectType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__ObjectType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__ObjectType(struct soap *soap, const char *tag, std::vector<ns5__ObjectType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__ObjectType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns5__ObjectType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns5__ObjectType, SOAP_TYPE_std__vectorTemplateOfPointerTons5__ObjectType, sizeof(ns5__ObjectType), 1, SCAP_finsert, SCAP_fbase))
				break;
			if (!soap_in_PointerTons5__ObjectType(soap, tag, NULL, "ns5:ObjectType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons5__ObjectType(soap, tag, &n, "ns5:ObjectType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__ObjectType *>  * SOAP_FMAC2 SCAP_instantiate_std__vectorTemplateOfPointerTons5__ObjectType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_std__vectorTemplateOfPointerTons5__ObjectType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns5__ObjectType *> *p;
	size_t k = sizeof(std::vector<ns5__ObjectType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns5__ObjectType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns5__ObjectType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns5__ObjectType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons5__ObjectType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__AttributeType(struct soap *soap, std::vector<ns3__AttributeType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__AttributeType(struct soap *soap, const std::vector<ns3__AttributeType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__AttributeType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__AttributeType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__AttributeType(struct soap *soap, const char *tag, int id, const std::vector<ns3__AttributeType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__AttributeType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__AttributeType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__AttributeType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__AttributeType(struct soap *soap, const char *tag, std::vector<ns3__AttributeType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__AttributeType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__AttributeType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns3__AttributeType, SOAP_TYPE_std__vectorTemplateOfPointerTons3__AttributeType, sizeof(ns3__AttributeType), 1, SCAP_finsert, SCAP_fbase))
				break;
			if (!soap_in_PointerTons3__AttributeType(soap, tag, NULL, "ns3:AttributeType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__AttributeType(soap, tag, &n, "ns3:AttributeType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__AttributeType *>  * SOAP_FMAC2 SCAP_instantiate_std__vectorTemplateOfPointerTons3__AttributeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_std__vectorTemplateOfPointerTons3__AttributeType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__AttributeType *> *p;
	size_t k = sizeof(std::vector<ns3__AttributeType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns3__AttributeType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns3__AttributeType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__AttributeType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons3__AttributeType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__SignatureType(struct soap *soap, std::vector<ns5__SignatureType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__SignatureType(struct soap *soap, const std::vector<ns5__SignatureType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns5__SignatureType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__SignatureType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__SignatureType(struct soap *soap, const char *tag, int id, const std::vector<ns5__SignatureType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns5__SignatureType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__SignatureType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__SignatureType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__SignatureType(struct soap *soap, const char *tag, std::vector<ns5__SignatureType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__SignatureType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns5__SignatureType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns5__SignatureType, SOAP_TYPE_std__vectorTemplateOfPointerTons5__SignatureType, sizeof(ns5__SignatureType), 1, SCAP_finsert, SCAP_fbase))
				break;
			if (!soap_in_PointerTons5__SignatureType(soap, tag, NULL, "ns5:SignatureType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons5__SignatureType(soap, tag, &n, "ns5:SignatureType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__SignatureType *>  * SOAP_FMAC2 SCAP_instantiate_std__vectorTemplateOfPointerTons5__SignatureType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_std__vectorTemplateOfPointerTons5__SignatureType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns5__SignatureType *> *p;
	size_t k = sizeof(std::vector<ns5__SignatureType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns5__SignatureType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns5__SignatureType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns5__SignatureType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons5__SignatureType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__AttributesType(struct soap *soap, std::vector<ns2__AttributesType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__AttributesType(struct soap *soap, const std::vector<ns2__AttributesType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__AttributesType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__AttributesType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__AttributesType(struct soap *soap, const char *tag, int id, const std::vector<ns2__AttributesType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__AttributesType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__AttributesType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__AttributesType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__AttributesType(struct soap *soap, const char *tag, std::vector<ns2__AttributesType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__AttributesType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns2__AttributesType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns2__AttributesType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__AttributesType, sizeof(ns2__AttributesType), 1, SCAP_finsert, SCAP_fbase))
				break;
			if (!soap_in_PointerTons2__AttributesType(soap, tag, NULL, "ns2:AttributesType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons2__AttributesType(soap, tag, &n, "ns2:AttributesType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__AttributesType *>  * SOAP_FMAC2 SCAP_instantiate_std__vectorTemplateOfPointerTons2__AttributesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_std__vectorTemplateOfPointerTons2__AttributesType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns2__AttributesType *> *p;
	size_t k = sizeof(std::vector<ns2__AttributesType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns2__AttributesType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns2__AttributesType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns2__AttributesType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons2__AttributesType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__AttributeSupplierType(struct soap *soap, std::vector<ns3__AttributeSupplierType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__AttributeSupplierType(struct soap *soap, const std::vector<ns3__AttributeSupplierType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__AttributeSupplierType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__AttributeSupplierType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__AttributeSupplierType(struct soap *soap, const char *tag, int id, const std::vector<ns3__AttributeSupplierType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__AttributeSupplierType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__AttributeSupplierType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__AttributeSupplierType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__AttributeSupplierType(struct soap *soap, const char *tag, std::vector<ns3__AttributeSupplierType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__AttributeSupplierType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__AttributeSupplierType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns3__AttributeSupplierType, SOAP_TYPE_std__vectorTemplateOfPointerTons3__AttributeSupplierType, sizeof(ns3__AttributeSupplierType), 1, SCAP_finsert, SCAP_fbase))
				break;
			if (!soap_in_PointerTons3__AttributeSupplierType(soap, tag, NULL, "ns3:AttributeSupplierType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__AttributeSupplierType(soap, tag, &n, "ns3:AttributeSupplierType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__AttributeSupplierType *>  * SOAP_FMAC2 SCAP_instantiate_std__vectorTemplateOfPointerTons3__AttributeSupplierType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "SCAP_instantiate_std__vectorTemplateOfPointerTons3__AttributeSupplierType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__AttributeSupplierType *> *p;
	size_t k = sizeof(std::vector<ns3__AttributeSupplierType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns3__AttributeSupplierType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns3__AttributeSupplierType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__AttributeSupplierType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons3__AttributeSupplierType, n, SCAP_fdelete);
	if (size)
		*size = k;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of SCAPC.cpp */

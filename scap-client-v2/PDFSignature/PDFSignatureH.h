/* PDFSignatureH.h
   Generated by gSOAP 2.8.28 from SCAP-PDFSignature.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#ifndef PDFSignatureH_H
#define PDFSignatureH_H
#include "PDFSignatureStub.h"

namespace PDFSignature {
#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap*, const void*, int);
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap*);
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap*);
#endif
SOAP_FMAC3 void *SOAP_FMAC4 soap_getelement(struct soap*, int*);
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap*, const void*, const char*, int, int);
SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap*);

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap);
SOAP_FMAC3 void * SOAP_FMAC4 PDFSignature_instantiate(struct soap*, int, const char*, const char*, size_t*);
SOAP_FMAC3 int SOAP_FMAC4 PDFSignature_fdelete(struct soap_clist*);
SOAP_FMAC3 int SOAP_FMAC4 PDFSignature_fbase(int, int);
SOAP_FMAC3 void SOAP_FMAC4 PDFSignature_finsert(struct soap*, int, int, void*, size_t, const void*, void**);

#ifndef SOAP_TYPE_PDFSignature_byte
#define SOAP_TYPE_PDFSignature_byte (3)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap*, char *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap*, const char*, int, const char *, const char*);
SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap*, const char*, char *, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap*, const char *, const char*, const char*);

#ifndef soap_write_byte
#define soap_write_byte(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || PDFSignature::soap_put_byte(soap, data, "byte", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap*, char *, const char*, const char*);

#ifndef soap_read_byte
#define soap_read_byte(soap, data) ( ((data) ? (PDFSignature::soap_default_byte(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_byte(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_int
#define SOAP_TYPE_PDFSignature_int (1)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap*, int *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap*, const char*, int, const int *, const char*);
SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap*, const char*, int *, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap*, const int *, const char*, const char*);

#ifndef soap_write_int
#define soap_write_int(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || PDFSignature::soap_put_int(soap, data, "int", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap*, int *, const char*, const char*);

#ifndef soap_read_int
#define soap_read_int(soap, data) ( ((data) ? (PDFSignature::soap_default_int(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_int(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_unsignedByte
#define SOAP_TYPE_PDFSignature_unsignedByte (13)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap*, unsigned char *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap*, const char*, int, const unsigned char *, const char*);
SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap*, const char*, unsigned char *, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap*, const unsigned char *, const char*, const char*);

#ifndef soap_write_unsignedByte
#define soap_write_unsignedByte(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || PDFSignature::soap_put_unsignedByte(soap, data, "unsignedByte", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap*, unsigned char *, const char*, const char*);

#ifndef soap_read_unsignedByte
#define soap_read_unsignedByte(soap, data) ( ((data) ? (PDFSignature::soap_default_unsignedByte(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_unsignedByte(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_unsignedInt
#define SOAP_TYPE_PDFSignature_unsignedInt (12)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap*, unsigned int *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap*, const char*, int, const unsigned int *, const char*);
SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap*, const char*, unsigned int *, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap*, const unsigned int *, const char*, const char*);

#ifndef soap_write_unsignedInt
#define soap_write_unsignedInt(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || PDFSignature::soap_put_unsignedInt(soap, data, "unsignedInt", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap*, unsigned int *, const char*, const char*);

#ifndef soap_read_unsignedInt
#define soap_read_unsignedInt(soap, data) ( ((data) ? (PDFSignature::soap_default_unsignedInt(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_unsignedInt(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_ns1__SignatureOrientationEnumType
#define SOAP_TYPE_PDFSignature_ns1__SignatureOrientationEnumType (29)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SignatureOrientationEnumType(struct soap*, enum ns1__SignatureOrientationEnumType *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SignatureOrientationEnumType(struct soap*, const char*, int, const enum ns1__SignatureOrientationEnumType *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__SignatureOrientationEnumType2s(struct soap*, enum ns1__SignatureOrientationEnumType);
SOAP_FMAC3 enum ns1__SignatureOrientationEnumType * SOAP_FMAC4 soap_in_ns1__SignatureOrientationEnumType(struct soap*, const char*, enum ns1__SignatureOrientationEnumType *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__SignatureOrientationEnumType(struct soap*, const char*, enum ns1__SignatureOrientationEnumType *);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SignatureOrientationEnumType(struct soap*, const enum ns1__SignatureOrientationEnumType *, const char*, const char*);

#ifndef soap_write_ns1__SignatureOrientationEnumType
#define soap_write_ns1__SignatureOrientationEnumType(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || PDFSignature::soap_put_ns1__SignatureOrientationEnumType(soap, data, "ns1:SignatureOrientationEnumType", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 enum ns1__SignatureOrientationEnumType * SOAP_FMAC4 soap_get_ns1__SignatureOrientationEnumType(struct soap*, enum ns1__SignatureOrientationEnumType *, const char*, const char*);

#ifndef soap_read_ns1__SignatureOrientationEnumType
#define soap_read_ns1__SignatureOrientationEnumType(soap, data) ( ((data) ? (PDFSignature::soap_default_ns1__SignatureOrientationEnumType(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_ns1__SignatureOrientationEnumType(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_ns1__Status
#define SOAP_TYPE_PDFSignature_ns1__Status (28)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Status(struct soap*, const char*, int, const ns1__Status *, const char*);
SOAP_FMAC3 ns1__Status * SOAP_FMAC4 soap_in_ns1__Status(struct soap*, const char*, ns1__Status *, const char*);
SOAP_FMAC1 ns1__Status * SOAP_FMAC2 soap_instantiate_ns1__Status(struct soap*, int, const char*, const char*, size_t*);

inline ns1__Status * soap_new_ns1__Status(struct soap *soap, int n = -1) { return soap_instantiate_ns1__Status(soap, n, NULL, NULL, NULL); }

inline ns1__Status * soap_new_req_ns1__Status(
	struct soap *soap,
	const std::string& Code,
	const std::string& Message)
{	ns1__Status *_p = soap_new_ns1__Status(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns1__Status::Code = Code;
		_p->ns1__Status::Message = Message;
	}
	return _p;
}

inline ns1__Status * soap_new_set_ns1__Status(
	struct soap *soap,
	const std::string& Code,
	const std::string& Message,
	std::string *Field,
	std::string *FieldValue)
{	ns1__Status *_p = soap_new_ns1__Status(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns1__Status::Code = Code;
		_p->ns1__Status::Message = Message;
		_p->ns1__Status::Field = Field;
		_p->ns1__Status::FieldValue = FieldValue;
	}
	return _p;
}

#ifndef soap_write_ns1__Status
#define soap_write_ns1__Status(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || ((data)->soap_serialize(soap), 0) || (data)->soap_put(soap, "ns1:Status", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 ns1__Status * SOAP_FMAC4 soap_get_ns1__Status(struct soap*, ns1__Status *, const char*, const char*);

#ifndef soap_read_ns1__Status
#define soap_read_ns1__Status(soap, data) ( ((data) ? ((data)->soap_default(soap), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_ns1__Status(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_ns1__SignResponse
#define SOAP_TYPE_PDFSignature_ns1__SignResponse (27)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SignResponse(struct soap*, const char*, int, const ns1__SignResponse *, const char*);
SOAP_FMAC3 ns1__SignResponse * SOAP_FMAC4 soap_in_ns1__SignResponse(struct soap*, const char*, ns1__SignResponse *, const char*);
SOAP_FMAC1 ns1__SignResponse * SOAP_FMAC2 soap_instantiate_ns1__SignResponse(struct soap*, int, const char*, const char*, size_t*);

inline ns1__SignResponse * soap_new_ns1__SignResponse(struct soap *soap, int n = -1) { return soap_instantiate_ns1__SignResponse(soap, n, NULL, NULL, NULL); }

inline ns1__SignResponse * soap_new_req_ns1__SignResponse(
	struct soap *soap,
	const std::string& ProcessId,
	ns1__Status *Status)
{	ns1__SignResponse *_p = soap_new_ns1__SignResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns1__SignResponse::ProcessId = ProcessId;
		_p->ns1__SignResponse::Status = Status;
	}
	return _p;
}

inline ns1__SignResponse * soap_new_set_ns1__SignResponse(
	struct soap *soap,
	const std::string& ProcessId,
	ns1__Status *Status,
	xsd__base64Binary *SignedDocument)
{	ns1__SignResponse *_p = soap_new_ns1__SignResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns1__SignResponse::ProcessId = ProcessId;
		_p->ns1__SignResponse::Status = Status;
		_p->ns1__SignResponse::SignedDocument = SignedDocument;
	}
	return _p;
}

#ifndef soap_write_ns1__SignResponse
#define soap_write_ns1__SignResponse(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || ((data)->soap_serialize(soap), 0) || (data)->soap_put(soap, "ns1:SignResponse", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 ns1__SignResponse * SOAP_FMAC4 soap_get_ns1__SignResponse(struct soap*, ns1__SignResponse *, const char*, const char*);

#ifndef soap_read_ns1__SignResponse
#define soap_read_ns1__SignResponse(soap, data) ( ((data) ? ((data)->soap_default(soap), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_ns1__SignResponse(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_ns1__SubAttributeType
#define SOAP_TYPE_PDFSignature_ns1__SubAttributeType (26)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubAttributeType(struct soap*, const char*, int, const ns1__SubAttributeType *, const char*);
SOAP_FMAC3 ns1__SubAttributeType * SOAP_FMAC4 soap_in_ns1__SubAttributeType(struct soap*, const char*, ns1__SubAttributeType *, const char*);
SOAP_FMAC1 ns1__SubAttributeType * SOAP_FMAC2 soap_instantiate_ns1__SubAttributeType(struct soap*, int, const char*, const char*, size_t*);

inline ns1__SubAttributeType * soap_new_ns1__SubAttributeType(struct soap *soap, int n = -1) { return soap_instantiate_ns1__SubAttributeType(soap, n, NULL, NULL, NULL); }

inline ns1__SubAttributeType * soap_new_req_ns1__SubAttributeType(
	struct soap *soap,
	const std::string& AttributeID)
{	ns1__SubAttributeType *_p = soap_new_ns1__SubAttributeType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns1__SubAttributeType::AttributeID = AttributeID;
	}
	return _p;
}

inline ns1__SubAttributeType * soap_new_set_ns1__SubAttributeType(
	struct soap *soap,
	const std::string& AttributeID,
	std::string *Description,
	std::string *Value,
	ns1__LegalActListType *LegalActList,
	std::string *Type)
{	ns1__SubAttributeType *_p = soap_new_ns1__SubAttributeType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns1__SubAttributeType::AttributeID = AttributeID;
		_p->ns1__SubAttributeType::Description = Description;
		_p->ns1__SubAttributeType::Value = Value;
		_p->ns1__SubAttributeType::LegalActList = LegalActList;
		_p->ns1__SubAttributeType::Type = Type;
	}
	return _p;
}

#ifndef soap_write_ns1__SubAttributeType
#define soap_write_ns1__SubAttributeType(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || ((data)->soap_serialize(soap), 0) || (data)->soap_put(soap, "ns1:SubAttributeType", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 ns1__SubAttributeType * SOAP_FMAC4 soap_get_ns1__SubAttributeType(struct soap*, ns1__SubAttributeType *, const char*, const char*);

#ifndef soap_read_ns1__SubAttributeType
#define soap_read_ns1__SubAttributeType(soap, data) ( ((data) ? ((data)->soap_default(soap), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_ns1__SubAttributeType(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_ns1__SubAttributeListType
#define SOAP_TYPE_PDFSignature_ns1__SubAttributeListType (25)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubAttributeListType(struct soap*, const char*, int, const ns1__SubAttributeListType *, const char*);
SOAP_FMAC3 ns1__SubAttributeListType * SOAP_FMAC4 soap_in_ns1__SubAttributeListType(struct soap*, const char*, ns1__SubAttributeListType *, const char*);
SOAP_FMAC1 ns1__SubAttributeListType * SOAP_FMAC2 soap_instantiate_ns1__SubAttributeListType(struct soap*, int, const char*, const char*, size_t*);

inline ns1__SubAttributeListType * soap_new_ns1__SubAttributeListType(struct soap *soap, int n = -1) { return soap_instantiate_ns1__SubAttributeListType(soap, n, NULL, NULL, NULL); }

inline ns1__SubAttributeListType * soap_new_req_ns1__SubAttributeListType(
	struct soap *soap,
	const std::vector<ns1__SubAttributeType *> & SubAttribute)
{	ns1__SubAttributeListType *_p = soap_new_ns1__SubAttributeListType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns1__SubAttributeListType::SubAttribute = SubAttribute;
	}
	return _p;
}

inline ns1__SubAttributeListType * soap_new_set_ns1__SubAttributeListType(
	struct soap *soap,
	const std::vector<ns1__SubAttributeType *> & SubAttribute)
{	ns1__SubAttributeListType *_p = soap_new_ns1__SubAttributeListType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns1__SubAttributeListType::SubAttribute = SubAttribute;
	}
	return _p;
}

#ifndef soap_write_ns1__SubAttributeListType
#define soap_write_ns1__SubAttributeListType(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || ((data)->soap_serialize(soap), 0) || (data)->soap_put(soap, "ns1:SubAttributeListType", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 ns1__SubAttributeListType * SOAP_FMAC4 soap_get_ns1__SubAttributeListType(struct soap*, ns1__SubAttributeListType *, const char*, const char*);

#ifndef soap_read_ns1__SubAttributeListType
#define soap_read_ns1__SubAttributeListType(soap, data) ( ((data) ? ((data)->soap_default(soap), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_ns1__SubAttributeListType(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_ns1__LegalActListType
#define SOAP_TYPE_PDFSignature_ns1__LegalActListType (24)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LegalActListType(struct soap*, const char*, int, const ns1__LegalActListType *, const char*);
SOAP_FMAC3 ns1__LegalActListType * SOAP_FMAC4 soap_in_ns1__LegalActListType(struct soap*, const char*, ns1__LegalActListType *, const char*);
SOAP_FMAC1 ns1__LegalActListType * SOAP_FMAC2 soap_instantiate_ns1__LegalActListType(struct soap*, int, const char*, const char*, size_t*);

inline ns1__LegalActListType * soap_new_ns1__LegalActListType(struct soap *soap, int n = -1) { return soap_instantiate_ns1__LegalActListType(soap, n, NULL, NULL, NULL); }

inline ns1__LegalActListType * soap_new_req_ns1__LegalActListType(
	struct soap *soap,
	const std::vector<std::string> & LegalAct)
{	ns1__LegalActListType *_p = soap_new_ns1__LegalActListType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns1__LegalActListType::LegalAct = LegalAct;
	}
	return _p;
}

inline ns1__LegalActListType * soap_new_set_ns1__LegalActListType(
	struct soap *soap,
	const std::vector<std::string> & LegalAct)
{	ns1__LegalActListType *_p = soap_new_ns1__LegalActListType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns1__LegalActListType::LegalAct = LegalAct;
	}
	return _p;
}

#ifndef soap_write_ns1__LegalActListType
#define soap_write_ns1__LegalActListType(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || ((data)->soap_serialize(soap), 0) || (data)->soap_put(soap, "ns1:LegalActListType", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 ns1__LegalActListType * SOAP_FMAC4 soap_get_ns1__LegalActListType(struct soap*, ns1__LegalActListType *, const char*, const char*);

#ifndef soap_read_ns1__LegalActListType
#define soap_read_ns1__LegalActListType(soap, data) ( ((data) ? ((data)->soap_default(soap), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_ns1__LegalActListType(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_ns1__MainAttributeType
#define SOAP_TYPE_PDFSignature_ns1__MainAttributeType (23)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MainAttributeType(struct soap*, const char*, int, const ns1__MainAttributeType *, const char*);
SOAP_FMAC3 ns1__MainAttributeType * SOAP_FMAC4 soap_in_ns1__MainAttributeType(struct soap*, const char*, ns1__MainAttributeType *, const char*);
SOAP_FMAC1 ns1__MainAttributeType * SOAP_FMAC2 soap_instantiate_ns1__MainAttributeType(struct soap*, int, const char*, const char*, size_t*);

inline ns1__MainAttributeType * soap_new_ns1__MainAttributeType(struct soap *soap, int n = -1) { return soap_instantiate_ns1__MainAttributeType(soap, n, NULL, NULL, NULL); }

inline ns1__MainAttributeType * soap_new_req_ns1__MainAttributeType(
	struct soap *soap,
	const std::string& AttributeID)
{	ns1__MainAttributeType *_p = soap_new_ns1__MainAttributeType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns1__MainAttributeType::AttributeID = AttributeID;
	}
	return _p;
}

inline ns1__MainAttributeType * soap_new_set_ns1__MainAttributeType(
	struct soap *soap,
	const std::string& AttributeID,
	std::string *Description,
	ns1__LegalActListType *LegalActList,
	ns1__SubAttributeListType *SubAttributeList)
{	ns1__MainAttributeType *_p = soap_new_ns1__MainAttributeType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns1__MainAttributeType::AttributeID = AttributeID;
		_p->ns1__MainAttributeType::Description = Description;
		_p->ns1__MainAttributeType::LegalActList = LegalActList;
		_p->ns1__MainAttributeType::SubAttributeList = SubAttributeList;
	}
	return _p;
}

#ifndef soap_write_ns1__MainAttributeType
#define soap_write_ns1__MainAttributeType(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || ((data)->soap_serialize(soap), 0) || (data)->soap_put(soap, "ns1:MainAttributeType", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 ns1__MainAttributeType * SOAP_FMAC4 soap_get_ns1__MainAttributeType(struct soap*, ns1__MainAttributeType *, const char*, const char*);

#ifndef soap_read_ns1__MainAttributeType
#define soap_read_ns1__MainAttributeType(soap, data) ( ((data) ? ((data)->soap_default(soap), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_ns1__MainAttributeType(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_ns1__AttributeSupplierType
#define SOAP_TYPE_PDFSignature_ns1__AttributeSupplierType (22)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AttributeSupplierType(struct soap*, const char*, int, const ns1__AttributeSupplierType *, const char*);
SOAP_FMAC3 ns1__AttributeSupplierType * SOAP_FMAC4 soap_in_ns1__AttributeSupplierType(struct soap*, const char*, ns1__AttributeSupplierType *, const char*);
SOAP_FMAC1 ns1__AttributeSupplierType * SOAP_FMAC2 soap_instantiate_ns1__AttributeSupplierType(struct soap*, int, const char*, const char*, size_t*);

inline ns1__AttributeSupplierType * soap_new_ns1__AttributeSupplierType(struct soap *soap, int n = -1) { return soap_instantiate_ns1__AttributeSupplierType(soap, n, NULL, NULL, NULL); }

inline ns1__AttributeSupplierType * soap_new_req_ns1__AttributeSupplierType(
	struct soap *soap,
	const std::string& Id,
	const std::string& Name)
{	ns1__AttributeSupplierType *_p = soap_new_ns1__AttributeSupplierType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns1__AttributeSupplierType::Id = Id;
		_p->ns1__AttributeSupplierType::Name = Name;
	}
	return _p;
}

inline ns1__AttributeSupplierType * soap_new_set_ns1__AttributeSupplierType(
	struct soap *soap,
	const std::string& Id,
	const std::string& Name,
	std::string *Type)
{	ns1__AttributeSupplierType *_p = soap_new_ns1__AttributeSupplierType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns1__AttributeSupplierType::Id = Id;
		_p->ns1__AttributeSupplierType::Name = Name;
		_p->ns1__AttributeSupplierType::Type = Type;
	}
	return _p;
}

#ifndef soap_write_ns1__AttributeSupplierType
#define soap_write_ns1__AttributeSupplierType(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || ((data)->soap_serialize(soap), 0) || (data)->soap_put(soap, "ns1:AttributeSupplierType", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 ns1__AttributeSupplierType * SOAP_FMAC4 soap_get_ns1__AttributeSupplierType(struct soap*, ns1__AttributeSupplierType *, const char*, const char*);

#ifndef soap_read_ns1__AttributeSupplierType
#define soap_read_ns1__AttributeSupplierType(soap, data) ( ((data) ? ((data)->soap_default(soap), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_ns1__AttributeSupplierType(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_ns1__AttributeType
#define SOAP_TYPE_PDFSignature_ns1__AttributeType (21)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AttributeType(struct soap*, const char*, int, const ns1__AttributeType *, const char*);
SOAP_FMAC3 ns1__AttributeType * SOAP_FMAC4 soap_in_ns1__AttributeType(struct soap*, const char*, ns1__AttributeType *, const char*);
SOAP_FMAC1 ns1__AttributeType * SOAP_FMAC2 soap_instantiate_ns1__AttributeType(struct soap*, int, const char*, const char*, size_t*);

inline ns1__AttributeType * soap_new_ns1__AttributeType(struct soap *soap, int n = -1) { return soap_instantiate_ns1__AttributeType(soap, n, NULL, NULL, NULL); }

inline ns1__AttributeType * soap_new_req_ns1__AttributeType(
	struct soap *soap,
	ns1__AttributeSupplierType *AttributeSupplier,
	ns1__MainAttributeType *MainAttribute)
{	ns1__AttributeType *_p = soap_new_ns1__AttributeType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns1__AttributeType::AttributeSupplier = AttributeSupplier;
		_p->ns1__AttributeType::MainAttribute = MainAttribute;
	}
	return _p;
}

inline ns1__AttributeType * soap_new_set_ns1__AttributeType(
	struct soap *soap,
	ns1__AttributeSupplierType *AttributeSupplier,
	ns1__MainAttributeType *MainAttribute)
{	ns1__AttributeType *_p = soap_new_ns1__AttributeType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns1__AttributeType::AttributeSupplier = AttributeSupplier;
		_p->ns1__AttributeType::MainAttribute = MainAttribute;
	}
	return _p;
}

#ifndef soap_write_ns1__AttributeType
#define soap_write_ns1__AttributeType(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || ((data)->soap_serialize(soap), 0) || (data)->soap_put(soap, "ns1:AttributeType", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 ns1__AttributeType * SOAP_FMAC4 soap_get_ns1__AttributeType(struct soap*, ns1__AttributeType *, const char*, const char*);

#ifndef soap_read_ns1__AttributeType
#define soap_read_ns1__AttributeType(soap, data) ( ((data) ? ((data)->soap_default(soap), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_ns1__AttributeType(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_ns1__AttributeListType
#define SOAP_TYPE_PDFSignature_ns1__AttributeListType (20)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AttributeListType(struct soap*, const char*, int, const ns1__AttributeListType *, const char*);
SOAP_FMAC3 ns1__AttributeListType * SOAP_FMAC4 soap_in_ns1__AttributeListType(struct soap*, const char*, ns1__AttributeListType *, const char*);
SOAP_FMAC1 ns1__AttributeListType * SOAP_FMAC2 soap_instantiate_ns1__AttributeListType(struct soap*, int, const char*, const char*, size_t*);

inline ns1__AttributeListType * soap_new_ns1__AttributeListType(struct soap *soap, int n = -1) { return soap_instantiate_ns1__AttributeListType(soap, n, NULL, NULL, NULL); }

inline ns1__AttributeListType * soap_new_req_ns1__AttributeListType(
	struct soap *soap,
	const std::vector<ns1__AttributeType *> & Attribute)
{	ns1__AttributeListType *_p = soap_new_ns1__AttributeListType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns1__AttributeListType::Attribute = Attribute;
	}
	return _p;
}

inline ns1__AttributeListType * soap_new_set_ns1__AttributeListType(
	struct soap *soap,
	const std::vector<ns1__AttributeType *> & Attribute)
{	ns1__AttributeListType *_p = soap_new_ns1__AttributeListType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns1__AttributeListType::Attribute = Attribute;
	}
	return _p;
}

#ifndef soap_write_ns1__AttributeListType
#define soap_write_ns1__AttributeListType(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || ((data)->soap_serialize(soap), 0) || (data)->soap_put(soap, "ns1:AttributeListType", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 ns1__AttributeListType * SOAP_FMAC4 soap_get_ns1__AttributeListType(struct soap*, ns1__AttributeListType *, const char*, const char*);

#ifndef soap_read_ns1__AttributeListType
#define soap_read_ns1__AttributeListType(soap, data) ( ((data) ? ((data)->soap_default(soap), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_ns1__AttributeListType(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_ns1__PersonalDataType
#define SOAP_TYPE_PDFSignature_ns1__PersonalDataType (19)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PersonalDataType(struct soap*, const char*, int, const ns1__PersonalDataType *, const char*);
SOAP_FMAC3 ns1__PersonalDataType * SOAP_FMAC4 soap_in_ns1__PersonalDataType(struct soap*, const char*, ns1__PersonalDataType *, const char*);
SOAP_FMAC1 ns1__PersonalDataType * SOAP_FMAC2 soap_instantiate_ns1__PersonalDataType(struct soap*, int, const char*, const char*, size_t*);

inline ns1__PersonalDataType * soap_new_ns1__PersonalDataType(struct soap *soap, int n = -1) { return soap_instantiate_ns1__PersonalDataType(soap, n, NULL, NULL, NULL); }

inline ns1__PersonalDataType * soap_new_req_ns1__PersonalDataType(
	struct soap *soap,
	const std::string& Name,
	const std::string& NIC)
{	ns1__PersonalDataType *_p = soap_new_ns1__PersonalDataType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns1__PersonalDataType::Name = Name;
		_p->ns1__PersonalDataType::NIC = NIC;
	}
	return _p;
}

inline ns1__PersonalDataType * soap_new_set_ns1__PersonalDataType(
	struct soap *soap,
	const std::string& Name,
	const std::string& NIC)
{	ns1__PersonalDataType *_p = soap_new_ns1__PersonalDataType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns1__PersonalDataType::Name = Name;
		_p->ns1__PersonalDataType::NIC = NIC;
	}
	return _p;
}

#ifndef soap_write_ns1__PersonalDataType
#define soap_write_ns1__PersonalDataType(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || ((data)->soap_serialize(soap), 0) || (data)->soap_put(soap, "ns1:PersonalDataType", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 ns1__PersonalDataType * SOAP_FMAC4 soap_get_ns1__PersonalDataType(struct soap*, ns1__PersonalDataType *, const char*, const char*);

#ifndef soap_read_ns1__PersonalDataType
#define soap_read_ns1__PersonalDataType(soap, data) ( ((data) ? ((data)->soap_default(soap), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_ns1__PersonalDataType(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_ns1__SignRequest
#define SOAP_TYPE_PDFSignature_ns1__SignRequest (18)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SignRequest(struct soap*, const char*, int, const ns1__SignRequest *, const char*);
SOAP_FMAC3 ns1__SignRequest * SOAP_FMAC4 soap_in_ns1__SignRequest(struct soap*, const char*, ns1__SignRequest *, const char*);
SOAP_FMAC1 ns1__SignRequest * SOAP_FMAC2 soap_instantiate_ns1__SignRequest(struct soap*, int, const char*, const char*, size_t*);

inline ns1__SignRequest * soap_new_ns1__SignRequest(struct soap *soap, int n = -1) { return soap_instantiate_ns1__SignRequest(soap, n, NULL, NULL, NULL); }

inline ns1__SignRequest * soap_new_req_ns1__SignRequest(
	struct soap *soap,
	const std::string& ProcessId,
	ns1__PersonalDataType *PersonalData,
	ns1__AttributeListType *AttributeList,
	const std::string& SignatureFieldName,
	const xsd__base64Binary& SignDocument,
	int Page,
	int X,
	int Y,
	enum ns1__SignatureOrientationEnumType Orientation)
{	ns1__SignRequest *_p = soap_new_ns1__SignRequest(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns1__SignRequest::ProcessId = ProcessId;
		_p->ns1__SignRequest::PersonalData = PersonalData;
		_p->ns1__SignRequest::AttributeList = AttributeList;
		_p->ns1__SignRequest::SignatureFieldName = SignatureFieldName;
		_p->ns1__SignRequest::SignDocument = SignDocument;
		_p->ns1__SignRequest::Page = Page;
		_p->ns1__SignRequest::X = X;
		_p->ns1__SignRequest::Y = Y;
		_p->ns1__SignRequest::Orientation = Orientation;
	}
	return _p;
}

inline ns1__SignRequest * soap_new_set_ns1__SignRequest(
	struct soap *soap,
	const std::string& ProcessId,
	ns1__PersonalDataType *PersonalData,
	ns1__AttributeListType *AttributeList,
	const std::string& SignatureFieldName,
	const xsd__base64Binary& SignDocument,
	int *LTV,
	int Page,
	int X,
	int Y,
	enum ns1__SignatureOrientationEnumType Orientation)
{	ns1__SignRequest *_p = soap_new_ns1__SignRequest(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns1__SignRequest::ProcessId = ProcessId;
		_p->ns1__SignRequest::PersonalData = PersonalData;
		_p->ns1__SignRequest::AttributeList = AttributeList;
		_p->ns1__SignRequest::SignatureFieldName = SignatureFieldName;
		_p->ns1__SignRequest::SignDocument = SignDocument;
		_p->ns1__SignRequest::LTV = LTV;
		_p->ns1__SignRequest::Page = Page;
		_p->ns1__SignRequest::X = X;
		_p->ns1__SignRequest::Y = Y;
		_p->ns1__SignRequest::Orientation = Orientation;
	}
	return _p;
}

#ifndef soap_write_ns1__SignRequest
#define soap_write_ns1__SignRequest(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || ((data)->soap_serialize(soap), 0) || (data)->soap_put(soap, "ns1:SignRequest", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 ns1__SignRequest * SOAP_FMAC4 soap_get_ns1__SignRequest(struct soap*, ns1__SignRequest *, const char*, const char*);

#ifndef soap_read_ns1__SignRequest
#define soap_read_ns1__SignRequest(soap, data) ( ((data) ? ((data)->soap_default(soap), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_ns1__SignRequest(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_xsd__anyURI
#define SOAP_TYPE_PDFSignature_xsd__anyURI (17)
#endif

#define soap_default_xsd__anyURI(soap, a) soap_default_std__string(soap, a)

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap*, const std::string *);

#define soap_xsd__anyURI2s soap_std__string2s

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2xsd__anyURI soap_s2std__string

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_xsd__anyURI soap_instantiate_std__string


#define soap_new_xsd__anyURI soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap*, const std::string *, const char*, const char*);

#ifndef soap_write_xsd__anyURI
#define soap_write_xsd__anyURI(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize_xsd__anyURI(soap, data), 0) || PDFSignature::soap_put_xsd__anyURI(soap, data, "xsd:anyURI", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap*, std::string *, const char*, const char*);

#ifndef soap_read_xsd__anyURI
#define soap_read_xsd__anyURI(soap, data) ( ((data) ? (PDFSignature::soap_default_xsd__anyURI(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_xsd__anyURI(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_std__string
#define SOAP_TYPE_PDFSignature_std__string (16)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap*, std::string *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap*, const std::string *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap*, const char*, int, const std::string*, const char*);
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap*, const char*, std::string*, const char*);
SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap*, int, const char*, const char*, size_t*);

inline std::string * soap_new_std__string(struct soap *soap, int n = -1) { return soap_instantiate_std__string(soap, n, NULL, NULL, NULL); }

inline std::string * soap_new_req_std__string(
	struct soap *soap)
{	std::string *_p = soap_new_std__string(soap);
	if (_p)
	{	soap_default_std__string(soap, _p);
	}
	return _p;
}

inline std::string * soap_new_set_std__string(
	struct soap *soap)
{	std::string *_p = soap_new_std__string(soap);
	if (_p)
	{	soap_default_std__string(soap, _p);
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap*, const std::string *, const char*, const char*);

#ifndef soap_write_std__string
#define soap_write_std__string(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize_std__string(soap, data), 0) || PDFSignature::soap_put_std__string(soap, data, "string", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap*, std::string *, const char*, const char*);

#ifndef soap_read_std__string
#define soap_read_std__string(soap, data) ( ((data) ? (PDFSignature::soap_default_std__string(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_std__string(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_xsd__base64Binary
#define SOAP_TYPE_PDFSignature_xsd__base64Binary (11)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap*, const char*, int, const xsd__base64Binary *, const char*);
SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap*, const char*, xsd__base64Binary *, const char*);
SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);

inline xsd__base64Binary * soap_new_xsd__base64Binary(struct soap *soap, int n = -1) { return soap_instantiate_xsd__base64Binary(soap, n, NULL, NULL, NULL); }

inline xsd__base64Binary * soap_new_req_xsd__base64Binary(
	struct soap *soap)
{	xsd__base64Binary *_p = soap_new_xsd__base64Binary(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xsd__base64Binary * soap_new_set_xsd__base64Binary(
	struct soap *soap,
	unsigned char *__ptr,
	int __size,
	char *id,
	char *type,
	char *options)
{	xsd__base64Binary *_p = soap_new_xsd__base64Binary(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xsd__base64Binary::__ptr = __ptr;
		_p->xsd__base64Binary::__size = __size;
		_p->xsd__base64Binary::id = id;
		_p->xsd__base64Binary::type = type;
		_p->xsd__base64Binary::options = options;
	}
	return _p;
}

#ifndef soap_write_xsd__base64Binary
#define soap_write_xsd__base64Binary(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || ((data)->soap_serialize(soap), 0) || (data)->soap_put(soap, "xsd:base64Binary", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap*, xsd__base64Binary *, const char*, const char*);

#ifndef soap_read_xsd__base64Binary
#define soap_read_xsd__base64Binary(soap, data) ( ((data) ? ((data)->soap_default(soap), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_xsd__base64Binary(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_PDFSignature_SOAP_ENV__Fault
#define SOAP_TYPE_PDFSignature_SOAP_ENV__Fault (56)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap*, const struct SOAP_ENV__Fault *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap*, const char*, int, const struct SOAP_ENV__Fault *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap*, const char*, struct SOAP_ENV__Fault *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Fault * soap_new_SOAP_ENV__Fault(struct soap *soap, int n = -1) { return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL); }

inline struct SOAP_ENV__Fault * soap_new_req_SOAP_ENV__Fault(
	struct soap *soap)
{	struct SOAP_ENV__Fault *_p = soap_new_SOAP_ENV__Fault(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Fault(soap, _p);
	}
	return _p;
}

inline struct SOAP_ENV__Fault * soap_new_set_SOAP_ENV__Fault(
	struct soap *soap,
	char *faultcode,
	char *faultstring,
	char *faultactor,
	struct SOAP_ENV__Detail *detail,
	struct SOAP_ENV__Code *SOAP_ENV__Code,
	struct SOAP_ENV__Reason *SOAP_ENV__Reason,
	char *SOAP_ENV__Node,
	char *SOAP_ENV__Role,
	struct SOAP_ENV__Detail *SOAP_ENV__Detail)
{	struct SOAP_ENV__Fault *_p = soap_new_SOAP_ENV__Fault(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Fault(soap, _p);
		_p->faultcode = faultcode;
		_p->faultstring = faultstring;
		_p->faultactor = faultactor;
		_p->detail = detail;
		_p->SOAP_ENV__Code = SOAP_ENV__Code;
		_p->SOAP_ENV__Reason = SOAP_ENV__Reason;
		_p->SOAP_ENV__Node = SOAP_ENV__Node;
		_p->SOAP_ENV__Role = SOAP_ENV__Role;
		_p->SOAP_ENV__Detail = SOAP_ENV__Detail;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap*, const struct SOAP_ENV__Fault *, const char*, const char*);

#ifndef soap_write_SOAP_ENV__Fault
#define soap_write_SOAP_ENV__Fault(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize_SOAP_ENV__Fault(soap, data), 0) || PDFSignature::soap_put_SOAP_ENV__Fault(soap, data, "SOAP-ENV:Fault", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault *, const char*, const char*);

#ifndef soap_read_SOAP_ENV__Fault
#define soap_read_SOAP_ENV__Fault(soap, data) ( ((data) ? (PDFSignature::soap_default_SOAP_ENV__Fault(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_SOAP_ENV__Fault(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_PDFSignature_SOAP_ENV__Reason
#define SOAP_TYPE_PDFSignature_SOAP_ENV__Reason (55)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap*, const struct SOAP_ENV__Reason *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap*, const char*, int, const struct SOAP_ENV__Reason *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap*, const char*, struct SOAP_ENV__Reason *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Reason * soap_new_SOAP_ENV__Reason(struct soap *soap, int n = -1) { return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL); }

inline struct SOAP_ENV__Reason * soap_new_req_SOAP_ENV__Reason(
	struct soap *soap)
{	struct SOAP_ENV__Reason *_p = soap_new_SOAP_ENV__Reason(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Reason(soap, _p);
	}
	return _p;
}

inline struct SOAP_ENV__Reason * soap_new_set_SOAP_ENV__Reason(
	struct soap *soap,
	char *SOAP_ENV__Text)
{	struct SOAP_ENV__Reason *_p = soap_new_SOAP_ENV__Reason(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Reason(soap, _p);
		_p->SOAP_ENV__Text = SOAP_ENV__Text;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap*, const struct SOAP_ENV__Reason *, const char*, const char*);

#ifndef soap_write_SOAP_ENV__Reason
#define soap_write_SOAP_ENV__Reason(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize_SOAP_ENV__Reason(soap, data), 0) || PDFSignature::soap_put_SOAP_ENV__Reason(soap, data, "SOAP-ENV:Reason", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *, const char*, const char*);

#ifndef soap_read_SOAP_ENV__Reason
#define soap_read_SOAP_ENV__Reason(soap, data) ( ((data) ? (PDFSignature::soap_default_SOAP_ENV__Reason(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_SOAP_ENV__Reason(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_PDFSignature_SOAP_ENV__Detail
#define SOAP_TYPE_PDFSignature_SOAP_ENV__Detail (52)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap*, const struct SOAP_ENV__Detail *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap*, const char*, int, const struct SOAP_ENV__Detail *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap*, const char*, struct SOAP_ENV__Detail *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Detail * soap_new_SOAP_ENV__Detail(struct soap *soap, int n = -1) { return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL); }

inline struct SOAP_ENV__Detail * soap_new_req_SOAP_ENV__Detail(
	struct soap *soap,
	int __type,
	void *fault)
{	struct SOAP_ENV__Detail *_p = soap_new_SOAP_ENV__Detail(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Detail(soap, _p);
		_p->__type = __type;
		_p->fault = fault;
	}
	return _p;
}

inline struct SOAP_ENV__Detail * soap_new_set_SOAP_ENV__Detail(
	struct soap *soap,
	char *__any,
	int __type,
	void *fault)
{	struct SOAP_ENV__Detail *_p = soap_new_SOAP_ENV__Detail(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Detail(soap, _p);
		_p->__any = __any;
		_p->__type = __type;
		_p->fault = fault;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap*, const struct SOAP_ENV__Detail *, const char*, const char*);

#ifndef soap_write_SOAP_ENV__Detail
#define soap_write_SOAP_ENV__Detail(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize_SOAP_ENV__Detail(soap, data), 0) || PDFSignature::soap_put_SOAP_ENV__Detail(soap, data, "SOAP-ENV:Detail", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *, const char*, const char*);

#ifndef soap_read_SOAP_ENV__Detail
#define soap_read_SOAP_ENV__Detail(soap, data) ( ((data) ? (PDFSignature::soap_default_SOAP_ENV__Detail(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_SOAP_ENV__Detail(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_PDFSignature_SOAP_ENV__Code
#define SOAP_TYPE_PDFSignature_SOAP_ENV__Code (50)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap*, const struct SOAP_ENV__Code *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap*, const char*, int, const struct SOAP_ENV__Code *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap*, const char*, struct SOAP_ENV__Code *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Code * soap_new_SOAP_ENV__Code(struct soap *soap, int n = -1) { return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL); }

inline struct SOAP_ENV__Code * soap_new_req_SOAP_ENV__Code(
	struct soap *soap)
{	struct SOAP_ENV__Code *_p = soap_new_SOAP_ENV__Code(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Code(soap, _p);
	}
	return _p;
}

inline struct SOAP_ENV__Code * soap_new_set_SOAP_ENV__Code(
	struct soap *soap,
	char *SOAP_ENV__Value,
	struct SOAP_ENV__Code *SOAP_ENV__Subcode)
{	struct SOAP_ENV__Code *_p = soap_new_SOAP_ENV__Code(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Code(soap, _p);
		_p->SOAP_ENV__Value = SOAP_ENV__Value;
		_p->SOAP_ENV__Subcode = SOAP_ENV__Subcode;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap*, const struct SOAP_ENV__Code *, const char*, const char*);

#ifndef soap_write_SOAP_ENV__Code
#define soap_write_SOAP_ENV__Code(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize_SOAP_ENV__Code(soap, data), 0) || PDFSignature::soap_put_SOAP_ENV__Code(soap, data, "SOAP-ENV:Code", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *, const char*, const char*);

#ifndef soap_read_SOAP_ENV__Code
#define soap_read_SOAP_ENV__Code(soap, data) ( ((data) ? (PDFSignature::soap_default_SOAP_ENV__Code(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_SOAP_ENV__Code(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_PDFSignature_SOAP_ENV__Header
#define SOAP_TYPE_PDFSignature_SOAP_ENV__Header (49)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap*, const struct SOAP_ENV__Header *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap*, const char*, int, const struct SOAP_ENV__Header *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap*, const char*, struct SOAP_ENV__Header *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Header * soap_new_SOAP_ENV__Header(struct soap *soap, int n = -1) { return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL); }

inline struct SOAP_ENV__Header * soap_new_req_SOAP_ENV__Header(
	struct soap *soap)
{	struct SOAP_ENV__Header *_p = soap_new_SOAP_ENV__Header(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Header(soap, _p);
	}
	return _p;
}

inline struct SOAP_ENV__Header * soap_new_set_SOAP_ENV__Header(
	struct soap *soap)
{	struct SOAP_ENV__Header *_p = soap_new_SOAP_ENV__Header(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Header(soap, _p);
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap*, const struct SOAP_ENV__Header *, const char*, const char*);

#ifndef soap_write_SOAP_ENV__Header
#define soap_write_SOAP_ENV__Header(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize_SOAP_ENV__Header(soap, data), 0) || PDFSignature::soap_put_SOAP_ENV__Header(soap, data, "SOAP-ENV:Header", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header *, const char*, const char*);

#ifndef soap_read_SOAP_ENV__Header
#define soap_read_SOAP_ENV__Header(soap, data) ( ((data) ? (PDFSignature::soap_default_SOAP_ENV__Header(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_SOAP_ENV__Header(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#endif

#ifndef SOAP_TYPE_PDFSignature___ns1__Sign
#define SOAP_TYPE_PDFSignature___ns1__Sign (48)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Sign(struct soap*, struct __ns1__Sign *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Sign(struct soap*, const struct __ns1__Sign *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Sign(struct soap*, const char*, int, const struct __ns1__Sign *, const char*);
SOAP_FMAC3 struct __ns1__Sign * SOAP_FMAC4 soap_in___ns1__Sign(struct soap*, const char*, struct __ns1__Sign *, const char*);
SOAP_FMAC1 struct __ns1__Sign * SOAP_FMAC2 soap_instantiate___ns1__Sign(struct soap*, int, const char*, const char*, size_t*);

inline struct __ns1__Sign * soap_new___ns1__Sign(struct soap *soap, int n = -1) { return soap_instantiate___ns1__Sign(soap, n, NULL, NULL, NULL); }

inline struct __ns1__Sign * soap_new_req___ns1__Sign(
	struct soap *soap)
{	struct __ns1__Sign *_p = soap_new___ns1__Sign(soap);
	if (_p)
	{	soap_default___ns1__Sign(soap, _p);
	}
	return _p;
}

inline struct __ns1__Sign * soap_new_set___ns1__Sign(
	struct soap *soap,
	ns1__SignRequest *ns1__SignRequest_)
{	struct __ns1__Sign *_p = soap_new___ns1__Sign(soap);
	if (_p)
	{	soap_default___ns1__Sign(soap, _p);
		_p->ns1__SignRequest_ = ns1__SignRequest_;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Sign(struct soap*, const struct __ns1__Sign *, const char*, const char*);

#ifndef soap_write___ns1__Sign
#define soap_write___ns1__Sign(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize___ns1__Sign(soap, data), 0) || PDFSignature::soap_put___ns1__Sign(soap, data, "-ns1:Sign", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 struct __ns1__Sign * SOAP_FMAC4 soap_get___ns1__Sign(struct soap*, struct __ns1__Sign *, const char*, const char*);

#ifndef soap_read___ns1__Sign
#define soap_read___ns1__Sign(soap, data) ( ((data) ? (PDFSignature::soap_default___ns1__Sign(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get___ns1__Sign(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_PDFSignature_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PDFSignature_PointerToSOAP_ENV__Reason (58)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap*, const char *, int, struct SOAP_ENV__Reason *const*, const char *);
SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap*, const char*, struct SOAP_ENV__Reason **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *const*, const char*, const char*);

#ifndef soap_write_PointerToSOAP_ENV__Reason
#define soap_write_PointerToSOAP_ENV__Reason(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize_PointerToSOAP_ENV__Reason(soap, data), 0) || PDFSignature::soap_put_PointerToSOAP_ENV__Reason(soap, data, "SOAP-ENV:Reason", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason **, const char*, const char*);

#ifndef soap_read_PointerToSOAP_ENV__Reason
#define soap_read_PointerToSOAP_ENV__Reason(soap, data) ( ((data) ? (PDFSignature::soap_default_PointerToSOAP_ENV__Reason(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_PointerToSOAP_ENV__Reason(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_PDFSignature_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PDFSignature_PointerToSOAP_ENV__Detail (57)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap*, const char *, int, struct SOAP_ENV__Detail *const*, const char *);
SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap*, const char*, struct SOAP_ENV__Detail **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *const*, const char*, const char*);

#ifndef soap_write_PointerToSOAP_ENV__Detail
#define soap_write_PointerToSOAP_ENV__Detail(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize_PointerToSOAP_ENV__Detail(soap, data), 0) || PDFSignature::soap_put_PointerToSOAP_ENV__Detail(soap, data, "SOAP-ENV:Detail", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail **, const char*, const char*);

#ifndef soap_read_PointerToSOAP_ENV__Detail
#define soap_read_PointerToSOAP_ENV__Detail(soap, data) ( ((data) ? (PDFSignature::soap_default_PointerToSOAP_ENV__Detail(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_PointerToSOAP_ENV__Detail(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_PDFSignature_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PDFSignature_PointerToSOAP_ENV__Code (51)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap*, const char *, int, struct SOAP_ENV__Code *const*, const char *);
SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap*, const char*, struct SOAP_ENV__Code **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *const*, const char*, const char*);

#ifndef soap_write_PointerToSOAP_ENV__Code
#define soap_write_PointerToSOAP_ENV__Code(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize_PointerToSOAP_ENV__Code(soap, data), 0) || PDFSignature::soap_put_PointerToSOAP_ENV__Code(soap, data, "SOAP-ENV:Code", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code **, const char*, const char*);

#ifndef soap_read_PointerToSOAP_ENV__Code
#define soap_read_PointerToSOAP_ENV__Code(soap, data) ( ((data) ? (PDFSignature::soap_default_PointerToSOAP_ENV__Code(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_PointerToSOAP_ENV__Code(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#endif

#ifndef SOAP_TYPE_PDFSignature_PointerTons1__SignRequest
#define SOAP_TYPE_PDFSignature_PointerTons1__SignRequest (45)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SignRequest(struct soap*, ns1__SignRequest *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SignRequest(struct soap*, const char *, int, ns1__SignRequest *const*, const char *);
SOAP_FMAC3 ns1__SignRequest ** SOAP_FMAC4 soap_in_PointerTons1__SignRequest(struct soap*, const char*, ns1__SignRequest **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SignRequest(struct soap*, ns1__SignRequest *const*, const char*, const char*);

#ifndef soap_write_PointerTons1__SignRequest
#define soap_write_PointerTons1__SignRequest(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize_PointerTons1__SignRequest(soap, data), 0) || PDFSignature::soap_put_PointerTons1__SignRequest(soap, data, "ns1:SignRequest", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 ns1__SignRequest ** SOAP_FMAC4 soap_get_PointerTons1__SignRequest(struct soap*, ns1__SignRequest **, const char*, const char*);

#ifndef soap_read_PointerTons1__SignRequest
#define soap_read_PointerTons1__SignRequest(soap, data) ( ((data) ? (PDFSignature::soap_default_PointerTons1__SignRequest(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_PointerTons1__SignRequest(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_PointerToxsd__base64Binary
#define SOAP_TYPE_PDFSignature_PointerToxsd__base64Binary (44)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap*, xsd__base64Binary *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap*, const char *, int, xsd__base64Binary *const*, const char *);
SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap*, const char*, xsd__base64Binary **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap*, xsd__base64Binary *const*, const char*, const char*);

#ifndef soap_write_PointerToxsd__base64Binary
#define soap_write_PointerToxsd__base64Binary(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize_PointerToxsd__base64Binary(soap, data), 0) || PDFSignature::soap_put_PointerToxsd__base64Binary(soap, data, "xsd:base64Binary", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap*, xsd__base64Binary **, const char*, const char*);

#ifndef soap_read_PointerToxsd__base64Binary
#define soap_read_PointerToxsd__base64Binary(soap, data) ( ((data) ? (PDFSignature::soap_default_PointerToxsd__base64Binary(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_PointerToxsd__base64Binary(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_PointerTons1__Status
#define SOAP_TYPE_PDFSignature_PointerTons1__Status (43)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Status(struct soap*, ns1__Status *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Status(struct soap*, const char *, int, ns1__Status *const*, const char *);
SOAP_FMAC3 ns1__Status ** SOAP_FMAC4 soap_in_PointerTons1__Status(struct soap*, const char*, ns1__Status **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Status(struct soap*, ns1__Status *const*, const char*, const char*);

#ifndef soap_write_PointerTons1__Status
#define soap_write_PointerTons1__Status(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize_PointerTons1__Status(soap, data), 0) || PDFSignature::soap_put_PointerTons1__Status(soap, data, "ns1:Status", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 ns1__Status ** SOAP_FMAC4 soap_get_PointerTons1__Status(struct soap*, ns1__Status **, const char*, const char*);

#ifndef soap_read_PointerTons1__Status
#define soap_read_PointerTons1__Status(soap, data) ( ((data) ? (PDFSignature::soap_default_PointerTons1__Status(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_PointerTons1__Status(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_PointerTons1__SubAttributeType
#define SOAP_TYPE_PDFSignature_PointerTons1__SubAttributeType (41)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SubAttributeType(struct soap*, ns1__SubAttributeType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SubAttributeType(struct soap*, const char *, int, ns1__SubAttributeType *const*, const char *);
SOAP_FMAC3 ns1__SubAttributeType ** SOAP_FMAC4 soap_in_PointerTons1__SubAttributeType(struct soap*, const char*, ns1__SubAttributeType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SubAttributeType(struct soap*, ns1__SubAttributeType *const*, const char*, const char*);

#ifndef soap_write_PointerTons1__SubAttributeType
#define soap_write_PointerTons1__SubAttributeType(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize_PointerTons1__SubAttributeType(soap, data), 0) || PDFSignature::soap_put_PointerTons1__SubAttributeType(soap, data, "ns1:SubAttributeType", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 ns1__SubAttributeType ** SOAP_FMAC4 soap_get_PointerTons1__SubAttributeType(struct soap*, ns1__SubAttributeType **, const char*, const char*);

#ifndef soap_read_PointerTons1__SubAttributeType
#define soap_read_PointerTons1__SubAttributeType(soap, data) ( ((data) ? (PDFSignature::soap_default_PointerTons1__SubAttributeType(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_PointerTons1__SubAttributeType(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_PointerTons1__SubAttributeListType
#define SOAP_TYPE_PDFSignature_PointerTons1__SubAttributeListType (39)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SubAttributeListType(struct soap*, ns1__SubAttributeListType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SubAttributeListType(struct soap*, const char *, int, ns1__SubAttributeListType *const*, const char *);
SOAP_FMAC3 ns1__SubAttributeListType ** SOAP_FMAC4 soap_in_PointerTons1__SubAttributeListType(struct soap*, const char*, ns1__SubAttributeListType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SubAttributeListType(struct soap*, ns1__SubAttributeListType *const*, const char*, const char*);

#ifndef soap_write_PointerTons1__SubAttributeListType
#define soap_write_PointerTons1__SubAttributeListType(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize_PointerTons1__SubAttributeListType(soap, data), 0) || PDFSignature::soap_put_PointerTons1__SubAttributeListType(soap, data, "ns1:SubAttributeListType", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 ns1__SubAttributeListType ** SOAP_FMAC4 soap_get_PointerTons1__SubAttributeListType(struct soap*, ns1__SubAttributeListType **, const char*, const char*);

#ifndef soap_read_PointerTons1__SubAttributeListType
#define soap_read_PointerTons1__SubAttributeListType(soap, data) ( ((data) ? (PDFSignature::soap_default_PointerTons1__SubAttributeListType(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_PointerTons1__SubAttributeListType(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_PointerTons1__LegalActListType
#define SOAP_TYPE_PDFSignature_PointerTons1__LegalActListType (38)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__LegalActListType(struct soap*, ns1__LegalActListType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__LegalActListType(struct soap*, const char *, int, ns1__LegalActListType *const*, const char *);
SOAP_FMAC3 ns1__LegalActListType ** SOAP_FMAC4 soap_in_PointerTons1__LegalActListType(struct soap*, const char*, ns1__LegalActListType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__LegalActListType(struct soap*, ns1__LegalActListType *const*, const char*, const char*);

#ifndef soap_write_PointerTons1__LegalActListType
#define soap_write_PointerTons1__LegalActListType(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize_PointerTons1__LegalActListType(soap, data), 0) || PDFSignature::soap_put_PointerTons1__LegalActListType(soap, data, "ns1:LegalActListType", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 ns1__LegalActListType ** SOAP_FMAC4 soap_get_PointerTons1__LegalActListType(struct soap*, ns1__LegalActListType **, const char*, const char*);

#ifndef soap_read_PointerTons1__LegalActListType
#define soap_read_PointerTons1__LegalActListType(soap, data) ( ((data) ? (PDFSignature::soap_default_PointerTons1__LegalActListType(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_PointerTons1__LegalActListType(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_PointerTostd__string
#define SOAP_TYPE_PDFSignature_PointerTostd__string (37)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap*, std::string *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap*, const char *, int, std::string *const*, const char *);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap*, const char*, std::string **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap*, std::string *const*, const char*, const char*);

#ifndef soap_write_PointerTostd__string
#define soap_write_PointerTostd__string(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize_PointerTostd__string(soap, data), 0) || PDFSignature::soap_put_PointerTostd__string(soap, data, "string", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap*, std::string **, const char*, const char*);

#ifndef soap_read_PointerTostd__string
#define soap_read_PointerTostd__string(soap, data) ( ((data) ? (PDFSignature::soap_default_PointerTostd__string(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_PointerTostd__string(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_PointerTons1__MainAttributeType
#define SOAP_TYPE_PDFSignature_PointerTons1__MainAttributeType (36)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MainAttributeType(struct soap*, ns1__MainAttributeType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MainAttributeType(struct soap*, const char *, int, ns1__MainAttributeType *const*, const char *);
SOAP_FMAC3 ns1__MainAttributeType ** SOAP_FMAC4 soap_in_PointerTons1__MainAttributeType(struct soap*, const char*, ns1__MainAttributeType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MainAttributeType(struct soap*, ns1__MainAttributeType *const*, const char*, const char*);

#ifndef soap_write_PointerTons1__MainAttributeType
#define soap_write_PointerTons1__MainAttributeType(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize_PointerTons1__MainAttributeType(soap, data), 0) || PDFSignature::soap_put_PointerTons1__MainAttributeType(soap, data, "ns1:MainAttributeType", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 ns1__MainAttributeType ** SOAP_FMAC4 soap_get_PointerTons1__MainAttributeType(struct soap*, ns1__MainAttributeType **, const char*, const char*);

#ifndef soap_read_PointerTons1__MainAttributeType
#define soap_read_PointerTons1__MainAttributeType(soap, data) ( ((data) ? (PDFSignature::soap_default_PointerTons1__MainAttributeType(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_PointerTons1__MainAttributeType(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_PointerTons1__AttributeSupplierType
#define SOAP_TYPE_PDFSignature_PointerTons1__AttributeSupplierType (35)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AttributeSupplierType(struct soap*, ns1__AttributeSupplierType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AttributeSupplierType(struct soap*, const char *, int, ns1__AttributeSupplierType *const*, const char *);
SOAP_FMAC3 ns1__AttributeSupplierType ** SOAP_FMAC4 soap_in_PointerTons1__AttributeSupplierType(struct soap*, const char*, ns1__AttributeSupplierType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AttributeSupplierType(struct soap*, ns1__AttributeSupplierType *const*, const char*, const char*);

#ifndef soap_write_PointerTons1__AttributeSupplierType
#define soap_write_PointerTons1__AttributeSupplierType(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize_PointerTons1__AttributeSupplierType(soap, data), 0) || PDFSignature::soap_put_PointerTons1__AttributeSupplierType(soap, data, "ns1:AttributeSupplierType", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 ns1__AttributeSupplierType ** SOAP_FMAC4 soap_get_PointerTons1__AttributeSupplierType(struct soap*, ns1__AttributeSupplierType **, const char*, const char*);

#ifndef soap_read_PointerTons1__AttributeSupplierType
#define soap_read_PointerTons1__AttributeSupplierType(soap, data) ( ((data) ? (PDFSignature::soap_default_PointerTons1__AttributeSupplierType(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_PointerTons1__AttributeSupplierType(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_PointerTons1__AttributeType
#define SOAP_TYPE_PDFSignature_PointerTons1__AttributeType (33)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AttributeType(struct soap*, ns1__AttributeType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AttributeType(struct soap*, const char *, int, ns1__AttributeType *const*, const char *);
SOAP_FMAC3 ns1__AttributeType ** SOAP_FMAC4 soap_in_PointerTons1__AttributeType(struct soap*, const char*, ns1__AttributeType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AttributeType(struct soap*, ns1__AttributeType *const*, const char*, const char*);

#ifndef soap_write_PointerTons1__AttributeType
#define soap_write_PointerTons1__AttributeType(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize_PointerTons1__AttributeType(soap, data), 0) || PDFSignature::soap_put_PointerTons1__AttributeType(soap, data, "ns1:AttributeType", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 ns1__AttributeType ** SOAP_FMAC4 soap_get_PointerTons1__AttributeType(struct soap*, ns1__AttributeType **, const char*, const char*);

#ifndef soap_read_PointerTons1__AttributeType
#define soap_read_PointerTons1__AttributeType(soap, data) ( ((data) ? (PDFSignature::soap_default_PointerTons1__AttributeType(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_PointerTons1__AttributeType(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_PointerToint
#define SOAP_TYPE_PDFSignature_PointerToint (32)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap*, int *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap*, const char *, int, int *const*, const char *);
SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap*, const char*, int **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap*, int *const*, const char*, const char*);

#ifndef soap_write_PointerToint
#define soap_write_PointerToint(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize_PointerToint(soap, data), 0) || PDFSignature::soap_put_PointerToint(soap, data, "int", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap*, int **, const char*, const char*);

#ifndef soap_read_PointerToint
#define soap_read_PointerToint(soap, data) ( ((data) ? (PDFSignature::soap_default_PointerToint(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_PointerToint(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_PointerTons1__AttributeListType
#define SOAP_TYPE_PDFSignature_PointerTons1__AttributeListType (31)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AttributeListType(struct soap*, ns1__AttributeListType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AttributeListType(struct soap*, const char *, int, ns1__AttributeListType *const*, const char *);
SOAP_FMAC3 ns1__AttributeListType ** SOAP_FMAC4 soap_in_PointerTons1__AttributeListType(struct soap*, const char*, ns1__AttributeListType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AttributeListType(struct soap*, ns1__AttributeListType *const*, const char*, const char*);

#ifndef soap_write_PointerTons1__AttributeListType
#define soap_write_PointerTons1__AttributeListType(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize_PointerTons1__AttributeListType(soap, data), 0) || PDFSignature::soap_put_PointerTons1__AttributeListType(soap, data, "ns1:AttributeListType", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 ns1__AttributeListType ** SOAP_FMAC4 soap_get_PointerTons1__AttributeListType(struct soap*, ns1__AttributeListType **, const char*, const char*);

#ifndef soap_read_PointerTons1__AttributeListType
#define soap_read_PointerTons1__AttributeListType(soap, data) ( ((data) ? (PDFSignature::soap_default_PointerTons1__AttributeListType(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_PointerTons1__AttributeListType(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_PointerTons1__PersonalDataType
#define SOAP_TYPE_PDFSignature_PointerTons1__PersonalDataType (30)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PersonalDataType(struct soap*, ns1__PersonalDataType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PersonalDataType(struct soap*, const char *, int, ns1__PersonalDataType *const*, const char *);
SOAP_FMAC3 ns1__PersonalDataType ** SOAP_FMAC4 soap_in_PointerTons1__PersonalDataType(struct soap*, const char*, ns1__PersonalDataType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PersonalDataType(struct soap*, ns1__PersonalDataType *const*, const char*, const char*);

#ifndef soap_write_PointerTons1__PersonalDataType
#define soap_write_PointerTons1__PersonalDataType(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize_PointerTons1__PersonalDataType(soap, data), 0) || PDFSignature::soap_put_PointerTons1__PersonalDataType(soap, data, "ns1:PersonalDataType", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 ns1__PersonalDataType ** SOAP_FMAC4 soap_get_PointerTons1__PersonalDataType(struct soap*, ns1__PersonalDataType **, const char*, const char*);

#ifndef soap_read_PointerTons1__PersonalDataType
#define soap_read_PointerTons1__PersonalDataType(soap, data) ( ((data) ? (PDFSignature::soap_default_PointerTons1__PersonalDataType(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_PointerTons1__PersonalDataType(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_PointerTounsignedByte
#define SOAP_TYPE_PDFSignature_PointerTounsignedByte (14)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap*, unsigned char *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap*, const char *, int, unsigned char *const*, const char *);
SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap*, const char*, unsigned char **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap*, unsigned char *const*, const char*, const char*);

#ifndef soap_write_PointerTounsignedByte
#define soap_write_PointerTounsignedByte(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize_PointerTounsignedByte(soap, data), 0) || PDFSignature::soap_put_PointerTounsignedByte(soap, data, "unsignedByte", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap*, unsigned char **, const char*, const char*);

#ifndef soap_read_PointerTounsignedByte
#define soap_read_PointerTounsignedByte(soap, data) ( ((data) ? (PDFSignature::soap_default_PointerTounsignedByte(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_PointerTounsignedByte(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature__QName
#define SOAP_TYPE_PDFSignature__QName (5)
#endif

#define soap_default__QName(soap, a) soap_default_string(soap, a)

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap*, char *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap*, const char*, int, char*const*, const char*);
SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap*, const char*, char **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap*, char *const*, const char*, const char*);

#ifndef soap_write__QName
#define soap_write__QName(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize__QName(soap, data), 0) || PDFSignature::soap_put__QName(soap, data, "QName", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap*, char **, const char*, const char*);

#ifndef soap_read__QName
#define soap_read__QName(soap, data) ( ((data) ? (PDFSignature::soap_default__QName(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get__QName(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_string
#define SOAP_TYPE_PDFSignature_string (4)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap*, char **);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap*, char *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap*, const char*, int, char*const*, const char*);
SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap*, const char*, char **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap*, char *const*, const char*, const char*);

#ifndef soap_write_string
#define soap_write_string(soap, data) ( soap_free_temp(soap), soap_begin_send(soap) || (PDFSignature::soap_serialize_string(soap, data), 0) || PDFSignature::soap_put_string(soap, data, "string", NULL) || soap_end_send(soap), (soap)->error )
#endif

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap*, char **, const char*, const char*);

#ifndef soap_read_string
#define soap_read_string(soap, data) ( ((data) ? (PDFSignature::soap_default_string(soap, (data)), 0) : 0) || soap_begin_recv(soap) || !PDFSignature::soap_get_string(soap, (data), NULL, NULL) || soap_end_recv(soap), (soap)->error )
#endif


#ifndef SOAP_TYPE_PDFSignature_std__vectorTemplateOfPointerTons1__SubAttributeType
#define SOAP_TYPE_PDFSignature_std__vectorTemplateOfPointerTons1__SubAttributeType (42)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SubAttributeType(struct soap*, std::vector<ns1__SubAttributeType *> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SubAttributeType(struct soap*, const std::vector<ns1__SubAttributeType *> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SubAttributeType(struct soap*, const char*, int, const std::vector<ns1__SubAttributeType *> *, const char*);
SOAP_FMAC3 std::vector<ns1__SubAttributeType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SubAttributeType(struct soap*, const char*, std::vector<ns1__SubAttributeType *> *, const char*);
SOAP_FMAC1 std::vector<ns1__SubAttributeType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__SubAttributeType(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<ns1__SubAttributeType *>  * soap_new_std__vectorTemplateOfPointerTons1__SubAttributeType(struct soap *soap, int n = -1) { return soap_instantiate_std__vectorTemplateOfPointerTons1__SubAttributeType(soap, n, NULL, NULL, NULL); }

#ifndef SOAP_TYPE_PDFSignature_std__vectorTemplateOfstd__string
#define SOAP_TYPE_PDFSignature_std__vectorTemplateOfstd__string (40)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap*, std::vector<std::string> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap*, const std::vector<std::string> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap*, const char*, int, const std::vector<std::string> *, const char*);
SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap*, const char*, std::vector<std::string> *, const char*);
SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<std::string>  * soap_new_std__vectorTemplateOfstd__string(struct soap *soap, int n = -1) { return soap_instantiate_std__vectorTemplateOfstd__string(soap, n, NULL, NULL, NULL); }

#ifndef SOAP_TYPE_PDFSignature_std__vectorTemplateOfPointerTons1__AttributeType
#define SOAP_TYPE_PDFSignature_std__vectorTemplateOfPointerTons1__AttributeType (34)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__AttributeType(struct soap*, std::vector<ns1__AttributeType *> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__AttributeType(struct soap*, const std::vector<ns1__AttributeType *> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__AttributeType(struct soap*, const char*, int, const std::vector<ns1__AttributeType *> *, const char*);
SOAP_FMAC3 std::vector<ns1__AttributeType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__AttributeType(struct soap*, const char*, std::vector<ns1__AttributeType *> *, const char*);
SOAP_FMAC1 std::vector<ns1__AttributeType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__AttributeType(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<ns1__AttributeType *>  * soap_new_std__vectorTemplateOfPointerTons1__AttributeType(struct soap *soap, int n = -1) { return soap_instantiate_std__vectorTemplateOfPointerTons1__AttributeType(soap, n, NULL, NULL, NULL); }

} // namespace PDFSignature


#endif

/* End of PDFSignatureH.h */

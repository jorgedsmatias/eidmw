/* soapStub.h
   Generated by gSOAP 2.8.28 from SCAP-ASService.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#define SOAP_NAMESPACE_OF_wsc	"http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512"
#include <deque>
#include <list>
#include <vector>
#include <set>
#define SOAP_NAMESPACE_OF_ns1	"http://www.cartaodecidadao.pt/ccc/sccc/services/AttributeSupplierService"
#define SOAP_NAMESPACE_OF_ns2	"http://www.cartaodecidadao.pt/ccc/sccc/messages/AttributeSupplierService"
#define SOAP_NAMESPACE_OF_ns3	"http://www.cartaodecidadao.pt/ccc/commons/messages/Attribute"
#define SOAP_NAMESPACE_OF_ns4	"http://www.cartaodecidadao.pt/ccc/commons/messages/Types"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20828
# error "GSOAP VERSION 20828 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/* wsu.h:66 */
#ifndef SOAP_TYPE_wsu__tTimestampFault
#define SOAP_TYPE_wsu__tTimestampFault (8)
/* wsu:tTimestampFault */
enum wsu__tTimestampFault
{
	wsu__MessageExpired = 0
};
#endif

/* wsse.h:98 */
#ifndef SOAP_TYPE_wsse__FaultcodeEnum
#define SOAP_TYPE_wsse__FaultcodeEnum (10)
/* wsse:FaultcodeEnum */
enum wsse__FaultcodeEnum
{
	wsse__UnsupportedSecurityToken = 0,
	wsse__UnsupportedAlgorithm = 1,
	wsse__InvalidSecurity = 2,
	wsse__InvalidSecurityToken = 3,
	wsse__FailedAuthentication = 4,
	wsse__FailedCheck = 5,
	wsse__SecurityTokenUnavailable = 6
};
#endif

/* wsc.h:62 */
#ifndef SOAP_TYPE_wsc__FaultCodeType
#define SOAP_TYPE_wsc__FaultCodeType (83)
/* wsc:FaultCodeType */
enum wsc__FaultCodeType
{
	wsc__BadContextToken = 0,
	wsc__UnsupportedContextToken = 1,
	wsc__UnknownDerivationSource = 2,
	wsc__RenewNeeded = 3,
	wsc__UnableToRenew = 4
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs, and Unions                                               *
 *                                                                            *
\******************************************************************************/

struct _wsu__Timestamp;	/* wsu.h:76 */
struct _wsse__UsernameToken;	/* wsse.h:114 */
struct _wsse__BinarySecurityToken;	/* wsse.h:125 */
struct _wsse__Reference;	/* wsse.h:135 */
struct _wsse__Embedded;	/* wsse.h:143 */
struct _wsse__KeyIdentifier;	/* wsse.h:152 */
struct _wsse__SecurityTokenReference;	/* wsse.h:162 */
struct ds__SignatureType;	/* ds.h:47 */
struct _c14n__InclusiveNamespaces;	/* c14n.h:24 */
struct ds__TransformType;	/* ds.h:74 */
struct ds__KeyInfoType;	/* ds.h:49 */
struct ds__SignedInfoType;	/* ds.h:47 */
struct ds__CanonicalizationMethodType;	/* ds.h:60 */
struct ds__SignatureMethodType;	/* ds.h:63 */
struct ds__ReferenceType;	/* ds.h:66 */
struct ds__TransformsType;	/* ds.h:69 */
struct ds__DigestMethodType;	/* ds.h:80 */
struct ds__KeyValueType;	/* ds.h:86 */
struct ds__RetrievalMethodType;	/* ds.h:87 */
struct ds__X509DataType;	/* wsse.h:165 */
struct ds__X509IssuerSerialType;	/* ds.h:103 */
struct ds__DSAKeyValueType;	/* ds.h:124 */
struct ds__RSAKeyValueType;	/* ds.h:127 */
struct xenc__EncryptionPropertyType;	/* xenc.h:84 */
struct xenc__EncryptedType;	/* xenc.h:53 */
struct xenc__EncryptionMethodType;	/* xenc.h:56 */
struct xenc__CipherDataType;	/* xenc.h:59 */
struct xenc__CipherReferenceType;	/* xenc.h:62 */
struct xenc__TransformsType;	/* xenc.h:65 */
struct xenc__AgreementMethodType;	/* xenc.h:74 */
struct xenc__ReferenceType;	/* xenc.h:77 */
struct xenc__EncryptionPropertiesType;	/* xenc.h:80 */
struct __xenc__union_ReferenceList;	/* xenc.h:238 */
struct _xenc__ReferenceList;	/* xenc.h:89 */
struct xenc__EncryptedDataType;	/* xenc.h:68 */
struct xenc__EncryptedKeyType;	/* xenc.h:71 */
struct wsc__SecurityContextTokenType;	/* wsc.h:87 */
union _wsc__union_DerivedKeyTokenType;	/* wsc.h:125 */
struct __wsc__DerivedKeyTokenType_sequence;	/* wsc.h:116 */
struct wsc__DerivedKeyTokenType;	/* wsc.h:109 */
struct wsc__PropertiesType;	/* wsc.h:113 */
struct _wsse__Security;	/* wsse.h:177 */
struct _wsse__Password;	/* wsse.h:115 */
class ns2__AttributeSupplierResponseType;	/* SCAP-ASService.h:174 */
class ns3__AttributeType;	/* SCAP-ASService.h:177 */
class ns3__AttributeSupplierType;	/* SCAP-ASService.h:180 */
class ns3__PersonalDataType;	/* SCAP-ASService.h:183 */
class ns3__ExtraIDListType;	/* SCAP-ASService.h:186 */
class ns3__ExtraIDType;	/* SCAP-ASService.h:189 */
class ns3__MainAttributeType;	/* SCAP-ASService.h:192 */
class ns3__LegalActListType;	/* SCAP-ASService.h:195 */
class ns3__SubAttributeListType;	/* SCAP-ASService.h:198 */
class ns3__SubAttributeType;	/* SCAP-ASService.h:201 */
class ns3__ResponseCodeStatusType;	/* SCAP-ASService.h:204 */
struct __ns1__AttributeSuppliers;	/* SCAP-ASService.h:782 */

/* wsu.h:76 */
#ifndef SOAP_TYPE__wsu__Timestamp
#define SOAP_TYPE__wsu__Timestamp (9)
/* wsu:Timestamp complex type: */
struct _wsu__Timestamp
{
public:
	char *wsu__Id;	/* optional attribute of XSD type xsd:string */
	char *Created;	/* optional element of XSD type xsd:string */
	char *Expires;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 9; } /* = unique type id SOAP_TYPE__wsu__Timestamp */
	         _wsu__Timestamp();
	friend SOAP_FMAC1 _wsu__Timestamp * SOAP_FMAC2 soap_instantiate__wsu__Timestamp(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:114 */
#ifndef SOAP_TYPE__wsse__UsernameToken
#define SOAP_TYPE__wsse__UsernameToken (11)
/* wsse:UsernameToken complex type: */
struct _wsse__UsernameToken
{
public:
	char *Username;	/* optional element of XSD type xsd:string */
	struct _wsse__Password *Password;	/* optional element of XSD type wsse:Password */
	char *Nonce;	/* optional element of XSD type xsd:string */
	char *wsu__Created;	/* optional element of XSD type xsd:string */
	char *wsu__Id;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 11; } /* = unique type id SOAP_TYPE__wsse__UsernameToken */
	         _wsse__UsernameToken();
	friend SOAP_FMAC1 _wsse__UsernameToken * SOAP_FMAC2 soap_instantiate__wsse__UsernameToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:125 */
#ifndef SOAP_TYPE__wsse__BinarySecurityToken
#define SOAP_TYPE__wsse__BinarySecurityToken (14)
/* wsse:BinarySecurityToken simple type: */
struct _wsse__BinarySecurityToken
{
public:
	char *__item;	/* mixed XML content */
	char *wsu__Id;	/* optional attribute of XSD type xsd:string */
	char *ValueType;	/* optional attribute of XSD type xsd:string */
	char *EncodingType;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 14; } /* = unique type id SOAP_TYPE__wsse__BinarySecurityToken */
	         _wsse__BinarySecurityToken();
	friend SOAP_FMAC1 _wsse__BinarySecurityToken * SOAP_FMAC2 soap_instantiate__wsse__BinarySecurityToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:135 */
#ifndef SOAP_TYPE__wsse__Reference
#define SOAP_TYPE__wsse__Reference (15)
/* wsse:Reference complex type: */
struct _wsse__Reference
{
public:
	char *URI;	/* optional attribute of XSD type xsd:string */
	char *ValueType;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 15; } /* = unique type id SOAP_TYPE__wsse__Reference */
	         _wsse__Reference();
	friend SOAP_FMAC1 _wsse__Reference * SOAP_FMAC2 soap_instantiate__wsse__Reference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:143 */
#ifndef SOAP_TYPE__wsse__Embedded
#define SOAP_TYPE__wsse__Embedded (16)
/* wsse:Embedded complex type: */
struct _wsse__Embedded
{
public:
	char *wsu__Id;	/* optional attribute of XSD type xsd:string */
	char *ValueType;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 16; } /* = unique type id SOAP_TYPE__wsse__Embedded */
	         _wsse__Embedded();
	friend SOAP_FMAC1 _wsse__Embedded * SOAP_FMAC2 soap_instantiate__wsse__Embedded(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:152 */
#ifndef SOAP_TYPE__wsse__KeyIdentifier
#define SOAP_TYPE__wsse__KeyIdentifier (17)
/* wsse:KeyIdentifier simple type: */
struct _wsse__KeyIdentifier
{
public:
	char *__item;	/* mixed XML content */
	char *wsu__Id;	/* optional attribute of XSD type xsd:string */
	char *ValueType;	/* optional attribute of XSD type xsd:string */
	char *EncodingType;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 17; } /* = unique type id SOAP_TYPE__wsse__KeyIdentifier */
	         _wsse__KeyIdentifier();
	friend SOAP_FMAC1 _wsse__KeyIdentifier * SOAP_FMAC2 soap_instantiate__wsse__KeyIdentifier(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:162 */
#ifndef SOAP_TYPE__wsse__SecurityTokenReference
#define SOAP_TYPE__wsse__SecurityTokenReference (18)
/* wsse:SecurityTokenReference complex type: */
struct _wsse__SecurityTokenReference
{
public:
	struct _wsse__Reference *Reference;	/* optional element of XSD type wsse:Reference */
	struct _wsse__KeyIdentifier *KeyIdentifier;	/* optional element of XSD type wsse:KeyIdentifier */
	struct _wsse__Embedded *Embedded;	/* optional element of XSD type wsse:Embedded */
	struct ds__X509DataType *ds__X509Data;	/* optional element of XSD type ds:X509DataType */
	char *wsu__Id;	/* optional attribute of XSD type xsd:string */
	char *wsc__Instance;	/* optional attribute of XSD type xsd:string */
	char *Usage;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 18; } /* = unique type id SOAP_TYPE__wsse__SecurityTokenReference */
	         _wsse__SecurityTokenReference();
	friend SOAP_FMAC1 _wsse__SecurityTokenReference * SOAP_FMAC2 soap_instantiate__wsse__SecurityTokenReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:47 */
#ifndef SOAP_TYPE_ds__SignatureType
#define SOAP_TYPE_ds__SignatureType (24)
/* ds:SignatureType complex type: */
struct ds__SignatureType
{
public:
	struct ds__SignedInfoType *SignedInfo;	/* optional element of XSD type ds:SignedInfoType */
	char *SignatureValue;	/* optional element of XSD type xsd:string */
	struct ds__KeyInfoType *KeyInfo;	/* optional element of XSD type ds:KeyInfoType */
	char *Id;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 24; } /* = unique type id SOAP_TYPE_ds__SignatureType */
	         ds__SignatureType();
	friend SOAP_FMAC1 ds__SignatureType * SOAP_FMAC2 soap_instantiate_ds__SignatureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* c14n.h:24 */
#ifndef SOAP_TYPE__c14n__InclusiveNamespaces
#define SOAP_TYPE__c14n__InclusiveNamespaces (34)
/* c14n:InclusiveNamespaces complex type: */
struct _c14n__InclusiveNamespaces
{
public:
	char *PrefixList;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 34; } /* = unique type id SOAP_TYPE__c14n__InclusiveNamespaces */
	         _c14n__InclusiveNamespaces();
	friend SOAP_FMAC1 _c14n__InclusiveNamespaces * SOAP_FMAC2 soap_instantiate__c14n__InclusiveNamespaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:74 */
#ifndef SOAP_TYPE_ds__TransformType
#define SOAP_TYPE_ds__TransformType (35)
/* ds:TransformType complex type: */
struct ds__TransformType
{
public:
	struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;	/* optional element of XSD type c14n:InclusiveNamespaces */
	char *__any;
	char *Algorithm;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 35; } /* = unique type id SOAP_TYPE_ds__TransformType */
	         ds__TransformType();
	friend SOAP_FMAC1 ds__TransformType * SOAP_FMAC2 soap_instantiate_ds__TransformType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:49 */
#ifndef SOAP_TYPE_ds__KeyInfoType
#define SOAP_TYPE_ds__KeyInfoType (27)
/* ds:KeyInfoType complex type: */
struct ds__KeyInfoType
{
public:
	char *KeyName;	/* optional element of XSD type xsd:string */
	struct ds__KeyValueType *KeyValue;	/* optional element of XSD type ds:KeyValueType */
	struct ds__RetrievalMethodType *RetrievalMethod;	/* optional element of XSD type ds:RetrievalMethodType */
	struct ds__X509DataType *X509Data;	/* optional element of XSD type ds:X509DataType */
	struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;	/* optional element of XSD type wsse:SecurityTokenReference */
	char *Id;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 27; } /* = unique type id SOAP_TYPE_ds__KeyInfoType */
	         ds__KeyInfoType();
	friend SOAP_FMAC1 ds__KeyInfoType * SOAP_FMAC2 soap_instantiate_ds__KeyInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:47 */
#ifndef SOAP_TYPE_ds__SignedInfoType
#define SOAP_TYPE_ds__SignedInfoType (25)
/* ds:SignedInfoType complex type: */
struct ds__SignedInfoType
{
public:
	struct ds__CanonicalizationMethodType *CanonicalizationMethod;	/* required element of XSD type ds:CanonicalizationMethodType */
	struct ds__SignatureMethodType *SignatureMethod;	/* required element of XSD type ds:SignatureMethodType */
	int __sizeReference;	/* sequence of elements <Reference> of XSD type ds:ReferenceType */
	struct ds__ReferenceType **Reference;
	char *Id;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 25; } /* = unique type id SOAP_TYPE_ds__SignedInfoType */
	         ds__SignedInfoType();
	friend SOAP_FMAC1 ds__SignedInfoType * SOAP_FMAC2 soap_instantiate_ds__SignedInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:60 */
#ifndef SOAP_TYPE_ds__CanonicalizationMethodType
#define SOAP_TYPE_ds__CanonicalizationMethodType (30)
/* ds:CanonicalizationMethodType complex type: */
struct ds__CanonicalizationMethodType
{
public:
	char *Algorithm;	/* required attribute of XSD type xsd:string */
	struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;	/* optional element of XSD type c14n:InclusiveNamespaces */
public:
	int soap_type() const { return 30; } /* = unique type id SOAP_TYPE_ds__CanonicalizationMethodType */
	         ds__CanonicalizationMethodType();
	friend SOAP_FMAC1 ds__CanonicalizationMethodType * SOAP_FMAC2 soap_instantiate_ds__CanonicalizationMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:63 */
#ifndef SOAP_TYPE_ds__SignatureMethodType
#define SOAP_TYPE_ds__SignatureMethodType (31)
/* ds:SignatureMethodType complex type: */
struct ds__SignatureMethodType
{
public:
	int *HMACOutputLength;	/* optional element of XSD type xsd:int */
	char *Algorithm;	/* required attribute of XSD type xsd:string */
public:
	int soap_type() const { return 31; } /* = unique type id SOAP_TYPE_ds__SignatureMethodType */
	         ds__SignatureMethodType();
	friend SOAP_FMAC1 ds__SignatureMethodType * SOAP_FMAC2 soap_instantiate_ds__SignatureMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:66 */
#ifndef SOAP_TYPE_ds__ReferenceType
#define SOAP_TYPE_ds__ReferenceType (32)
/* ds:ReferenceType complex type: */
struct ds__ReferenceType
{
public:
	struct ds__TransformsType *Transforms;	/* optional element of XSD type ds:TransformsType */
	struct ds__DigestMethodType *DigestMethod;	/* required element of XSD type ds:DigestMethodType */
	char *DigestValue;	/* required element of XSD type xsd:string */
	char *Id;	/* optional attribute of XSD type xsd:string */
	char *URI;	/* optional attribute of XSD type xsd:string */
	char *Type;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 32; } /* = unique type id SOAP_TYPE_ds__ReferenceType */
	         ds__ReferenceType();
	friend SOAP_FMAC1 ds__ReferenceType * SOAP_FMAC2 soap_instantiate_ds__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:69 */
#ifndef SOAP_TYPE_ds__TransformsType
#define SOAP_TYPE_ds__TransformsType (33)
/* ds:TransformsType complex type: */
struct ds__TransformsType
{
public:
	int __sizeTransform;	/* sequence of elements <Transform> of XSD type ds:TransformType */
	struct ds__TransformType *Transform;
public:
	int soap_type() const { return 33; } /* = unique type id SOAP_TYPE_ds__TransformsType */
	         ds__TransformsType();
	friend SOAP_FMAC1 ds__TransformsType * SOAP_FMAC2 soap_instantiate_ds__TransformsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:80 */
#ifndef SOAP_TYPE_ds__DigestMethodType
#define SOAP_TYPE_ds__DigestMethodType (38)
/* ds:DigestMethodType complex type: */
struct ds__DigestMethodType
{
public:
	char *Algorithm;	/* required attribute of XSD type xsd:string */
public:
	int soap_type() const { return 38; } /* = unique type id SOAP_TYPE_ds__DigestMethodType */
	         ds__DigestMethodType();
	friend SOAP_FMAC1 ds__DigestMethodType * SOAP_FMAC2 soap_instantiate_ds__DigestMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:86 */
#ifndef SOAP_TYPE_ds__KeyValueType
#define SOAP_TYPE_ds__KeyValueType (39)
/* ds:KeyValueType complex type: */
struct ds__KeyValueType
{
public:
	struct ds__DSAKeyValueType *DSAKeyValue;	/* optional element of XSD type ds:DSAKeyValueType */
	struct ds__RSAKeyValueType *RSAKeyValue;	/* optional element of XSD type ds:RSAKeyValueType */
public:
	int soap_type() const { return 39; } /* = unique type id SOAP_TYPE_ds__KeyValueType */
	         ds__KeyValueType();
	friend SOAP_FMAC1 ds__KeyValueType * SOAP_FMAC2 soap_instantiate_ds__KeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:87 */
#ifndef SOAP_TYPE_ds__RetrievalMethodType
#define SOAP_TYPE_ds__RetrievalMethodType (41)
/* ds:RetrievalMethodType complex type: */
struct ds__RetrievalMethodType
{
public:
	struct ds__TransformsType *Transforms;	/* optional element of XSD type ds:TransformsType */
	char *URI;	/* optional attribute of XSD type xsd:string */
	char *Type;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 41; } /* = unique type id SOAP_TYPE_ds__RetrievalMethodType */
	         ds__RetrievalMethodType();
	friend SOAP_FMAC1 ds__RetrievalMethodType * SOAP_FMAC2 soap_instantiate_ds__RetrievalMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:165 */
#ifndef SOAP_TYPE_ds__X509DataType
#define SOAP_TYPE_ds__X509DataType (22)
/* ds:X509DataType complex type: */
struct ds__X509DataType
{
public:
	struct ds__X509IssuerSerialType *X509IssuerSerial;	/* optional element of XSD type ds:X509IssuerSerialType */
	char *X509SKI;	/* optional element of XSD type xsd:string */
	char *X509SubjectName;	/* optional element of XSD type xsd:string */
	char *X509Certificate;	/* optional element of XSD type xsd:string */
	char *X509CRL;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 22; } /* = unique type id SOAP_TYPE_ds__X509DataType */
	         ds__X509DataType();
	friend SOAP_FMAC1 ds__X509DataType * SOAP_FMAC2 soap_instantiate_ds__X509DataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:103 */
#ifndef SOAP_TYPE_ds__X509IssuerSerialType
#define SOAP_TYPE_ds__X509IssuerSerialType (45)
/* ds:X509IssuerSerialType complex type: */
struct ds__X509IssuerSerialType
{
public:
	char *X509IssuerName;	/* required element of XSD type xsd:string */
	char *X509SerialNumber;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 45; } /* = unique type id SOAP_TYPE_ds__X509IssuerSerialType */
	         ds__X509IssuerSerialType();
	friend SOAP_FMAC1 ds__X509IssuerSerialType * SOAP_FMAC2 soap_instantiate_ds__X509IssuerSerialType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:124 */
#ifndef SOAP_TYPE_ds__DSAKeyValueType
#define SOAP_TYPE_ds__DSAKeyValueType (46)
/* ds:DSAKeyValueType complex type: */
struct ds__DSAKeyValueType
{
public:
	char *G;	/* optional element of XSD type xsd:string */
	char *Y;	/* required element of XSD type xsd:string */
	char *J;	/* optional element of XSD type xsd:string */
	char *P;	/* required element of XSD type xsd:string */
	char *Q;	/* required element of XSD type xsd:string */
	char *Seed;	/* required element of XSD type xsd:string */
	char *PgenCounter;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 46; } /* = unique type id SOAP_TYPE_ds__DSAKeyValueType */
	         ds__DSAKeyValueType();
	friend SOAP_FMAC1 ds__DSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__DSAKeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:127 */
#ifndef SOAP_TYPE_ds__RSAKeyValueType
#define SOAP_TYPE_ds__RSAKeyValueType (47)
/* ds:RSAKeyValueType complex type: */
struct ds__RSAKeyValueType
{
public:
	char *Modulus;	/* required element of XSD type xsd:string */
	char *Exponent;	/* required element of XSD type xsd:string */
public:
	int soap_type() const { return 47; } /* = unique type id SOAP_TYPE_ds__RSAKeyValueType */
	         ds__RSAKeyValueType();
	friend SOAP_FMAC1 ds__RSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__RSAKeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:84 */
#ifndef SOAP_TYPE_xenc__EncryptionPropertyType
#define SOAP_TYPE_xenc__EncryptionPropertyType (69)
/* xenc:EncryptionPropertyType complex type: */
struct xenc__EncryptionPropertyType
{
public:
	char *Target;	/* optional attribute of XSD type xsd:string */
	char *Id;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 69; } /* = unique type id SOAP_TYPE_xenc__EncryptionPropertyType */
	         xenc__EncryptionPropertyType();
	friend SOAP_FMAC1 xenc__EncryptionPropertyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:53 */
#ifndef SOAP_TYPE_xenc__EncryptedType
#define SOAP_TYPE_xenc__EncryptedType (59)
/* xenc:EncryptedType complex type: */
struct xenc__EncryptedType
{
public:
	struct xenc__EncryptionMethodType *EncryptionMethod;	/* optional element of XSD type xenc:EncryptionMethodType */
	struct ds__KeyInfoType *ds__KeyInfo;	/* optional element of XSD type ds:KeyInfo */
	struct xenc__CipherDataType *CipherData;	/* required element of XSD type xenc:CipherDataType */
	struct xenc__EncryptionPropertiesType *EncryptionProperties;	/* optional element of XSD type xenc:EncryptionPropertiesType */
	char *Id;	/* optional attribute of XSD type xsd:string */
	char *Type;	/* optional attribute of XSD type xsd:string */
	char *MimeType;	/* optional attribute of XSD type xsd:string */
	char *Encoding;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 59; } /* = unique type id SOAP_TYPE_xenc__EncryptedType */
	         xenc__EncryptedType();
	friend SOAP_FMAC1 xenc__EncryptedType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:56 */
#ifndef SOAP_TYPE_xenc__EncryptionMethodType
#define SOAP_TYPE_xenc__EncryptionMethodType (60)
/* xenc:EncryptionMethodType complex type: */
struct xenc__EncryptionMethodType
{
public:
	int *KeySize;	/* optional element of XSD type xsd:int */
	char *OAEPparams;	/* optional element of XSD type xsd:string */
	char *Algorithm;	/* required attribute of XSD type xsd:string */
	struct ds__DigestMethodType *ds__DigestMethod;	/* optional element of XSD type ds:DigestMethodType */
	char *__mixed;
public:
	int soap_type() const { return 60; } /* = unique type id SOAP_TYPE_xenc__EncryptionMethodType */
	         xenc__EncryptionMethodType();
	friend SOAP_FMAC1 xenc__EncryptionMethodType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:59 */
#ifndef SOAP_TYPE_xenc__CipherDataType
#define SOAP_TYPE_xenc__CipherDataType (61)
/* xenc:CipherDataType complex type: */
struct xenc__CipherDataType
{
public:
	char *CipherValue;	/* optional element of XSD type xsd:string */
	struct xenc__CipherReferenceType *CipherReference;	/* optional element of XSD type xenc:CipherReferenceType */
public:
	int soap_type() const { return 61; } /* = unique type id SOAP_TYPE_xenc__CipherDataType */
	         xenc__CipherDataType();
	friend SOAP_FMAC1 xenc__CipherDataType * SOAP_FMAC2 soap_instantiate_xenc__CipherDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:62 */
#ifndef SOAP_TYPE_xenc__CipherReferenceType
#define SOAP_TYPE_xenc__CipherReferenceType (62)
/* xenc:CipherReferenceType complex type: */
struct xenc__CipherReferenceType
{
public:
	struct xenc__TransformsType *Transforms;	/* optional element of XSD type xenc:TransformsType */
	char *URI;	/* required attribute of XSD type xsd:string */
public:
	int soap_type() const { return 62; } /* = unique type id SOAP_TYPE_xenc__CipherReferenceType */
	         xenc__CipherReferenceType();
	friend SOAP_FMAC1 xenc__CipherReferenceType * SOAP_FMAC2 soap_instantiate_xenc__CipherReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:65 */
#ifndef SOAP_TYPE_xenc__TransformsType
#define SOAP_TYPE_xenc__TransformsType (63)
/* xenc:TransformsType complex type: */
struct xenc__TransformsType
{
public:
	struct ds__TransformType ds__Transform;	/* required element of XSD type ds:Transform */
public:
	int soap_type() const { return 63; } /* = unique type id SOAP_TYPE_xenc__TransformsType */
	         xenc__TransformsType();
	friend SOAP_FMAC1 xenc__TransformsType * SOAP_FMAC2 soap_instantiate_xenc__TransformsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:74 */
#ifndef SOAP_TYPE_xenc__AgreementMethodType
#define SOAP_TYPE_xenc__AgreementMethodType (66)
/* xenc:AgreementMethodType complex type: */
struct xenc__AgreementMethodType
{
public:
	char *KA_Nonce;	/* optional element of XSD type xsd:string */
	struct ds__KeyInfoType *OriginatorKeyInfo;	/* optional element of XSD type ds:KeyInfoType */
	struct ds__KeyInfoType *RecipientKeyInfo;	/* optional element of XSD type ds:KeyInfoType */
	char *Algorithm;	/* required attribute of XSD type xsd:string */
	char *__mixed;
public:
	int soap_type() const { return 66; } /* = unique type id SOAP_TYPE_xenc__AgreementMethodType */
	         xenc__AgreementMethodType();
	friend SOAP_FMAC1 xenc__AgreementMethodType * SOAP_FMAC2 soap_instantiate_xenc__AgreementMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:77 */
#ifndef SOAP_TYPE_xenc__ReferenceType
#define SOAP_TYPE_xenc__ReferenceType (67)
/* xenc:ReferenceType complex type: */
struct xenc__ReferenceType
{
public:
	char *URI;	/* required attribute of XSD type xsd:string */
public:
	int soap_type() const { return 67; } /* = unique type id SOAP_TYPE_xenc__ReferenceType */
	         xenc__ReferenceType();
	friend SOAP_FMAC1 xenc__ReferenceType * SOAP_FMAC2 soap_instantiate_xenc__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:80 */
#ifndef SOAP_TYPE_xenc__EncryptionPropertiesType
#define SOAP_TYPE_xenc__EncryptionPropertiesType (68)
/* xenc:EncryptionPropertiesType complex type: */
struct xenc__EncryptionPropertiesType
{
public:
	int __sizeEncryptionProperty;	/* sequence of elements <EncryptionProperty> of XSD type xenc:EncryptionPropertyType */
	struct xenc__EncryptionPropertyType *EncryptionProperty;
	char *Id;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 68; } /* = unique type id SOAP_TYPE_xenc__EncryptionPropertiesType */
	         xenc__EncryptionPropertiesType();
	friend SOAP_FMAC1 xenc__EncryptionPropertiesType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:238 */
#ifndef SOAP_TYPE___xenc__union_ReferenceList
#define SOAP_TYPE___xenc__union_ReferenceList (78)
/* Operation wrapper: */
struct __xenc__union_ReferenceList
{
public:
	struct xenc__ReferenceType *DataReference;	/* optional element of XSD type xenc:ReferenceType */
	struct xenc__ReferenceType *KeyReference;	/* optional element of XSD type xenc:ReferenceType */
public:
	int soap_type() const { return 78; } /* = unique type id SOAP_TYPE___xenc__union_ReferenceList */
	         __xenc__union_ReferenceList();
	friend SOAP_FMAC1 __xenc__union_ReferenceList * SOAP_FMAC2 soap_instantiate___xenc__union_ReferenceList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:89 */
#ifndef SOAP_TYPE__xenc__ReferenceList
#define SOAP_TYPE__xenc__ReferenceList (70)
/* xenc:ReferenceList complex type: */
struct _xenc__ReferenceList
{
public:
	int __size_ReferenceList;	/* sequence of elements <-union-ReferenceList> of XSD type -xenc:union-ReferenceList */
	struct __xenc__union_ReferenceList *__union_ReferenceList;
public:
	int soap_type() const { return 70; } /* = unique type id SOAP_TYPE__xenc__ReferenceList */
	         _xenc__ReferenceList();
	friend SOAP_FMAC1 _xenc__ReferenceList * SOAP_FMAC2 soap_instantiate__xenc__ReferenceList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:68 */
#ifndef SOAP_TYPE_xenc__EncryptedDataType
#define SOAP_TYPE_xenc__EncryptedDataType (64)
/* xenc:EncryptedDataType complex type: */
struct xenc__EncryptedDataType
{
public:
	struct xenc__EncryptionMethodType *EncryptionMethod;	/* optional element of XSD type xenc:EncryptionMethodType */
	struct ds__KeyInfoType *ds__KeyInfo;	/* optional element of XSD type ds:KeyInfo */
	struct xenc__CipherDataType *CipherData;	/* required element of XSD type xenc:CipherDataType */
	struct xenc__EncryptionPropertiesType *EncryptionProperties;	/* optional element of XSD type xenc:EncryptionPropertiesType */
	char *Id;	/* optional attribute of XSD type xsd:string */
	char *Type;	/* optional attribute of XSD type xsd:string */
	char *MimeType;	/* optional attribute of XSD type xsd:string */
	char *Encoding;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 64; } /* = unique type id SOAP_TYPE_xenc__EncryptedDataType */
	         xenc__EncryptedDataType();
	friend SOAP_FMAC1 xenc__EncryptedDataType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:71 */
#ifndef SOAP_TYPE_xenc__EncryptedKeyType
#define SOAP_TYPE_xenc__EncryptedKeyType (65)
/* xenc:EncryptedKeyType complex type: */
struct xenc__EncryptedKeyType
{
public:
	struct xenc__EncryptionMethodType *EncryptionMethod;	/* optional element of XSD type xenc:EncryptionMethodType */
	struct ds__KeyInfoType *ds__KeyInfo;	/* optional element of XSD type ds:KeyInfo */
	struct xenc__CipherDataType *CipherData;	/* required element of XSD type xenc:CipherDataType */
	struct xenc__EncryptionPropertiesType *EncryptionProperties;	/* optional element of XSD type xenc:EncryptionPropertiesType */
	char *Id;	/* optional attribute of XSD type xsd:string */
	char *Type;	/* optional attribute of XSD type xsd:string */
	char *MimeType;	/* optional attribute of XSD type xsd:string */
	char *Encoding;	/* optional attribute of XSD type xsd:string */
	struct _xenc__ReferenceList *ReferenceList;	/* optional element of XSD type xenc:ReferenceList */
	char *CarriedKeyName;	/* optional element of XSD type xsd:string */
	char *Recipient;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 65; } /* = unique type id SOAP_TYPE_xenc__EncryptedKeyType */
	         xenc__EncryptedKeyType();
	friend SOAP_FMAC1 xenc__EncryptedKeyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedKeyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:87 */
#ifndef SOAP_TYPE_wsc__SecurityContextTokenType
#define SOAP_TYPE_wsc__SecurityContextTokenType (84)
/* wsc:SecurityContextTokenType complex type: */
struct wsc__SecurityContextTokenType
{
public:
	char *wsu__Id;	/* optional attribute of XSD type xsd:string */
	char *Identifier;	/* optional element of XSD type xsd:string */
	char *Instance;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 84; } /* = unique type id SOAP_TYPE_wsc__SecurityContextTokenType */
	         wsc__SecurityContextTokenType();
	friend SOAP_FMAC1 wsc__SecurityContextTokenType * SOAP_FMAC2 soap_instantiate_wsc__SecurityContextTokenType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:125 */
#ifndef SOAP_TYPE__wsc__union_DerivedKeyTokenType
#define SOAP_TYPE__wsc__union_DerivedKeyTokenType (90)
/* xsd:choice complex type: */
union _wsc__union_DerivedKeyTokenType
{
#define SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation	(1)
	ULONG64 Generation;
#define SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset	(2)
	ULONG64 Offset;
};
#endif

/* wsc.h:116 */
#ifndef SOAP_TYPE___wsc__DerivedKeyTokenType_sequence
#define SOAP_TYPE___wsc__DerivedKeyTokenType_sequence (88)
/* Operation wrapper: */
struct __wsc__DerivedKeyTokenType_sequence
{
public:
	int __union_DerivedKeyTokenType;	/* union discriminant (of union defined below) */
	union _wsc__union_DerivedKeyTokenType union_DerivedKeyTokenType;
	ULONG64 *Length;	/* optional element of XSD type xsd:unsignedLong */
public:
	int soap_type() const { return 88; } /* = unique type id SOAP_TYPE___wsc__DerivedKeyTokenType_sequence */
	         __wsc__DerivedKeyTokenType_sequence();
	friend SOAP_FMAC1 __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC2 soap_instantiate___wsc__DerivedKeyTokenType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:109 */
#ifndef SOAP_TYPE_wsc__DerivedKeyTokenType
#define SOAP_TYPE_wsc__DerivedKeyTokenType (85)
/* wsc:DerivedKeyTokenType complex type: */
struct wsc__DerivedKeyTokenType
{
public:
	struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;	/* optional element of XSD type wsse:SecurityTokenReference */
	struct wsc__PropertiesType *Properties;	/* optional element of XSD type wsc:PropertiesType */
	struct __wsc__DerivedKeyTokenType_sequence *__DerivedKeyTokenType_sequence;
	char *Label;	/* optional element of XSD type xsd:string */
	char *Nonce;	/* optional element of XSD type xsd:string */
	char *wsu__Id;	/* optional attribute of XSD type xsd:string */
	char *Algorithm;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 85; } /* = unique type id SOAP_TYPE_wsc__DerivedKeyTokenType */
	         wsc__DerivedKeyTokenType();
	friend SOAP_FMAC1 wsc__DerivedKeyTokenType * SOAP_FMAC2 soap_instantiate_wsc__DerivedKeyTokenType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:113 */
#ifndef SOAP_TYPE_wsc__PropertiesType
#define SOAP_TYPE_wsc__PropertiesType (86)
/* wsc:PropertiesType complex type: */
struct wsc__PropertiesType
{
public:
	int soap_type() const { return 86; } /* = unique type id SOAP_TYPE_wsc__PropertiesType */
	         wsc__PropertiesType();
	friend SOAP_FMAC1 wsc__PropertiesType * SOAP_FMAC2 soap_instantiate_wsc__PropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:177 */
#ifndef SOAP_TYPE__wsse__Security
#define SOAP_TYPE__wsse__Security (93)
/* wsse:Security complex type: */
struct _wsse__Security
{
public:
	struct _wsu__Timestamp *wsu__Timestamp;	/* optional element of XSD type wsu:Timestamp */
	struct _wsse__UsernameToken *UsernameToken;	/* optional element of XSD type wsse:UsernameToken */
	struct _wsse__BinarySecurityToken *BinarySecurityToken;	/* optional element of XSD type wsse:BinarySecurityToken */
	struct xenc__EncryptedKeyType *xenc__EncryptedKey;	/* optional element of XSD type xenc:EncryptedKeyType */
	struct _xenc__ReferenceList *xenc__ReferenceList;	/* optional element of XSD type xenc:ReferenceList */
	struct wsc__SecurityContextTokenType *wsc__SecurityContextToken;	/* optional element of XSD type wsc:SecurityContextTokenType */
	struct ds__SignatureType *ds__Signature;	/* optional element of XSD type ds:SignatureType */
	char *SOAP_ENV__actor;	/* optional attribute of XSD type xsd:string */
	char *SOAP_ENV__role;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 93; } /* = unique type id SOAP_TYPE__wsse__Security */
	         _wsse__Security();
	friend SOAP_FMAC1 _wsse__Security * SOAP_FMAC2 soap_instantiate__wsse__Security(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:115 */
#ifndef SOAP_TYPE__wsse__Password
#define SOAP_TYPE__wsse__Password (12)
/* wsse:Password simple type: */
struct _wsse__Password
{
public:
	char *__item;	/* mixed XML content */
	char *Type;	/* optional attribute of XSD type xsd:string */
public:
	int soap_type() const { return 12; } /* = unique type id SOAP_TYPE__wsse__Password */
	         _wsse__Password();
	friend SOAP_FMAC1 _wsse__Password * SOAP_FMAC2 soap_instantiate__wsse__Password(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:207 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (100)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	struct _wsse__Security *wsse__Security;	/* mustUnderstand */
public:
	int soap_type() const { return 100; } /* = unique type id SOAP_TYPE_SOAP_ENV__Header */
	         SOAP_ENV__Header();
	friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* SCAP-ASService.h:174 */
#ifndef SOAP_TYPE_ns2__AttributeSupplierResponseType
#define SOAP_TYPE_ns2__AttributeSupplierResponseType (108)
/* ns2:AttributeSupplierResponseType complex type: */
class SOAP_CMAC ns2__AttributeSupplierResponseType
{
public:
	std::vector<ns3__AttributeSupplierType *> AttributeSupplier;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns3:AttributeSupplierType */
	std::string *ErrorMessage;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__AttributeSupplierResponseType (108)
	virtual int soap_type(void) const { return 108; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__AttributeSupplierResponseType, default initialized and not managed by a soap context
	virtual ns2__AttributeSupplierResponseType *soap_alloc(void) const { return SOAP_NEW(ns2__AttributeSupplierResponseType); }
	         ns2__AttributeSupplierResponseType() { ns2__AttributeSupplierResponseType::soap_default(NULL); }
	virtual ~ns2__AttributeSupplierResponseType() { }
	friend SOAP_FMAC1 ns2__AttributeSupplierResponseType * SOAP_FMAC2 soap_instantiate_ns2__AttributeSupplierResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-ASService.h:177 */
#ifndef SOAP_TYPE_ns3__AttributeType
#define SOAP_TYPE_ns3__AttributeType (109)
/* ns3:AttributeType complex type: */
class SOAP_CMAC ns3__AttributeType
{
public:
	ns3__AttributeSupplierType *AttributeSupplier;	/* required element of XSD type ns3:AttributeSupplierType */
	std::string Date;	/* required element of XSD type ns4:DateType */
	std::string Validity;	/* required element of XSD type ns4:ValidityType */
	ns3__PersonalDataType *PersonalData;	/* required element of XSD type ns3:PersonalDataType */
	ns3__MainAttributeType *MainAttribute;	/* required element of XSD type ns3:MainAttributeType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__AttributeType (109)
	virtual int soap_type(void) const { return 109; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__AttributeType, default initialized and not managed by a soap context
	virtual ns3__AttributeType *soap_alloc(void) const { return SOAP_NEW(ns3__AttributeType); }
	         ns3__AttributeType() { ns3__AttributeType::soap_default(NULL); }
	virtual ~ns3__AttributeType() { }
	friend SOAP_FMAC1 ns3__AttributeType * SOAP_FMAC2 soap_instantiate_ns3__AttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-ASService.h:180 */
#ifndef SOAP_TYPE_ns3__AttributeSupplierType
#define SOAP_TYPE_ns3__AttributeSupplierType (110)
/* ns3:AttributeSupplierType complex type: */
class SOAP_CMAC ns3__AttributeSupplierType
{
public:
	std::string Id;	/* required element of XSD type xsd:anyURI */
	std::string Name;	/* required element of XSD type ns4:NameType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__AttributeSupplierType (110)
	virtual int soap_type(void) const { return 110; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__AttributeSupplierType, default initialized and not managed by a soap context
	virtual ns3__AttributeSupplierType *soap_alloc(void) const { return SOAP_NEW(ns3__AttributeSupplierType); }
	         ns3__AttributeSupplierType() { ns3__AttributeSupplierType::soap_default(NULL); }
	virtual ~ns3__AttributeSupplierType() { }
	friend SOAP_FMAC1 ns3__AttributeSupplierType * SOAP_FMAC2 soap_instantiate_ns3__AttributeSupplierType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-ASService.h:183 */
#ifndef SOAP_TYPE_ns3__PersonalDataType
#define SOAP_TYPE_ns3__PersonalDataType (111)
/* ns3:PersonalDataType complex type: */
class SOAP_CMAC ns3__PersonalDataType
{
public:
	std::string Name;	/* required element of XSD type ns4:NameType */
	std::string NIC;	/* required element of XSD type ns4:NICType */
	ns3__ExtraIDListType *ExtraIDList;	/* optional element of XSD type ns3:ExtraIDListType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__PersonalDataType (111)
	virtual int soap_type(void) const { return 111; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__PersonalDataType, default initialized and not managed by a soap context
	virtual ns3__PersonalDataType *soap_alloc(void) const { return SOAP_NEW(ns3__PersonalDataType); }
	         ns3__PersonalDataType() { ns3__PersonalDataType::soap_default(NULL); }
	virtual ~ns3__PersonalDataType() { }
	friend SOAP_FMAC1 ns3__PersonalDataType * SOAP_FMAC2 soap_instantiate_ns3__PersonalDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-ASService.h:186 */
#ifndef SOAP_TYPE_ns3__ExtraIDListType
#define SOAP_TYPE_ns3__ExtraIDListType (112)
/* ns3:ExtraIDListType complex type: */
class SOAP_CMAC ns3__ExtraIDListType
{
public:
	std::vector<ns3__ExtraIDType *> ExtraID;	/* required element of XSD type ns3:ExtraIDType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__ExtraIDListType (112)
	virtual int soap_type(void) const { return 112; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__ExtraIDListType, default initialized and not managed by a soap context
	virtual ns3__ExtraIDListType *soap_alloc(void) const { return SOAP_NEW(ns3__ExtraIDListType); }
	         ns3__ExtraIDListType() { ns3__ExtraIDListType::soap_default(NULL); }
	virtual ~ns3__ExtraIDListType() { }
	friend SOAP_FMAC1 ns3__ExtraIDListType * SOAP_FMAC2 soap_instantiate_ns3__ExtraIDListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-ASService.h:189 */
#ifndef SOAP_TYPE_ns3__ExtraIDType
#define SOAP_TYPE_ns3__ExtraIDType (113)
/* ns3:ExtraIDType complex type: */
class SOAP_CMAC ns3__ExtraIDType
{
public:
	std::string Name;	/* required element of XSD type ns4:NameType */
	std::string Value;	/* required element of XSD type ns4:ExtraIDValueType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__ExtraIDType (113)
	virtual int soap_type(void) const { return 113; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__ExtraIDType, default initialized and not managed by a soap context
	virtual ns3__ExtraIDType *soap_alloc(void) const { return SOAP_NEW(ns3__ExtraIDType); }
	         ns3__ExtraIDType() { ns3__ExtraIDType::soap_default(NULL); }
	virtual ~ns3__ExtraIDType() { }
	friend SOAP_FMAC1 ns3__ExtraIDType * SOAP_FMAC2 soap_instantiate_ns3__ExtraIDType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-ASService.h:192 */
#ifndef SOAP_TYPE_ns3__MainAttributeType
#define SOAP_TYPE_ns3__MainAttributeType (114)
/* ns3:MainAttributeType complex type: */
class SOAP_CMAC ns3__MainAttributeType
{
public:
	std::string AttributeID;	/* required element of XSD type ns4:AttributeIDType */
	std::string *Description;	/* optional element of XSD type ns4:DescriptionType */
	ns3__LegalActListType *LegalActList;	/* optional element of XSD type ns3:LegalActListType */
	ns3__SubAttributeListType *SubAttributeList;	/* optional element of XSD type ns3:SubAttributeListType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__MainAttributeType (114)
	virtual int soap_type(void) const { return 114; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__MainAttributeType, default initialized and not managed by a soap context
	virtual ns3__MainAttributeType *soap_alloc(void) const { return SOAP_NEW(ns3__MainAttributeType); }
	         ns3__MainAttributeType() { ns3__MainAttributeType::soap_default(NULL); }
	virtual ~ns3__MainAttributeType() { }
	friend SOAP_FMAC1 ns3__MainAttributeType * SOAP_FMAC2 soap_instantiate_ns3__MainAttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-ASService.h:195 */
#ifndef SOAP_TYPE_ns3__LegalActListType
#define SOAP_TYPE_ns3__LegalActListType (115)
/* ns3:LegalActListType complex type: */
class SOAP_CMAC ns3__LegalActListType
{
public:
	std::vector<std::string> LegalAct;	/* required element of XSD type ns4:LegalActType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__LegalActListType (115)
	virtual int soap_type(void) const { return 115; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__LegalActListType, default initialized and not managed by a soap context
	virtual ns3__LegalActListType *soap_alloc(void) const { return SOAP_NEW(ns3__LegalActListType); }
	         ns3__LegalActListType() { ns3__LegalActListType::soap_default(NULL); }
	virtual ~ns3__LegalActListType() { }
	friend SOAP_FMAC1 ns3__LegalActListType * SOAP_FMAC2 soap_instantiate_ns3__LegalActListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-ASService.h:198 */
#ifndef SOAP_TYPE_ns3__SubAttributeListType
#define SOAP_TYPE_ns3__SubAttributeListType (116)
/* ns3:SubAttributeListType complex type: */
class SOAP_CMAC ns3__SubAttributeListType
{
public:
	std::vector<ns3__SubAttributeType *> SubAttribute;	/* required element of XSD type ns3:SubAttributeType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__SubAttributeListType (116)
	virtual int soap_type(void) const { return 116; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__SubAttributeListType, default initialized and not managed by a soap context
	virtual ns3__SubAttributeListType *soap_alloc(void) const { return SOAP_NEW(ns3__SubAttributeListType); }
	         ns3__SubAttributeListType() { ns3__SubAttributeListType::soap_default(NULL); }
	virtual ~ns3__SubAttributeListType() { }
	friend SOAP_FMAC1 ns3__SubAttributeListType * SOAP_FMAC2 soap_instantiate_ns3__SubAttributeListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-ASService.h:201 */
#ifndef SOAP_TYPE_ns3__SubAttributeType
#define SOAP_TYPE_ns3__SubAttributeType (117)
/* ns3:SubAttributeType complex type: */
class SOAP_CMAC ns3__SubAttributeType
{
public:
	std::string AttributeID;	/* required element of XSD type ns4:AttributeIDType */
	std::string *Description;	/* optional element of XSD type ns4:DescriptionType */
	std::string *Value;	/* optional element of XSD type ns4:SubAttributeValueType */
	ns3__LegalActListType *LegalActList;	/* optional element of XSD type ns3:LegalActListType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__SubAttributeType (117)
	virtual int soap_type(void) const { return 117; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__SubAttributeType, default initialized and not managed by a soap context
	virtual ns3__SubAttributeType *soap_alloc(void) const { return SOAP_NEW(ns3__SubAttributeType); }
	         ns3__SubAttributeType() { ns3__SubAttributeType::soap_default(NULL); }
	virtual ~ns3__SubAttributeType() { }
	friend SOAP_FMAC1 ns3__SubAttributeType * SOAP_FMAC2 soap_instantiate_ns3__SubAttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-ASService.h:204 */
#ifndef SOAP_TYPE_ns3__ResponseCodeStatusType
#define SOAP_TYPE_ns3__ResponseCodeStatusType (118)
/* ns3:ResponseCodeStatusType complex type: */
class SOAP_CMAC ns3__ResponseCodeStatusType
{
public:
	std::string Code;	/* required element of XSD type ns4:ResponseCodeType */
	std::string *Message;	/* optional element of XSD type ns4:ResponseCodeMessage */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__ResponseCodeStatusType (118)
	virtual int soap_type(void) const { return 118; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__ResponseCodeStatusType, default initialized and not managed by a soap context
	virtual ns3__ResponseCodeStatusType *soap_alloc(void) const { return SOAP_NEW(ns3__ResponseCodeStatusType); }
	         ns3__ResponseCodeStatusType() { ns3__ResponseCodeStatusType::soap_default(NULL); }
	virtual ~ns3__ResponseCodeStatusType() { }
	friend SOAP_FMAC1 ns3__ResponseCodeStatusType * SOAP_FMAC2 soap_instantiate_ns3__ResponseCodeStatusType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-ASService.h:782 */
#ifndef SOAP_TYPE___ns1__AttributeSuppliers
#define SOAP_TYPE___ns1__AttributeSuppliers (152)
/* Operation wrapper: */
struct __ns1__AttributeSuppliers
{
public:
	int soap_type() const { return 152; } /* = unique type id SOAP_TYPE___ns1__AttributeSuppliers */
	         __ns1__AttributeSuppliers();
	friend SOAP_FMAC1 __ns1__AttributeSuppliers * SOAP_FMAC2 soap_instantiate___ns1__AttributeSuppliers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-ASService.h:855 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (153)
/* Type SOAP_ENV__Code is a recursive data type (in)directly referencing itself through its (base) class members */
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of XSD type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of XSD type SOAP-ENV:Code */
public:
	int soap_type() const { return 153; } /* = unique type id SOAP_TYPE_SOAP_ENV__Code */
	         SOAP_ENV__Code();
	friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* SCAP-ASService.h:855 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (155)
/* SOAP-ENV:Detail complex type: */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below)
	   WARNING: do not create a cyclic data structure graph throught this element unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
	void *fault;	/* transient (not serialized) */
public:
	int soap_type() const { return 155; } /* = unique type id SOAP_TYPE_SOAP_ENV__Detail */
	         SOAP_ENV__Detail();
	friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* SCAP-ASService.h:855 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (158)
/* SOAP-ENV:Reason complex type: */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 158; } /* = unique type id SOAP_TYPE_SOAP_ENV__Reason */
	         SOAP_ENV__Reason();
	friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* SCAP-ASService.h:855 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (159)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of XSD type xsd:QName */
	char *faultstring;	/* optional element of XSD type xsd:string */
	char *faultactor;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of XSD type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of XSD type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of XSD type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of XSD type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of XSD type SOAP-ENV:Detail */
public:
	int soap_type() const { return 159; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault */
	         SOAP_ENV__Fault();
	friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* SCAP-ASService.h:101 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* SCAP-ASService.h:101 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/* ds.h:51 */
#ifndef SOAP_TYPE__ds__Signature
#define SOAP_TYPE__ds__Signature (29)
typedef struct ds__SignatureType _ds__Signature;
#endif

/* ds.h:77 */
#ifndef SOAP_TYPE__ds__Transform
#define SOAP_TYPE__ds__Transform (37)
typedef struct ds__TransformType _ds__Transform;
#endif

/* ds.h:91 */
#ifndef SOAP_TYPE__ds__KeyInfo
#define SOAP_TYPE__ds__KeyInfo (44)
typedef struct ds__KeyInfoType _ds__KeyInfo;
#endif

/* wsc.h:57 */
#ifndef SOAP_TYPE_wsc__FaultCodeOpenEnumType
#define SOAP_TYPE_wsc__FaultCodeOpenEnumType (82)
typedef char *wsc__FaultCodeOpenEnumType;
#endif

/* SCAP-ASService.h:160 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (106)
typedef std::string xsd__anyURI;
#endif

/* SCAP-ASService.h:163 */
#ifndef SOAP_TYPE_xsd__date
#define SOAP_TYPE_xsd__date (107)
typedef std::string xsd__date;
#endif

/* SCAP-ASService.h:241 */
#ifndef SOAP_TYPE_ns4__ProcessIDType
#define SOAP_TYPE_ns4__ProcessIDType (119)
typedef std::string ns4__ProcessIDType;
#endif

/* SCAP-ASService.h:246 */
#ifndef SOAP_TYPE_ns4__NameType
#define SOAP_TYPE_ns4__NameType (120)
typedef std::string ns4__NameType;
#endif

/* SCAP-ASService.h:250 */
#ifndef SOAP_TYPE_ns4__ValidityType
#define SOAP_TYPE_ns4__ValidityType (121)
typedef xsd__date ns4__ValidityType;
#endif

/* SCAP-ASService.h:254 */
#ifndef SOAP_TYPE_ns4__DateType
#define SOAP_TYPE_ns4__DateType (122)
typedef xsd__date ns4__DateType;
#endif

/* SCAP-ASService.h:259 */
#ifndef SOAP_TYPE_ns4__NICType
#define SOAP_TYPE_ns4__NICType (123)
typedef std::string ns4__NICType;
#endif

/* SCAP-ASService.h:264 */
#ifndef SOAP_TYPE_ns4__NIPCType
#define SOAP_TYPE_ns4__NIPCType (124)
typedef std::string ns4__NIPCType;
#endif

/* SCAP-ASService.h:269 */
#ifndef SOAP_TYPE_ns4__CompanyNameType
#define SOAP_TYPE_ns4__CompanyNameType (125)
typedef std::string ns4__CompanyNameType;
#endif

/* SCAP-ASService.h:274 */
#ifndef SOAP_TYPE_ns4__ExtraIDValueType
#define SOAP_TYPE_ns4__ExtraIDValueType (126)
typedef std::string ns4__ExtraIDValueType;
#endif

/* SCAP-ASService.h:279 */
#ifndef SOAP_TYPE_ns4__AttributeIDType
#define SOAP_TYPE_ns4__AttributeIDType (127)
typedef std::string ns4__AttributeIDType;
#endif

/* SCAP-ASService.h:284 */
#ifndef SOAP_TYPE_ns4__LegalActType
#define SOAP_TYPE_ns4__LegalActType (128)
typedef std::string ns4__LegalActType;
#endif

/* SCAP-ASService.h:289 */
#ifndef SOAP_TYPE_ns4__SubAttributeValueType
#define SOAP_TYPE_ns4__SubAttributeValueType (129)
typedef std::string ns4__SubAttributeValueType;
#endif

/* SCAP-ASService.h:294 */
#ifndef SOAP_TYPE_ns4__DescriptionType
#define SOAP_TYPE_ns4__DescriptionType (130)
typedef std::string ns4__DescriptionType;
#endif

/* SCAP-ASService.h:299 */
#ifndef SOAP_TYPE_ns4__ResponseCodeType
#define SOAP_TYPE_ns4__ResponseCodeType (131)
typedef std::string ns4__ResponseCodeType;
#endif

/* SCAP-ASService.h:304 */
#ifndef SOAP_TYPE_ns4__ResponseCodeMessage
#define SOAP_TYPE_ns4__ResponseCodeMessage (132)
typedef std::string ns4__ResponseCodeMessage;
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
